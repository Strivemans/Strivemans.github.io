<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梁伟杰的代码之旅</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-07T03:03:55.609Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>jackCoding</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springBoot整合MybatisPlus</title>
    <link href="http://example.com/20221/03/06/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/SpringBoot%20%E6%95%B4%E5%90%88%20MybatisPlus/"/>
    <id>http://example.com/20221/03/06/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/SpringBoot%20%E6%95%B4%E5%90%88%20MybatisPlus/</id>
    <published>+020221-03-06T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/%E7%9B%AE%E5%BD%95%E6%9E%B6%E6%9E%84.png"></p><h3 id="一、创建springBoot项目"><a href="#一、创建springBoot项目" class="headerlink" title="一、创建springBoot项目"></a>一、创建springBoot项目</h3><p><img src="/%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE01.png"></p><p><img src="/%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE02.png"></p><p><img src="/%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE03.png"></p><p><img src="/%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE04.png"></p><h3 id="二、引入项目依赖"><a href="#二、引入项目依赖" class="headerlink" title="二、引入项目依赖"></a>二、引入项目依赖</h3><p><img src="/%E4%BF%AE%E6%94%B9Maven.png"></p><p><img src="/mavenBug01.png"></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-plus 依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-annotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、配置application-properties"><a href="#三、配置application-properties" class="headerlink" title="三、配置application.properties"></a>三、配置application.properties</h3><p><img src="/%E9%85%8D%E7%BD%AEapplication.properties.png"></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动类端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#配置数据库连接信息</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/student?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#配置 mybatis-plus的mapper文件</span></span><br><span class="line"><span class="attr">mybatis-plus.mapper-locations</span>=<span class="string">classpath*:com/jack/learn/mapper/xml/*.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#可以让 swagger-ui 正常运行</span></span><br><span class="line"><span class="attr">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">ant_path_matcher</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#在控制台打印sql语句</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h3 id="四、正式编码"><a href="#四、正式编码" class="headerlink" title="四、正式编码"></a>四、正式编码</h3><ul><li><h4 id="1-编写实体-学生-类"><a href="#1-编写实体-学生-类" class="headerlink" title="1. 编写实体(学生)类"></a>1. 编写实体(学生)类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:30</span></span><br><span class="line"><span class="comment"> * 学生 实体类 与 数据库一一对应</span></span><br><span class="line"><span class="comment"> * 其中 mybatis-plus 可以 自动识别驼峰命名规则(既 数据库stu_name 则 java为 stuName)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//lombok注解，可让实体类自动生成 get set 构造器</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;Student对象&quot;,description = &quot;学生&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;学生ID&quot;)</span></span><br><span class="line">    <span class="comment">//设置 id为全局唯一 不能重复id</span></span><br><span class="line">    <span class="comment">//@TableId(value = &quot;id&quot;,type = IdType.ID_WORKER)</span></span><br><span class="line">    <span class="comment">//如果id值在 数据库中设置了自增索引 那么就要使用这个</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;学生姓名&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> String stuName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;学生电话&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> String stuTel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;学生年龄&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> stuAge;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;学生地址&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> String stuAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;学生性别&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> String stuSex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;学生的学院&quot;)</span></span><br><span class="line">     <span class="keyword">private</span> String facultyName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@TableField(fill = FieldFill.INSERT) 与 @TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="comment">//需要 编写对应的配置文件才能有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">     <span class="comment">// 设置创建时间属性 在添加时 自动添加</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="comment">//设置 修改时间属性 在修改时 自动添加</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写@TableField(fill &#x3D; FieldFill.INSERT) 与 @TableField(fill &#x3D; FieldFill.INSERT_UPDATE) 的配置文件. </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/28 8:45</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用于 对 实体类的自动填写时间进行配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@TableField</span>(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandle</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加student 时，进行设置 添加时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改student 时，进行修改时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="2-编写Mapper-xml文件"><a href="#2-编写Mapper-xml文件" class="headerlink" title="2. 编写Mapper.xml文件"></a>2. 编写Mapper.xml文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主要用来 编写一些 自定义的sql语句。默认的 增上改查 mybatis-plus 已经封装好了--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.jack.learn.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写Mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:56</span></span><br><span class="line"><span class="comment"> * 学生类的 mapper类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//通过 继承 mybatis-plus 的 BaseMapper类 来快速实现 基本的增删改查</span></span><br><span class="line"><span class="comment">//BaseMapper&lt;Student&gt; 继承 BaseMapper 泛型是 数据库对应的 java实体类</span></span><br><span class="line"><span class="keyword">public</span>  StudentMapper <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Student&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="3-编写Service层"><a href="#3-编写Service层" class="headerlink" title="3.  编写Service层"></a>3.  编写Service层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 21:08</span></span><br><span class="line"><span class="comment"> * 学生 的 服务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//通过 继承 mybatis-plus 得IService 来 快速实现 增删改查的 服务方法</span></span><br><span class="line"><span class="keyword">public</span>  StudentService <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Student&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 21:10</span></span><br><span class="line"><span class="comment"> * 学生 的 服务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// 通过 继承 ServiceImpl 来快速生成 增上改查的功能 也实现了 StudentService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;StudentMapper, Student&gt; <span class="keyword">implements</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="4-编写Controller层"><a href="#4-编写Controller层" class="headerlink" title="4. 编写Controller层"></a>4. 编写Controller层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 16:08</span></span><br><span class="line"><span class="comment"> * 学生控制层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">//RestController 相当于 Controller + ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/student&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span> <span class="comment">//跨域 不然数据传输不到前端</span></span><br><span class="line"><span class="meta">@Api(description = &quot;学生管理&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span>  <span class="comment">//加入spring 管理</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加学生</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;添加学生&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;addStudent&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R  <span class="title function_">addTeacher</span><span class="params">(<span class="meta">@ApiParam(name = &quot;Student&quot;,value = &quot;学生信息&quot;,required = true)</span> <span class="meta">@RequestBody</span> Student student)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> result=studentService.save(student);  <span class="comment">//save 就是 mypatis-pius的 自带方法</span></span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            <span class="keyword">return</span> R.ok();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查询学生</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;根据id查询学生&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;selectById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">selectById</span><span class="params">(<span class="meta">@ApiParam(name = &quot;id&quot;,value = &quot;学生id&quot;,required = true)</span> <span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        Student student=studentService.getById(id); <span class="comment">//getById 就是 mypatis-pius的 自带方法</span></span><br><span class="line">        <span class="keyword">return</span> R.ok().data(<span class="string">&quot;student&quot;</span>,student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="五、启动类"><a href="#五、启动类" class="headerlink" title="五、启动类"></a>五、启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ComponentScan :组件扫描, 例如 @controller、@Service 等等</span></span><br><span class="line"><span class="comment">//@MapperScan: 主要是用来扫描 mapper类的注解，这样就不用每个mapper类 都配置@MapperScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.jack.learn&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//要在 启动类添加 swagger-ui的 启动</span></span><br><span class="line"><span class="comment">//该注解 可以自动扫描该包下面的全部注解,需要把包准确扫描到 mapper类所在的包 .mapper</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages =&quot;com.jack.learn.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentdemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(StudentdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/%E7%9B%AE%E5%BD%95%E6%9E%B6%E6%9E%84.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、创建springBoot项目&quot;&gt;&lt;a href=&quot;#一、创建springBoot项目&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="-Java -框架" scheme="http://example.com/tags/Java-%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-09-20T07:18:43.613Z</published>
    <updated>2023-04-07T03:03:55.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实习生面试题"><a href="#实习生面试题" class="headerlink" title="实习生面试题"></a>实习生面试题</h2><ol><li><h1 id="java面向对象的三个特性-以及它们的含义"><a href="#java面向对象的三个特性-以及它们的含义" class="headerlink" title="java面向对象的三个特性 以及它们的含义"></a>java面向对象的三个特性 以及它们的含义</h1><ul><li>封装： 就是把 一个 对象 中的 细节数据隐藏起来，控制它们读和写的权限 通过 get&#x2F;set方法进行获取与设置</li><li>继承：就是把 两个类之间存在 父与子的关系。 子类是诞生于父类，拥有父类的属性和行为，并且还有自己独特的行为。而父类则充当共有的行为特征。比如动物是父类，而鸟是动物的子类。</li><li>多态：表示同一个行为，表现在不同的对象 会有不同的特征。 例如 动物的 叫声。</li></ul></li><li><h2 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 与 equals 的区别"></a>&#x3D;&#x3D; 与 equals 的区别</h2><p>&#x3D;&#x3D; 通常用于比较两者的 内存引用地址是否相等。 而equals则通常用于比较两者的 值是否相等。 在Object对象中， equals 和 &#x3D;&#x3D; 的功能是一样的。 但是，通常 许多的 类型类 都会继承 Object类 并重写了 equals方法 ，使其变成比较两个值大小的功能。例如 String 类。</p></li><li><h2 id="String-、StringBuffer、StringBuilder的区别"><a href="#String-、StringBuffer、StringBuilder的区别" class="headerlink" title="String 、StringBuffer、StringBuilder的区别"></a>String 、StringBuffer、StringBuilder的区别</h2><p>String 是一个 final类，每修改一次 则相当于 创建了一个对象</p><p>StringBuffer 是 一个线程不安全的 类，性能高</p><p>StringBuilder 因为继承了 synchronized 修饰 所以是线程安全的，但是性能就是减低</p></li><li><h2 id="ArrayList-与-LinkedList-的区别"><a href="#ArrayList-与-LinkedList-的区别" class="headerlink" title="ArrayList 与 LinkedList 的区别"></a>ArrayList 与 LinkedList 的区别</h2><p>它们在底层的数据结构上就不同，从名字就可以看出，ArrayList 是 采用动态数组实现的。它可以存储任何类型的 数据，当数组满了之后，会创建一个新的数组 并采用尾插法的方式 加入到 原来的数组中</p><p>而 LinkedList 底层就是采用 链表的结构，链表的特性就是 增删的效率快，而查询的效率慢。并且只能使用iteartor来进行遍历</p></li><li><h2 id="什么叫IOC容器"><a href="#什么叫IOC容器" class="headerlink" title="什么叫IOC容器"></a>什么叫IOC容器</h2><p>ioc容器的主要功能就是把 创建对象的权利 交给 容器去处理，这个容器 就叫IOC容器。 </p><p>那么 ，为什么需要ioc容器呢，因在，如果没有ioc容器，就意味着 每一个对象都需要我们去创建，这样是不利于我们后期的修改的。其中，spring就是一个ioc的容器，主要是三层 dao、service、controller层，service调用dao 而controller调用service ，其中就要我们去创建对象。这样会创建许多重复的对象，资源浪费。</p><p>使用spring 则可以通过注解的形式 对 bean进行依赖注入。把创建对象的权力 交给 ioc容器。</p><p>如果自己创建一个IOC容器</p><p>配置文件 配置包 扫描路径</p><p>递归包 去 扫描 .class文件</p><p>反射， 确定需要交给ioc容器管理的类</p><p>最后 依赖注入(get&#x2F; set)</p></li><li><h2 id="AOP的含义"><a href="#AOP的含义" class="headerlink" title="AOP的含义"></a>AOP的含义</h2><p>aop 即 面向切面编程。 什么叫面向切面呢 ，就当我们实现一个功能时，我们想要在实现这个功能之前或者之后去处理一些前置任务或者后置处理等功能时，就可以使用aop去进行处理。aop通常也可以叫做通知，主要有前置、后置、环绕、异常四个通知，根据不同的情况去在对应的通知中进行逻辑代码的编写。</p></li><li><h2 id="hashMap的特性"><a href="#hashMap的特性" class="headerlink" title="hashMap的特性"></a>hashMap的特性</h2><p>在jdk1.8之后 ，hashMap的底层数据结构时 数组+链表+红黑树组成的，</p><p>它呢 是无序、线程不安全、key允许为null、key不能重复的一些特点。</p><p>当 向hashmap对象进行put方法存储数据时，根据 key的值 用 hashCode（）方法去 得到这key值得 hashCode值，根据该值去 存储到 数组对应得下标（hash%16）。如果该 hashCode值相同，并且key值不相等，就会在数组该索引得地方构建衍生一个链表结构，</p><p>随着数据存入越来越多，链表和数组可能就会存满，这是就会有扩容机制。</p><p>数组得扩容：通常不会存满数组的长度才扩容，而是在数组长度的0.75 时，就会出发扩容 ，每次扩容会扩容为原来长度的2倍。</p><p>链表变化： 当链表的长度达到8后，就会使链表变成红黑树结构。</p><p>使用红黑树是为了二叉查找树的缺陷， 二叉查找树在特殊的情况下可能就变成线性结构，这样遍历查询的速度就更慢了。 而红黑树为了保持二叉树的平衡 会有 左旋、右旋、变色等操作。使用红黑树 就是为了 解决 查找速度的问题。而创建红黑树本身也需要损耗资源，所以如果长度不长的情况下，就不需要使用红黑树。</p></li><li><h2 id="Mysql事务的四大特性"><a href="#Mysql事务的四大特性" class="headerlink" title="Mysql事务的四大特性"></a>Mysql事务的四大特性</h2><ul><li>原子性： 事务作为一个整体存在，执行就要么执行完成，要么就不执行（undo log）</li><li>一致性：事务开始后，不论对数据做出怎样的改变，在没有结束之前，都不会去干扰到原来的数据。( 回滚、回复、并发情况的隔离性)</li><li>隔离性：当事务并发执行时，两者是互不干扰的。（锁、MVCC）</li><li>永久性：当事务执行完毕后，对数据的改变是永久保存在数据库中。（redo log）</li></ul></li><li><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul><li>读未提交： 最低级别，任何情况都无法保证</li><li>读已提交： 可预防脏读</li><li>可重复读：预防脏读、不可重复读（默认事务级别）</li><li>串行化： 预防幻读、脏读、不可重复读</li></ul></li><li><h2 id="脏读、不可重复读、幻读的含义"><a href="#脏读、不可重复读、幻读的含义" class="headerlink" title="脏读、不可重复读、幻读的含义"></a>脏读、不可重复读、幻读的含义</h2><ul><li>脏读：当其中一个事务涉及到a数据修改，但还没提交，但是另一个事务 却读到了 它修改而没提交的a数据状态。</li><li>不可重复读： 在进行事务时，a数据在不同时刻的值是不一样的，因为 其它事务可能对a进行了修改。</li><li>幻读： 比如说，当事务中，我需要去select 某项数据是否存在， 如果存在，则 添加某项数据。 那么我这个select判断的状态 可能会不同。</li></ul></li><li><h2 id="group-by-与-distinct的区别"><a href="#group-by-与-distinct的区别" class="headerlink" title="group by 与 distinct的区别"></a>group by 与 distinct的区别</h2><p>这两个关键字 主要都是用于筛选重复数据使用的。</p><p>它们的区别：对数据逻辑处理的不同，group by 是 先得到结果集, 然后进行筛选。 而distinct 则相反</p><p>其次呢，gourpby 可以对 某个字段 去分组刷选， 而distinct 则是对所有字段进行筛选。</p></li><li><h2 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h2><p>常见的有MyISAM、innoDB、MEMORY、ARCHIVE</p><p>mysql 5.5版本 默认采用 innoDB</p></li><li><h2 id="innoDB-与-myISAM-的区别"><a href="#innoDB-与-myISAM-的区别" class="headerlink" title="innoDB 与  myISAM 的区别"></a>innoDB 与  myISAM 的区别</h2><ul><li><p>事务</p><p>innoDB支持索引 而 myISAM不支持</p></li><li><p>表锁</p><p>myISAM 只支持 表锁</p><p>而 innoDB 支持 事务 和 行级锁。 行级锁可以让事务在多用户并发的情况下，增加性能。但是，只有在索引上 才可能是行锁。其他情况 依然是 表级锁</p></li><li><p>索引</p><p>innoDB 与 myISAM 都是采用 b+树的形式作为索引结构，但是 叶节点的 data域 存放的数据不同。</p><p>myISAM 是存放 数据存储的地址，即 数据文件 与 索引文件是分开的，当 myISAM 检索 索引时，采用b+树算法检索到索引，然后 指定的 key存在 ，取出data域的值作为地址 ，读取相对应得 查询记录。这种 也叫 非聚集</p><p>而 innoDB 得 索引文件 就是 数据文件， 查询到key 拿到data域得值 就是 要查询得数据。</p></li><li><p>表行</p><p>myISAM 保存有表行 查询表行 可以直接获得 </p><p>而 innoDB 则需要 遍历，再得出结果。 不过 如果加了where条件  这两者的处理方式就是一样的 都需要先遍历。</p></li><li><p>主键</p><p>myISAM 可以不定义主键 ，主键 就是 保存行的地址</p><p>而 innoDB 则需要 有一个 非空的唯一主键索引，如果在创建表时，没有自定义主键，那么 innoDB 就会自动为这个表生成一个 6字节的主键（用户看不到） </p></li><li><p>外键</p><p>innoDB 支持 外键</p><p>myISAM 不支持</p></li></ul></li><li><h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><p>数据表中的每一列 都不可以 再拆分</p><p>在第一范式的基础上， 每一个非主键 要 完全依赖于 主键</p><p>在第二范式的基础上， 表中的 非主键 只依赖于 主键。</p></li><li><h2 id="什么是存储结构-优缺点是啥"><a href="#什么是存储结构-优缺点是啥" class="headerlink" title="什么是存储结构 优缺点是啥"></a>什么是存储结构 优缺点是啥</h2><p>存储结构 就是把 编译好的sql语句 组成 一个函数 ，给他们自定义一个名字 ，这样下次就像调用方法一样 调用该存储结构 就会执行 里面 的sql语句</p><p>好处：减少sql重复编写， 因为存储结构就是 预编译好的代码块 所以 可以 提升执行效率，还可以保证 数据的安全。</p><p>缺点： 可移植性不灵活，调试麻烦。</p></li><li><h2 id="日常开发-怎么-优化sql"><a href="#日常开发-怎么-优化sql" class="headerlink" title="日常开发 怎么 优化sql"></a>日常开发 怎么 优化sql</h2><ul><li><p>添加合适的索引</p><p>对 所以查询条件 或者 group by 的字段 添加索引</p><p>如果是有多个查询字段的话 可以对这些字段建立 组合索引，把查询次数最多的放在最左边 依次 递减。</p><p>索引不宜太多 5个以内</p></li><li><p>调整优化 表的结构</p><p>选择正确的 表字段类型 ，比如 可以用数字类型的 就不用 字符串类型。尽量使用 not null 约束。</p></li><li><p>优化查询的语句</p></li></ul></li><li><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>优点：减少数据库的io成本 提升 查询的效率</p><p>缺点： 创建索引 会 占用物理空间，并且 会对增删改的效率会有影响。每次的增删改 都要去维护 索引。</p></li><li><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>索引主要有5种，普通索引、唯一索引、主键索引、全文索引、组合索引</p><p>普通索引： 就是 没有限制的索引</p><p>唯一索引： 被标注为唯一索引的字段，值不能相同，但可以为null</p><p>主键索引：一个表 通常只能有一个主键索引，不能为null</p><p>组合索引： 一个索引 包含有多个列</p><p>全文索引： 只能用在 char varchar text 的字段类型，</p></li><li><h2 id="索引的数据结构有哪些"><a href="#索引的数据结构有哪些" class="headerlink" title="索引的数据结构有哪些"></a>索引的数据结构有哪些</h2><p>主要有两者 hash索引 和 b+树索引</p></li><li><h2 id="HashCode的意义和作用"><a href="#HashCode的意义和作用" class="headerlink" title="HashCode的意义和作用"></a>HashCode的意义和作用</h2><p>hashCode方法的主要意义 就是 让同一个对象的 不同特征尽量拥有不同的hashCode值 让他们得以区分。</p><p>其次 hashode方法 与 equals（）方法有着关联,这也是 equals 的判定值是否相等的关键。</p><p>equals 相等 则 hashCode 必须相等</p><p>hashCode相等 equals 未必true</p><p>equals false hashCode 必须 不相等</p></li><li><h2 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring"></a>什么是spring</h2><p>spring 是一个轻量型（核心包只有不到1m，上手简单）的容器框架，它的作用就是 用来装javaBean 以及 作为一个中间层框架的存在（可以连接其它的框架 如 springMVC 、 mybatis）。 简单来说，就是一个 ioc 和 aop的 容器框架。</p></li><li><h2 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a>Java8的新特性</h2><ul><li><p>接口 可以存在 非抽象方法。</p></li><li><p>有了lambda表达式，减少代码冗余</p></li><li><p>有函数式接口 即 只有一个抽象方法的接口 ，可以用注解 @FunctionInterface 来标识</p><p>消费性接口 Consumer<T>  void accept(T t)</p><p>供给性接口 Supplier<T> T get()</p><p>函数性接口 Function&lt;T,R&gt; R apply(T t)</p><p>断定型接口 Predicate<T> boolean test(T t)</p></li><li><p>有了方法引用，可以直接引用Java类的 方法 和 构造器。简化lambda表达式。</p></li><li><p>stream流 用于解决conllection的弊端，可以简化它们的弊端，如 foreach遍历、filter筛选、map映射、concat合并。</p></li></ul></li><li><h2 id="反射的基本概念、优缺点、使用场景"><a href="#反射的基本概念、优缺点、使用场景" class="headerlink" title="反射的基本概念、优缺点、使用场景"></a>反射的基本概念、优缺点、使用场景</h2><p>反射 即 当一个类在运行状态中，可以随时获取它的属性和方法，并且使用。这种动态的获取类的信息就叫做反射。</p><p>优点：就是可以动态的 访问类的属性和方法</p><p>缺点：破坏了Java的特性，比如封装性。</p><p>使用场景：在 一些框架中经常会用 反射来实现动态代理的设计。如Spring。通常是用 配置文件来写入信息，那么反射就可以通过配置文件来 动态的处理类相关的属性和方法了。</p></li><li><h2 id="通过反射获取对象的方法，可以获得哪些信息"><a href="#通过反射获取对象的方法，可以获得哪些信息" class="headerlink" title="通过反射获取对象的方法，可以获得哪些信息"></a>通过反射获取对象的方法，可以获得哪些信息</h2><ul><li><p>通过 类名.class 来获得 </p></li><li><p>clss.forName(类的权限名com.jack.code.entity.student)</p></li><li><p>可以获取属性、方法、以及该实例对象。</p></li></ul></li><li><h2 id="反射的底层思路"><a href="#反射的底层思路" class="headerlink" title="反射的底层思路"></a>反射的底层思路</h2><p>为什么我们可以在运行状态中，获取任何一个类的属性方法等信息呢。 计算机在执行Java程序的时候，通常有三个状态。</p><p>编译阶段，主要是在讲我们编写的 .java文件 通过 javac 编译成 字节码文件 即 .class文件。</p><p>第二阶段，是加载阶段，通过 classLoader类加载器 对 生成的字节码文件 进行加载，加载类中的属性和方法和构造器等等。而我们从反射中 获取的类信息，就是在这个阶段，将类中的信息 存放在了 堆中。这样，我们才可以从 Class类中 获取每个类的 信息。</p><p>第三阶段，是运行阶段。在这个阶段 才真正的开始执行 程序中的代码。</p></li><li><h2 id="注解-和-元注解的含义，注解有什么用"><a href="#注解-和-元注解的含义，注解有什么用" class="headerlink" title="注解 和 元注解的含义，注解有什么用"></a>注解 和 元注解的含义，注解有什么用</h2><p>注解就是一种标记，使用了注解，会给它附带一个独特的信息。这样 编译器 和 jvm 在执行到 它时，就会识别到它时干嘛用的。</p><p>元注解：就是 我们自定义注解的注解。 比如说 @Target： 约束注解使用的位置。 @Rentention: 约束注解的生命周期。@Documented: 表明该注解被javadoc工具记录。</p></li><li><h2 id="File对象表示什么，有什么方法"><a href="#File对象表示什么，有什么方法" class="headerlink" title="File对象表示什么，有什么方法"></a>File对象表示什么，有什么方法</h2><p>File对象 通常用来 表示 计算中中的文件 或者 目录。其中 我用的比较多的方法有 </p><p>获取信息型方法： getPath() 获取 定义时的路径。 getAbsolutePath() 获取文件的绝对路径。 getName() 获取文件名带后缀。 lengh() 获取文件的长度 以字节为单位。</p><p>判断型方法： exists() 文件是否存在 isDirectory() 判断是不是目录 isFile() 判断是不是文件 </p><p>创建或删除： createNewFile() 不存在时 创建文件 delete() 删除文件，目录（非空目录不能删除） mkdir() 创建一级目录 mkdirs()创建多级目录 </p><p>获取多个： list() 获取该目录下的一级文件 的名字 。 listFiles()  获取多个一级文件 成 File对象 列表</p></li><li><h2 id="英文、数字、中文在文件中分别占多大的空间"><a href="#英文、数字、中文在文件中分别占多大的空间" class="headerlink" title="英文、数字、中文在文件中分别占多大的空间"></a>英文、数字、中文在文件中分别占多大的空间</h2><p>英文和数字 在文件中占 1个字节，中文在 GBK编码中 占2个字节 ， UTF-8中 占 3个字节。</p></li><li><h2 id="创建IO有哪些分类"><a href="#创建IO有哪些分类" class="headerlink" title="创建IO有哪些分类"></a>创建IO有哪些分类</h2><ul><li><p>按流的方向： 输入流（从磁盘中的文件 或者 网络介质 写入到 内存中）、输出流（和输入流相反）。</p></li><li><p>流的内容分： 字节流（通常用来传输二进制的数据）、字符流 （传输文本类）。 如 inputStream、outputStream、Reader、Writer。 它们都实现了 Closeable 接口。</p></li><li><p>缓冲流：自带有8kb1的缓冲区，可以将字节&#x2F;字符 流 转化成 缓冲流。 常用的有 BufferedInputSteam BufferedOutputStream BufferedWriter BufferedReader。（可以提升读写的效率，减少系统IO的次数）</p></li><li><p>转换流： 主要用于 字节 与 字符流的 转换使用。 如 inputStreamReader outputStreamWriter</p></li><li><p>打印流: 主要用于 打印数据，printStream</p></li></ul></li><li><h2 id="BIO、NIO、AIO-的区别和原理"><a href="#BIO、NIO、AIO-的区别和原理" class="headerlink" title="BIO、NIO、AIO 的区别和原理"></a>BIO、NIO、AIO 的区别和原理</h2><p>这三种都是针对 不同场景下的 三种 线程执行IO的 操作方式。</p><p>BIO: 又叫 同步并阻塞，同步就是自己去做，阻塞就是 当我们访问IO时，就会开一个线程去进行处理。这样就会创建大量的线程，可能就会导致不必要的资源开销。 这在JDK1.4前的 唯一选择。使用 连接数目小，且固定的架构。</p><p>NIO：又叫 同步非阻塞。 简单来说 就是 一个请求就开一个线程去处理。当客户端发送请求的时候，会注册到 多路复用器上，多路复用器会根据你是否需要使用IO，会则启动线程去处理。 这比BIO 减少对线程的资源开销。在jdk1.4之后出现。使用连接数多，但连接比较短的架构。 比如聊天室</p><p>AIO：又叫 异步非阻塞。 异步，就是别人会帮你去干。一个有效的请求 开启一个线程。有效的请求就是 需要去访问IO，这就是有效的请求。如果是有效请求，那么 OS会先完成IO操作 然后再 通知 服务端去开启线程。从JDK7开始。使用连接数多且连接长的架构。</p></li><li><h2 id="序列化与反序列化是什么，有什么要求"><a href="#序列化与反序列化是什么，有什么要求" class="headerlink" title="序列化与反序列化是什么，有什么要求"></a>序列化与反序列化是什么，有什么要求</h2><p>序列化就是可以将 Java对象 转化成 字节数组，使它能够在 网络上传输、文件存储中传输。因为，通过网络传输图片、视频这种资源都是需要进行二进制传输的。因此，当我们需要去传输Java对象时，就需要序列化。 序列化的另一个特点就是持久性，序列化对象 的生命周期不局限于 程序是否运行。它存在于程序的调用之间。</p><p>而 反序列化 就是 将序列化的对象的字节数组 返回成 Java对象。这里需要注意 序列化 与 反序列化之间的标识 在于 序列化的ID <strong>serialVersionUID</strong>  通过这个来识别。</p><p>静态变量 与 被transient 修饰的变量 是不能序列化的。 static 就是类的对象。 程序关闭，类就死亡了。 transient 就是临时的数据，也不能被序列化。</p></li><li><h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><ul><li><p>客户端发送请求给 dispatcherServlet, 在发送过程中 ，Filter过滤器 会对数据进行过滤(可以对 httpServletRequest进行处理), dispatcherServlet 会执行 doService() 方法，把数据灌入，然后 再执行 doDispatcher() 得到 请求资源标示符。</p></li><li><p>dispatcherServlet 获取到 请求后， 就会去访问 handlerMapper处理映射器，handlerMapper 会生成Handler对象 和 HandlerInterceptor 处理拦截器。 把它们组合封装成 HandlerExecutionChain 类型的 一个Hanler处理器执行链 和 适配这个Hanler的 HandlerAdapter 返回给 dispatcherServlet。</p></li><li><p>获取到 dispatcherAdapter后，就会去执行 它的 handler方法，方法里面呢 就会去调用 对应的bean 找到执行该bean的 controller类。</p></li><li><p>controller 执行完毕后，就会封装成 ModeAndView 对象 ，返回给 dispatcherServlet。</p></li><li><p>dispatcherServlet 就会 把 modeAndView 传输给 ViewReslover视图解析器，并根据View进行视图的渲染。</p></li><li><p>最后，将处理封装好的 ModeAndView视图 返回给 dispatcherServlet ，并响应给 客户端。客户端就可以看到执行完结果后的试图。</p></li></ul></li><li><h2 id="什么是noSQL，列举几个noSQL的数据库"><a href="#什么是noSQL，列举几个noSQL的数据库" class="headerlink" title="什么是noSQL，列举几个noSQL的数据库"></a>什么是noSQL，列举几个noSQL的数据库</h2><p>noSQL 意为 not only SQL， 泛指 非关系型数据库。 它的特点就是 没有数据间的关系，只有存储数据。</p><p>那么，为什么需要noSQL呢，因为 传统的关系型数据库 比如 Mysql，在用户比较多，流量比较大时，传统的关系型数据库就会显露弊端，比如 磁盘IO的性能会降低，数据关系复杂，扩展性差等问题。 而 noSQL则能完美的解决这些问题，可以说 noSQL就是为了 大数据高并发而诞生的一种数据库类型。</p><p>常见的noSQL数据库有：redis、MongoDB、HBase。</p></li><li><h2 id="讲讲Redis的含义"><a href="#讲讲Redis的含义" class="headerlink" title="讲讲Redis的含义"></a>讲讲Redis的含义</h2><p>Redis 使用C语言开发的 一款 开源高性能的  以 键值对的形式 来存储的 数据库。 数据库中的数据之间 没有必要的关联，内部采用单线程的机制去进行工作，并且支持持久化的存储。</p><p>Redis常见的 数据类型有： string、list、set、hash、sorted_set 。</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实习生面试题&quot;&gt;&lt;a href=&quot;#实习生面试题&quot; class=&quot;headerlink&quot; title=&quot;实习生面试题&quot;&gt;&lt;/a&gt;实习生面试题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h1 id=&quot;java面向对象的三个特性-以及它们的含义&quot;&gt;&lt;a href=&quot;#java面向对</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88Java%E8%AF%AD%E8%A8%8001%EF%BC%89/"/>
    <id>http://example.com/2023/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88Java%E8%AF%AD%E8%A8%8001%EF%BC%89/</id>
    <published>2023-09-20T07:18:43.607Z</published>
    <updated>2023-04-07T03:03:55.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么Java代码可以实现一次编写、到处运行？"><a href="#1-为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="1.  为什么Java代码可以实现一次编写、到处运行？"></a>1.  为什么Java代码可以实现一次编写、到处运行？</h1><h1 id="2-一个Java文件里可以有多个类吗（不含内部类）？"><a href="#2-一个Java文件里可以有多个类吗（不含内部类）？" class="headerlink" title="2. 一个Java文件里可以有多个类吗（不含内部类）？"></a>2. 一个Java文件里可以有多个类吗（不含内部类）？</h1><h1 id="3-说一说你对Java访问权限的了解"><a href="#3-说一说你对Java访问权限的了解" class="headerlink" title="3.说一说你对Java访问权限的了解"></a>3.说一说你对Java访问权限的了解</h1><h1 id="4-介绍一下Java的数据类型"><a href="#4-介绍一下Java的数据类型" class="headerlink" title="4.介绍一下Java的数据类型"></a>4.介绍一下Java的数据类型</h1><h1 id="5-int类型的数据范围是多少？"><a href="#5-int类型的数据范围是多少？" class="headerlink" title="5.int类型的数据范围是多少？"></a>5.int类型的数据范围是多少？</h1><h1 id="6-请介绍全局变量和局部变量的区别"><a href="#6-请介绍全局变量和局部变量的区别" class="headerlink" title="6.请介绍全局变量和局部变量的区别"></a>6.请介绍全局变量和局部变量的区别</h1><h1 id="7-请介绍一下实例变量的默认值"><a href="#7-请介绍一下实例变量的默认值" class="headerlink" title="7. 请介绍一下实例变量的默认值"></a>7. 请介绍一下实例变量的默认值</h1><h1 id="8-为啥要有包装类？"><a href="#8-为啥要有包装类？" class="headerlink" title="8.为啥要有包装类？"></a>8.为啥要有包装类？</h1><h1 id="9-说一说自动装箱、自动拆箱的应用场景"><a href="#9-说一说自动装箱、自动拆箱的应用场景" class="headerlink" title="9.说一说自动装箱、自动拆箱的应用场景"></a>9.说一说自动装箱、自动拆箱的应用场景</h1><h1 id="10-如何对Integer和Double类型判断相等？"><a href="#10-如何对Integer和Double类型判断相等？" class="headerlink" title="10.如何对Integer和Double类型判断相等？"></a>10.如何对Integer和Double类型判断相等？</h1><h1 id="11-int和Integer有什么区别，二者在做-运算时会得到什么结果？"><a href="#11-int和Integer有什么区别，二者在做-运算时会得到什么结果？" class="headerlink" title="11.int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？"></a>11.int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？</h1><h1 id="12-说一说你对面向对象的理解"><a href="#12-说一说你对面向对象的理解" class="headerlink" title="12.说一说你对面向对象的理解"></a>12.说一说你对面向对象的理解</h1><h1 id="13-面向象的三大特征是什么？"><a href="#13-面向象的三大特征是什么？" class="headerlink" title="13.面向象的三大特征是什么？"></a>13.面向象的三大特征是什么？</h1><h1 id="14-封装的目的是什么，为什么要有封装？"><a href="#14-封装的目的是什么，为什么要有封装？" class="headerlink" title="14.封装的目的是什么，为什么要有封装？"></a>14.封装的目的是什么，为什么要有封装？</h1><h1 id="15-说一说你对多态的理解"><a href="#15-说一说你对多态的理解" class="headerlink" title="15.说一说你对多态的理解"></a>15.说一说你对多态的理解</h1><h1 id="16-Java中的多态是怎么实现的？"><a href="#16-Java中的多态是怎么实现的？" class="headerlink" title="16.Java中的多态是怎么实现的？"></a>16.Java中的多态是怎么实现的？</h1><h1 id="17-Java为什么是单继承，为什么不能多继承？"><a href="#17-Java为什么是单继承，为什么不能多继承？" class="headerlink" title="17.Java为什么是单继承，为什么不能多继承？"></a>17.Java为什么是单继承，为什么不能多继承？</h1><h1 id="18-说一说重写与重载的区别"><a href="#18-说一说重写与重载的区别" class="headerlink" title="18.说一说重写与重载的区别"></a>18.说一说重写与重载的区别</h1><h1 id="19-构造方法能不能重写？"><a href="#19-构造方法能不能重写？" class="headerlink" title="19.构造方法能不能重写？"></a>19.构造方法能不能重写？</h1><h1 id="20-介绍一下Object类中的方法"><a href="#20-介绍一下Object类中的方法" class="headerlink" title="20.介绍一下Object类中的方法"></a>20.介绍一下Object类中的方法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-为什么Java代码可以实现一次编写、到处运行？&quot;&gt;&lt;a href=&quot;#1-为什么Java代码可以实现一次编写、到处运行？&quot; class=&quot;headerlink&quot; title=&quot;1.  为什么Java代码可以实现一次编写、到处运行？&quot;&gt;&lt;/a&gt;1.  为什么Ja</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java8新特性</title>
    <link href="http://example.com/2022/06/07/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/06/07/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-06-07T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-java8（jdk1-8）新特性的优点"><a href="#1-java8（jdk1-8）新特性的优点" class="headerlink" title="1. java8（jdk1.8）新特性的优点"></a>1. java8（jdk1.8）新特性的优点</h3><ul><li><h4 id="1-速度更快。-如-hashMap中-链表的长度超过8后，就会转成-红黑树。"><a href="#1-速度更快。-如-hashMap中-链表的长度超过8后，就会转成-红黑树。" class="headerlink" title="(1) 速度更快。 如 hashMap中 链表的长度超过8后，就会转成 红黑树。"></a>(1) 速度更快。 如 hashMap中 链表的长度超过8后，就会转成 红黑树。</h4></li><li><h4 id="2-代码更少。-用更少的代码-实现效果。-如-Lambda-表达式"><a href="#2-代码更少。-用更少的代码-实现效果。-如-Lambda-表达式" class="headerlink" title="(2) 代码更少。 用更少的代码 实现效果。 如 Lambda 表达式"></a>(2) 代码更少。 用更少的代码 实现效果。 如 Lambda 表达式</h4></li><li><h4 id="3-强大的-Stream-API"><a href="#3-强大的-Stream-API" class="headerlink" title="(3) 强大的 Stream API"></a>(3) 强大的 Stream API</h4></li><li><h4 id="4-便于并行"><a href="#4-便于并行" class="headerlink" title="(4) 便于并行"></a>(4) 便于并行</h4></li><li><h4 id="5-最大化的减少空指针异常-：Optional"><a href="#5-最大化的减少空指针异常-：Optional" class="headerlink" title="(5) 最大化的减少空指针异常 ：Optional"></a>(5) 最大化的减少空指针异常 ：Optional</h4></li><li><h4 id="6-加入了Nashorn引擎，允许在-jvm中运行-js，效率更高。"><a href="#6-加入了Nashorn引擎，允许在-jvm中运行-js，效率更高。" class="headerlink" title="(6) 加入了Nashorn引擎，允许在 jvm中运行 js，效率更高。"></a>(6) 加入了Nashorn引擎，允许在 jvm中运行 js，效率更高。</h4></li></ul><h3 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2. Lambda表达式"></a>2. Lambda表达式</h3><ul><li><h4 id="（1）使用场景：当需要实例化-函数式接口对象时-下面有介绍-并-重写其-抽象方法时，可以使用Lambda格式-来简化代码量。"><a href="#（1）使用场景：当需要实例化-函数式接口对象时-下面有介绍-并-重写其-抽象方法时，可以使用Lambda格式-来简化代码量。" class="headerlink" title="（1）使用场景：当需要实例化 函数式接口对象时(下面有介绍 ) 并 重写其 抽象方法时，可以使用Lambda格式 来简化代码量。"></a>（1）使用场景：当需要实例化 函数式接口对象时(下面有介绍 ) 并 重写其 抽象方法时，可以使用Lambda格式 来简化代码量。</h4></li><li><h4 id="（2）举例说明-含义"><a href="#（2）举例说明-含义" class="headerlink" title="（2）举例说明 含义"></a>（2）举例说明 含义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. (o1,o2)： 指示抽象方法的 参数</span></span><br><span class="line"><span class="comment">//2. -&gt; : lambda 标识符 </span></span><br><span class="line"><span class="comment">/**3. &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;hahah&quot;);</span></span><br><span class="line"><span class="comment">            return o1.compareTo(o2);</span></span><br><span class="line"><span class="comment">        &#125;; </span></span><br><span class="line"><span class="comment">        表示 抽象方法 的 方法体</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; comparator= (o1,o2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hahah&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="（3）格式说法"><a href="#（3）格式说法" class="headerlink" title="（3）格式说法"></a>（3）格式说法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/6/7 14:54</span></span><br><span class="line"><span class="comment"> * 演示 lambda 的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExam</span> &#123;</span><br><span class="line">    <span class="comment">//格式一：无参 无返回值的接口</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//当方法体 只有 一条执行语句时 可以省略 &#123;&#125; 如果时 return语句 则需要把 return 省略掉</span></span><br><span class="line">        Runnable r1= () -&gt; System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        r1.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式二：有一个参数，但是没有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 当只有 前面编译类型 有指示泛型(Consumer&lt;String&gt;) ，则参数可以省略类型(s1) -&gt; 类型推断机制</span></span><br><span class="line">        <span class="comment">//2. 当只有一个参数时，可以省略 ()</span></span><br><span class="line">        Consumer&lt;String&gt; consumer= s1 -&gt; System.out.println(s1);</span><br><span class="line">        consumer.accept(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式三：有两个或以上参数，并有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 当有两个或以上参数 则不能省略 ()</span></span><br><span class="line">        <span class="comment">//2. 当方法有 有两个或以上语句 则不能 省略&#123;&#125; ，得按正常的方法体规范去写</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator= (o1,o2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hahah&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(comparator.compare(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h3><ul><li><h4 id="（1）含义：只包含-一个抽象方法-的接口，即为函数式接口。"><a href="#（1）含义：只包含-一个抽象方法-的接口，即为函数式接口。" class="headerlink" title="（1）含义：只包含 一个抽象方法 的接口，即为函数式接口。"></a>（1）含义：只包含 一个抽象方法 的接口，即为函数式接口。</h4></li><li><h4 id="（2）特点："><a href="#（2）特点：" class="headerlink" title="（2）特点："></a>（2）特点：</h4><ul><li><h5 id="1）可以通过-Lamdba-表达式来-实例化对象"><a href="#1）可以通过-Lamdba-表达式来-实例化对象" class="headerlink" title="1）可以通过 Lamdba 表达式来 实例化对象"></a>1）可以通过 Lamdba 表达式来 实例化对象</h5></li><li><h5 id="2）可以在接口上-使用-Functionallnterface-注解来-检查该接口-是不是-函数式接口"><a href="#2）可以在接口上-使用-Functionallnterface-注解来-检查该接口-是不是-函数式接口" class="headerlink" title="2）可以在接口上 使用 @Functionallnterface 注解来 检查该接口 是不是 函数式接口"></a>2）可以在接口上 使用 @Functionallnterface 注解来 检查该接口 是不是 函数式接口</h5></li><li><h5 id="3）在-java-util-function-包下定义了-java8的-丰富的函数式接口"><a href="#3）在-java-util-function-包下定义了-java8的-丰富的函数式接口" class="headerlink" title="3）在 java.util.function 包下定义了 java8的 丰富的函数式接口"></a>3）在 java.util.function 包下定义了 java8的 丰富的函数式接口</h5></li></ul></li><li><h4 id="（3）java内置的函数式接口"><a href="#（3）java内置的函数式接口" class="headerlink" title="（3）java内置的函数式接口"></a>（3）java内置的函数式接口</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/java%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png"></p><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png"></p></li><li><h4 id="（4）-函数式接口的使用"><a href="#（4）-函数式接口的使用" class="headerlink" title="（4） 函数式接口的使用"></a>（4） 函数式接口的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionInterfaceExam</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;hello jack&quot;</span>;</span><br><span class="line">        happyTime(name,str -&gt; System.out.println(str+<span class="string">&quot;6666&quot;</span>)); <span class="comment">//使用 lambda来 实例化 函数式接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用 Consumer 消费型 函数式接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyTime</span><span class="params">(String str, Consumer&lt;String&gt; s)</span>&#123;</span><br><span class="line">        s.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;String&gt; list=Arrays.asList(<span class="string">&quot;南京&quot;</span>,<span class="string">&quot;天京&quot;</span>,<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;天安门&quot;</span>);</span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> equalsStr(list, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Predicate 断定型接口</span></span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">equalsStr</span><span class="params">(List&lt;String&gt; strList, Predicate&lt;String&gt; predicate)</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:strList)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> predicate.test(s);</span><br><span class="line">            <span class="keyword">if</span>(test)&#123;</span><br><span class="line">                arrayList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h3><ul><li><h4 id="（1）含义：实际是-lambda表达式-的-进一步简化。-用于减少代码量"><a href="#（1）含义：实际是-lambda表达式-的-进一步简化。-用于减少代码量" class="headerlink" title="（1）含义：实际是 lambda表达式 的 进一步简化。 用于减少代码量"></a>（1）含义：实际是 lambda表达式 的 进一步简化。 用于减少代码量</h4></li><li><h4 id="（2）用法环境（前提是符合-运用lambda表达式环境）："><a href="#（2）用法环境（前提是符合-运用lambda表达式环境）：" class="headerlink" title="（2）用法环境（前提是符合 运用lambda表达式环境）："></a>（2）用法环境（前提是符合 运用lambda表达式环境）：</h4><ul><li><h5 id="1）-当-编译类型的-抽象方法-的-方法体中的方法的-返回值和输入参数-的类型-与-抽象方法一致时-，则可以使用-方法引用。"><a href="#1）-当-编译类型的-抽象方法-的-方法体中的方法的-返回值和输入参数-的类型-与-抽象方法一致时-，则可以使用-方法引用。" class="headerlink" title="1） 当 编译类型的 抽象方法 的 方法体中的方法的 返回值和输入参数 的类型 与 抽象方法一致时 ，则可以使用 方法引用。"></a>1） 当 编译类型的 抽象方法 的 方法体中的方法的 返回值和输入参数 的类型 与 抽象方法一致时 ，则可以使用 方法引用。</h5></li></ul></li><li><h4 id="（3）用法："><a href="#（3）用法：" class="headerlink" title="（3）用法："></a>（3）用法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种： 对象 :: 实例方法</span></span><br><span class="line">   <span class="comment">//使用场景：只要符合 方法引用 就能使用</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line">       <span class="comment">// void accept(T t)   void System.out.println(T t)</span></span><br><span class="line">       <span class="comment">//void --- void   T t ---&gt; T t</span></span><br><span class="line">       <span class="comment">// 发现 accept方法体中 的 方法 的 返回值和输入参数的类型一致 则可以使用方法引用。</span></span><br><span class="line">       Consumer&lt;String&gt; consumer= ps :: println;</span><br><span class="line">       consumer.accept(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// Supplier 的 T get()</span></span><br><span class="line">       <span class="comment">//Employee 的 String getName()</span></span><br><span class="line">       <span class="comment">//两者的 返回类型一致 输入参数一致</span></span><br><span class="line">       Employee employee=<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">       Supplier&lt;String&gt; supplier= employee::getName;</span><br><span class="line">       System.out.println(supplier.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种 类 :: 静态方法</span></span><br><span class="line">    <span class="comment">//使用场景：</span></span><br><span class="line">    <span class="comment">//       1. 两者的 输入参数个数与类型 和 返回类型 一摸一样</span></span><br><span class="line">    <span class="comment">//       2. 类的方法 是 静态方法 如 compareTo、round</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// int comparator(T t,T t)</span></span><br><span class="line">        <span class="comment">// int compareTo(T t,T t)</span></span><br><span class="line">        <span class="comment">//两者的 输入参数个数与类型 和 返回类型 一摸一样</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator=Integer::compareTo;</span><br><span class="line">        System.out.println(comparator.compare(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R apply(T t)</span></span><br><span class="line">        <span class="comment">// Double round(Double d)</span></span><br><span class="line">        Function&lt;Double,Long&gt; function=Math::round;</span><br><span class="line">        System.out.println(function.apply(<span class="number">5.0</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况三： 类::实例方法</span></span><br><span class="line">    <span class="comment">//1. 当 可以用 其中一个的 输入参数调用方法 既t1.compareTo(t2)</span></span><br><span class="line">    <span class="comment">//2. 两者的 输入参数个数 是不一致的  但是类型需要一致</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//int comparator(T t1, T t2)</span></span><br><span class="line">        <span class="comment">//int compareTo(String t1)</span></span><br><span class="line">        Comparator&lt;String&gt; comparator=String::compareTo;</span><br><span class="line">        System.out.println(comparator.compare(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;333&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean test(T t1,T t2)</span></span><br><span class="line">        <span class="comment">// boolean t1.equals(t2)</span></span><br><span class="line">        BiPredicate&lt;String,String&gt; predicate=String::equals;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R apply(T t)</span></span><br><span class="line">        <span class="comment">// String getName()</span></span><br><span class="line">        <span class="comment">// t(employee).getName</span></span><br><span class="line">        Employee employee=<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;ping&quot;</span>);</span><br><span class="line">        Function&lt;Employee,String&gt; function=Employee::getName;</span><br><span class="line">        System.out.println(function.apply(employee));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-构造器引用"><a href="#5-构造器引用" class="headerlink" title="5.构造器引用"></a>5.构造器引用</h3><ul><li><h4 id="（1）含义：与方法引用类似，只不过方法体内的方法-变成了构造器。"><a href="#（1）含义：与方法引用类似，只不过方法体内的方法-变成了构造器。" class="headerlink" title="（1）含义：与方法引用类似，只不过方法体内的方法 变成了构造器。"></a>（1）含义：与方法引用类似，只不过方法体内的方法 变成了构造器。</h4></li><li><h4 id="（2）使用方法："><a href="#（2）使用方法：" class="headerlink" title="（2）使用方法："></a>（2）使用方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/6/15 14:15</span></span><br><span class="line"><span class="comment"> * 构造器引用的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用方法：对于抽象方法中的lambda表达式中</span></span><br><span class="line"><span class="comment"> *      输入参数 与 构造器的 输入参数 的个数和类型一致  并且 返回值为T 则可以自动匹配到对象的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorCite</span> &#123;</span><br><span class="line">    <span class="comment">// T Supplier.get()</span></span><br><span class="line">    <span class="comment">//返回值T 通过 new Employee来返回</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//构造器引用</span></span><br><span class="line">        Supplier&lt;Employee&gt; supplier=Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过不同的 输入参数 来匹配 对应的构造器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这次 匹配到的 就是 Employee(String name) 的 构造方法</span></span><br><span class="line">        Function&lt;String,Employee&gt; function=Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-StreamAPI"><a href="#6-StreamAPI" class="headerlink" title="6. StreamAPI"></a>6. StreamAPI</h3><ul><li><h4 id="（1）含义：Stream-主要用于-对-集合容器-进行非常复杂的一些操作，如查找、过滤、映射数据等。"><a href="#（1）含义：Stream-主要用于-对-集合容器-进行非常复杂的一些操作，如查找、过滤、映射数据等。" class="headerlink" title="（1）含义：Stream 主要用于 对 集合容器 进行非常复杂的一些操作，如查找、过滤、映射数据等。"></a>（1）含义：Stream 主要用于 对 集合容器 进行非常复杂的一些操作，如查找、过滤、映射数据等。</h4></li><li><h4 id="（2）使用场景：由于目前现在的数据源多了很多Nosql的数据，如MongDB-和-Radis-。这些就需要用到-java来处理。"><a href="#（2）使用场景：由于目前现在的数据源多了很多Nosql的数据，如MongDB-和-Radis-。这些就需要用到-java来处理。" class="headerlink" title="（2）使用场景：由于目前现在的数据源多了很多Nosql的数据，如MongDB 和 Radis 。这些就需要用到 java来处理。"></a>（2）使用场景：由于目前现在的数据源多了很多Nosql的数据，如MongDB 和 Radis 。这些就需要用到 java来处理。</h4></li><li><h4 id="（3）Stream-与-Collection集合的区别：Collection-是一种-静态的内存数据结构-，而-Stream主要用于计算的。Stream是面向CPU的-，使用CPU进行计算。而-Collection是面向内存，使用内存进行存储。"><a href="#（3）Stream-与-Collection集合的区别：Collection-是一种-静态的内存数据结构-，而-Stream主要用于计算的。Stream是面向CPU的-，使用CPU进行计算。而-Collection是面向内存，使用内存进行存储。" class="headerlink" title="（3）Stream 与 Collection集合的区别：Collection 是一种 静态的内存数据结构 ，而 Stream主要用于计算的。Stream是面向CPU的 ，使用CPU进行计算。而 Collection是面向内存，使用内存进行存储。"></a>（3）Stream 与 Collection集合的区别：Collection 是一种 静态的内存数据结构 ，而 Stream主要用于计算的。Stream是面向CPU的 ，使用CPU进行计算。而 Collection是面向内存，使用内存进行存储。</h4></li><li><h4 id="（4）注意事项："><a href="#（4）注意事项：" class="headerlink" title="（4）注意事项："></a>（4）注意事项：</h4><ul><li><h5 id="Stream-自己本身是不会-存储的。-只是用于对-数据进行-处理计算。"><a href="#Stream-自己本身是不会-存储的。-只是用于对-数据进行-处理计算。" class="headerlink" title="Stream  自己本身是不会 存储的。 只是用于对 数据进行 处理计算。"></a>Stream  自己本身是不会 存储的。 只是用于对 数据进行 处理计算。</h5></li><li><h5 id="Stream-不会改变-源对象。相反，它们会返回一个-持有结果的-新的-Stream。"><a href="#Stream-不会改变-源对象。相反，它们会返回一个-持有结果的-新的-Stream。" class="headerlink" title="Stream 不会改变 源对象。相反，它们会返回一个 持有结果的 新的 Stream。"></a>Stream 不会改变 源对象。相反，它们会返回一个 持有结果的 新的 Stream。</h5></li><li><h5 id="Stream-是延迟执行的，既-执行到-终止操作阶段，才会对数据-进行处理。"><a href="#Stream-是延迟执行的，既-执行到-终止操作阶段，才会对数据-进行处理。" class="headerlink" title="Stream 是延迟执行的，既 执行到 终止操作阶段，才会对数据 进行处理。"></a>Stream 是延迟执行的，既 执行到 终止操作阶段，才会对数据 进行处理。</h5></li></ul></li><li><h4 id="（5）Stream-的-操作流程"><a href="#（5）Stream-的-操作流程" class="headerlink" title="（5）Stream 的 操作流程"></a>（5）Stream 的 操作流程</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/Stream%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E4%B8%AA%E6%B5%81%E7%A8%8B.png"></p></li><li><h4 id="（6）中间操作："><a href="#（6）中间操作：" class="headerlink" title="（6）中间操作："></a>（6）中间操作：</h4><ul><li><h5 id="1）筛选与切片："><a href="#1）筛选与切片：" class="headerlink" title="1）筛选与切片："></a>1）筛选与切片：</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E7%AD%9B%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95.png"></p></li><li><h5 id="2）映射（既像hashMap一样-存在k-v）"><a href="#2）映射（既像hashMap一样-存在k-v）" class="headerlink" title="2）映射（既像hashMap一样 存在k-v）"></a>2）映射（既像hashMap一样 存在k-v）</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95.png"></p></li><li><h5 id="3）排序"><a href="#3）排序" class="headerlink" title="3）排序"></a>3）排序</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C-%E6%8E%92%E5%BA%8F.png.jpg"></p></li></ul></li><li><h4 id="（7）终止操作"><a href="#（7）终止操作" class="headerlink" title="（7）终止操作"></a>（7）终止操作</h4><ul><li><h5 id="1）匹配与查找"><a href="#1）匹配与查找" class="headerlink" title="1）匹配与查找"></a>1）匹配与查找</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE.png"></p></li><li><h5 id="2）归约"><a href="#2）归约" class="headerlink" title="2）归约"></a>2）归约</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E5%BD%92%E7%BA%A6.png"></p></li><li><h5 id="3）收集"><a href="#3）收集" class="headerlink" title="3）收集"></a>3）收集</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/%E6%94%B6%E9%9B%86.png"></p></li></ul></li><li><h4 id="（8）Optional类"><a href="#（8）Optional类" class="headerlink" title="（8）Optional类"></a>（8）Optional类</h4><ul><li><h5 id="1）含义：为了解决-空指针异常-导致运行异常的问题，从而引入了-Optional类用以-专门处理-空指针方面的问题。"><a href="#1）含义：为了解决-空指针异常-导致运行异常的问题，从而引入了-Optional类用以-专门处理-空指针方面的问题。" class="headerlink" title="1）含义：为了解决 空指针异常 导致运行异常的问题，从而引入了 Optional类用以 专门处理 空指针方面的问题。"></a>1）含义：为了解决 空指针异常 导致运行异常的问题，从而引入了 Optional类用以 专门处理 空指针方面的问题。</h5></li><li><h5 id="2）常用方法API："><a href="#2）常用方法API：" class="headerlink" title="2）常用方法API："></a>2）常用方法API：</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java8%E6%96%B0%E7%89%B9%E6%80%A7/Optional%E7%B1%BB%E6%96%B9%E6%B3%95.png"></p></li><li><h5 id="3）使用："><a href="#3）使用：" class="headerlink" title="3）使用："></a>3）使用：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalExam</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//传入为null 不会报 空指针异常 正常返回 girlName 为 ping</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">girlName</span> <span class="operator">=</span> getGirlName(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(girlName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlName</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 为了防止 传参boy为null 使用 ofNullable(T t)方法 创建Optional类</span></span><br><span class="line">        Optional&lt;Boy&gt; boy1 = Optional.ofNullable(boy);</span><br><span class="line">        <span class="comment">//2. 如果boy1为空 则创建一个boy来执行下面操作</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy2</span> <span class="operator">=</span> boy1.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">        <span class="comment">//3. 获取 girl的 Optional类 防止为空</span></span><br><span class="line">        Optional&lt;Girl&gt; girl = Optional.ofNullable(boy2.getGirl());</span><br><span class="line">        <span class="comment">//4. 如果girl为空 则创建一个girl来代替执行</span></span><br><span class="line">        <span class="type">Girl</span> <span class="variable">ping</span> <span class="operator">=</span> girl.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;ping&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> ping.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-java8（jdk1-8）新特性的优点&quot;&gt;&lt;a href=&quot;#1-java8（jdk1-8）新特性的优点&quot; class=&quot;headerlink&quot; title=&quot;1. java8（jdk1.8）新特性的优点&quot;&gt;&lt;/a&gt;1. java8（jdk1.8）新特性的优点</summary>
      
    
    
    
    
    <category term="-Java -复习" scheme="http://example.com/tags/Java-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java复习3</title>
    <link href="http://example.com/2021/11/16/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-3/"/>
    <id>http://example.com/2021/11/16/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-3/</id>
    <published>2021-11-16T03:57:36.000Z</published>
    <updated>2023-09-21T04:22:49.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-接口-interface"><a href="#1-接口-interface" class="headerlink" title="1.接口(interface)"></a>1.接口(interface)</h3><ul><li><h4 id="1-含义：接口-就是-给出一些没有实现的方法，封装在一起。当某个类需要使用时，根据实际情况-把方法写出来"><a href="#1-含义：接口-就是-给出一些没有实现的方法，封装在一起。当某个类需要使用时，根据实际情况-把方法写出来" class="headerlink" title="1.含义：接口 就是 给出一些没有实现的方法，封装在一起。当某个类需要使用时，根据实际情况 把方法写出来"></a>1.含义：接口 就是 给出一些没有实现的方法，封装在一起。当某个类需要使用时，根据实际情况 把方法写出来</h4></li><li><h4 id="2-使用细节："><a href="#2-使用细节：" class="headerlink" title="2.使用细节："></a>2.使用细节：</h4><ul><li><h5 id="1-接口不能被-实例化"><a href="#1-接口不能被-实例化" class="headerlink" title="1. 接口不能被 实例化"></a>1. 接口不能被 实例化</h5></li><li><h5 id="2-抽象类-去-实现接口，可以-不实现接口中的方法"><a href="#2-抽象类-去-实现接口，可以-不实现接口中的方法" class="headerlink" title="2.抽象类 去 实现接口，可以 不实现接口中的方法"></a>2.抽象类 去 实现接口，可以 不实现接口中的方法</h5></li><li><h5 id="3-一个类-可以-同时实现-多个接口"><a href="#3-一个类-可以-同时实现-多个接口" class="headerlink" title="3.一个类 可以 同时实现 多个接口"></a>3.一个类 可以 同时实现 多个接口</h5></li><li><h5 id="4-接口-中-的属性-只能修饰为-public-static-final-int-a-1-必须初始化-而且只能这样子修饰"><a href="#4-接口-中-的属性-只能修饰为-public-static-final-int-a-1-必须初始化-而且只能这样子修饰" class="headerlink" title="4.接口 中 的属性 只能修饰为 public static final int a&#x3D;1; 必须初始化  而且只能这样子修饰"></a>4.接口 中 的属性 只能修饰为 public static final int a&#x3D;1; 必须初始化  而且只能这样子修饰</h5></li><li><h5 id="5-一个-接口不能继承-其他的类，但能够继承-多个-其他的接口"><a href="#5-一个-接口不能继承-其他的类，但能够继承-多个-其他的接口" class="headerlink" title="5.一个 接口不能继承 其他的类，但能够继承 多个 其他的接口"></a>5.一个 接口不能继承 其他的类，但能够继承 多个 其他的接口</h5></li><li><h5 id="6-接口的-修饰符-只能时public-和-默认-，这点和类的修饰符是一样的"><a href="#6-接口的-修饰符-只能时public-和-默认-，这点和类的修饰符是一样的" class="headerlink" title="6.接口的 修饰符 只能时public 和 默认 ，这点和类的修饰符是一样的"></a>6.接口的 修饰符 只能时public 和 默认 ，这点和类的修饰符是一样的</h5></li></ul></li><li><h4 id="3-接口-与-继承-的-不同"><a href="#3-接口-与-继承-的-不同" class="headerlink" title="3.接口 与 继承 的 不同"></a>3.接口 与 继承 的 不同</h4><ul><li><h5 id="接口-和-继承-解决的问题不同，-继承-主要用于-解决-代码的复用性-与-可维护性-。-而-接口-主要是-用于设计-设计各种方法给-需要的类进行使用。"><a href="#接口-和-继承-解决的问题不同，-继承-主要用于-解决-代码的复用性-与-可维护性-。-而-接口-主要是-用于设计-设计各种方法给-需要的类进行使用。" class="headerlink" title="接口 和 继承 解决的问题不同， 继承 主要用于 解决 代码的复用性 与 可维护性 。 而 接口 主要是 用于设计 设计各种方法给 需要的类进行使用。"></a>接口 和 继承 解决的问题不同， 继承 主要用于 解决 代码的复用性 与 可维护性 。 而 接口 主要是 用于设计 设计各种方法给 需要的类进行使用。</h5></li><li><h5 id="接口-比-继承-更加的-灵活。-继承-满足-is-a-关系-，-而-实现-满足-like-a关系"><a href="#接口-比-继承-更加的-灵活。-继承-满足-is-a-关系-，-而-实现-满足-like-a关系" class="headerlink" title="接口 比 继承 更加的 灵活。 继承 满足 is a 关系 ， 而 实现 满足 like a关系"></a>接口 比 继承 更加的 灵活。 继承 满足 is a 关系 ， 而 实现 满足 like a关系</h5></li><li><h5 id="接口-在-一定程度上-实现-代码解耦"><a href="#接口-在-一定程度上-实现-代码解耦" class="headerlink" title="接口 在 一定程度上 实现 代码解耦"></a>接口 在 一定程度上 实现 代码解耦</h5></li></ul></li><li><h4 id="4-接口-的-多态特性"><a href="#4-接口-的-多态特性" class="headerlink" title="4.接口 的 多态特性"></a>4.接口 的 多态特性</h4><ul><li><h5 id="多态的参数"><a href="#多态的参数" class="headerlink" title="多态的参数"></a>多态的参数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       DD dd=<span class="keyword">new</span> <span class="title class_">DD</span>();</span><br><span class="line">       BB bb=<span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">       <span class="comment">//体现 接口参数 体现多态 参数是 AA接口类型 但是 传参可以是AA接口的实现类</span></span><br><span class="line">       dd.Exam(bb);</span><br><span class="line">       dd.Exam(cc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Exam</span><span class="params">(AA aa)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">implements</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> <span class="keyword">implements</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AA aa[]=<span class="keyword">new</span> <span class="title class_">AA</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//接口 数组 体现多态 数组成员可以是 实现类实例</span></span><br><span class="line">        aa[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        aa[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">CC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">implements</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> <span class="keyword">implements</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="接口-存在-多态传递现象"><a href="#接口-存在-多态传递现象" class="headerlink" title="接口 存在 多态传递现象"></a>接口 存在 多态传递现象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//呈现多态传递性</span></span><br><span class="line">        CC cc=<span class="keyword">new</span> <span class="title class_">CC</span>();</span><br><span class="line">        AA aa=cc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">implements</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CC 类 继承了 BB类 而BB类是 AA类的实现类 呈现了接口的传递性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> <span class="keyword">extends</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2.内部类"></a>2.内部类</h3><ul><li><h4 id="1-含义：在-一个类中-又完整的嵌套了-另一个类结构-在-嵌套里面的类-就叫内部类，而外面的-就叫-外部类"><a href="#1-含义：在-一个类中-又完整的嵌套了-另一个类结构-在-嵌套里面的类-就叫内部类，而外面的-就叫-外部类" class="headerlink" title="1. 含义：在 一个类中 又完整的嵌套了 另一个类结构 . 在 嵌套里面的类 就叫内部类，而外面的 就叫 外部类"></a>1. 含义：在 一个类中 又完整的嵌套了 另一个类结构 . 在 嵌套里面的类 就叫内部类，而外面的 就叫 外部类</h4></li><li><h4 id="2-内部类的分类"><a href="#2-内部类的分类" class="headerlink" title="2.内部类的分类"></a>2.内部类的分类</h4><ul><li><h5 id="定义在-外部类的-局部位置上-如-方体里、结构体里-等）"><a href="#定义在-外部类的-局部位置上-如-方体里、结构体里-等）" class="headerlink" title="定义在 外部类的 局部位置上(如 方体里、结构体里 等）"></a>定义在 外部类的 局部位置上(如 方体里、结构体里 等）</h5><ul><li><h5 id="局部内部类-（有类名）"><a href="#局部内部类-（有类名）" class="headerlink" title="局部内部类 （有类名）"></a>局部内部类 （有类名）</h5><ul><li><h5 id="1-不能添加-访问修饰符-但能添加-final-（既-和-局部变量一样）"><a href="#1-不能添加-访问修饰符-但能添加-final-（既-和-局部变量一样）" class="headerlink" title="1. 不能添加 访问修饰符 但能添加 final （既 和 局部变量一样）"></a>1. 不能添加 访问修饰符 但能添加 final （既 和 局部变量一样）</h5></li><li><h5 id="2-可以直接访问-外部类的所有成员-包括-私有成员"><a href="#2-可以直接访问-外部类的所有成员-包括-私有成员" class="headerlink" title="2. 可以直接访问 外部类的所有成员 包括 私有成员"></a>2. 可以直接访问 外部类的所有成员 包括 私有成员</h5></li><li><h5 id="3-作用域-仅仅在-定义它-的方法-或者-代码块中"><a href="#3-作用域-仅仅在-定义它-的方法-或者-代码块中" class="headerlink" title="3. 作用域 仅仅在 定义它 的方法 或者 代码块中"></a>3. 作用域 仅仅在 定义它 的方法 或者 代码块中</h5></li><li><h5 id="4-外部类-访问-局部内部类的成员"><a href="#4-外部类-访问-局部内部类的成员" class="headerlink" title="4. 外部类 访问 局部内部类的成员"></a>4. 外部类 访问 局部内部类的成员</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AA aa=<span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.f1(); <span class="comment">//调用 f1方法 来 使用 BB 匿名内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> n1=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">               System.out.println(n1);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用 局部内部类 必须在作用域中</span></span><br><span class="line">        BB b=<span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        b.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="5-如果-外部类-和-局部内部类-的成员重名-则默认遵循-就近原则-若向访问-外部类成员-可以用-外部类名-this-成员-访问"><a href="#5-如果-外部类-和-局部内部类-的成员重名-则默认遵循-就近原则-若向访问-外部类成员-可以用-外部类名-this-成员-访问" class="headerlink" title="5. 如果 外部类 和 局部内部类 的成员重名 则默认遵循 就近原则 若向访问 外部类成员 可以用 (外部类名.this.成员)访问"></a>5. 如果 外部类 和 局部内部类 的成员重名 则默认遵循 就近原则 若向访问 外部类成员 可以用 (外部类名.this.成员)访问</h5></li></ul></li><li><h5 id="匿名内部类（无类名）"><a href="#匿名内部类（无类名）" class="headerlink" title="匿名内部类（无类名）"></a>匿名内部类（无类名）</h5><ul><li><h5 id="1-匿名内部类-即是一个类-也是-一个对象-因此-外部类-可以使用-匿名内部类的对象实例"><a href="#1-匿名内部类-即是一个类-也是-一个对象-因此-外部类-可以使用-匿名内部类的对象实例" class="headerlink" title="1. 匿名内部类 即是一个类 也是 一个对象 因此 外部类 可以使用 匿名内部类的对象实例"></a>1. 匿名内部类 即是一个类 也是 一个对象 因此 外部类 可以使用 匿名内部类的对象实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//接口 实现 匿名内部类</span></span><br><span class="line">        <span class="comment">// b 的 编译类型是 BB 而 运行类型 则是 jdk自动赋予的 一个类（$1之类的类） 且只使用一次</span></span><br><span class="line">        BB b=<span class="keyword">new</span> <span class="title class_">BB</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//外部类 可以直接调用 在 f1()方法 体内的匿名内部类实体对象 </span></span><br><span class="line">        b.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="2-符合-局部局部内部类-的-1、2、3条规则"><a href="#2-符合-局部局部内部类-的-1、2、3条规则" class="headerlink" title="2. 符合 局部局部内部类 的 1、2、3条规则"></a>2. 符合 局部局部内部类 的 1、2、3条规则</h5></li><li><h5 id="3-最佳-实践方式"><a href="#3-最佳-实践方式" class="headerlink" title="3. 最佳 实践方式"></a>3. 最佳 实践方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AA a=<span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="comment">// 使用 一次 的传参类 方便 快捷</span></span><br><span class="line">        a.f2(<span class="keyword">new</span> <span class="title class_">BB</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;最佳实验演示&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(BB b)</span>&#123;</span><br><span class="line">        b.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h5 id="定义在外部类的成员位置上"><a href="#定义在外部类的成员位置上" class="headerlink" title="定义在外部类的成员位置上"></a>定义在外部类的成员位置上</h5><ul><li><h5 id="成员内部类（没有static修饰）"><a href="#成员内部类（没有static修饰）" class="headerlink" title="成员内部类（没有static修饰）"></a>成员内部类（没有static修饰）</h5><ul><li><h5 id="1-含义：定义在-外部类的成员位置，并且没有static修饰-即为成员内部类"><a href="#1-含义：定义在-外部类的成员位置，并且没有static修饰-即为成员内部类" class="headerlink" title="1.含义：定义在 外部类的成员位置，并且没有static修饰 即为成员内部类"></a>1.含义：定义在 外部类的成员位置，并且没有static修饰 即为成员内部类</h5></li><li><h5 id="2-可以添加-访问修饰符-public-static-default-private-因为-它的地位就是-一个-成员"><a href="#2-可以添加-访问修饰符-public-static-default-private-因为-它的地位就是-一个-成员" class="headerlink" title="2.可以添加 访问修饰符(public static default private)因为 它的地位就是 一个 成员"></a>2.可以添加 访问修饰符(public static default private)因为 它的地位就是 一个 成员</h5></li><li><h5 id="3-作用域-为-整个类体-外部其他类-想要获取-成员内部类-。可以通过-外部类-定义一个方法-来返回一个-成员内部类"><a href="#3-作用域-为-整个类体-外部其他类-想要获取-成员内部类-。可以通过-外部类-定义一个方法-来返回一个-成员内部类" class="headerlink" title="3.作用域 为 整个类体 外部其他类 想要获取 成员内部类 。可以通过 外部类 定义一个方法 来返回一个 成员内部类"></a>3.作用域 为 整个类体 外部其他类 想要获取 成员内部类 。可以通过 外部类 定义一个方法 来返回一个 成员内部类</h5></li><li><h5 id="4-外部类-访问-内部类，先-创建对象，再访问"><a href="#4-外部类-访问-内部类，先-创建对象，再访问" class="headerlink" title="4. 外部类 访问 内部类，先 创建对象，再访问"></a>4. 外部类 访问 内部类，先 创建对象，再访问</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AA aa=<span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        AA.BB bb=<span class="keyword">new</span> <span class="title class_">AA</span>.BB(); <span class="comment">//直接调用 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过 方法 获取</span></span><br><span class="line">        AA.BB b=aa.getBB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="comment">//成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BB bb=<span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        bb.say();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BB <span class="title function_">getBB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="静态内部类（有static修饰）"><a href="#静态内部类（有static修饰）" class="headerlink" title="静态内部类（有static修饰）"></a>静态内部类（有static修饰）</h5><ul><li><h5 id="1-可-直接访问-外部类的所有静态成员-，包括私有的-，但不能直接访问-非静态成员"><a href="#1-可-直接访问-外部类的所有静态成员-，包括私有的-，但不能直接访问-非静态成员" class="headerlink" title="1.可 直接访问 外部类的所有静态成员 ，包括私有的 ，但不能直接访问 非静态成员"></a>1.可 直接访问 外部类的所有静态成员 ，包括私有的 ，但不能直接访问 非静态成员</h5></li><li><h5 id="2-符合-成员内部类的2、3规则"><a href="#2-符合-成员内部类的2、3规则" class="headerlink" title="2. 符合 成员内部类的2、3规则"></a>2. 符合 成员内部类的2、3规则</h5></li></ul></li></ul></li></ul></li></ul><h3 id="3-枚举类-enum"><a href="#3-枚举类-enum" class="headerlink" title="3.枚举类(enum)"></a>3.枚举类(enum)</h3><ul><li><h4 id="1-含义：当-一个类-不需要-被修改-被设置定义属性的时候-就可以定义为-枚举类。"><a href="#1-含义：当-一个类-不需要-被修改-被设置定义属性的时候-就可以定义为-枚举类。" class="headerlink" title="1.含义：当 一个类 不需要 被修改 被设置定义属性的时候 就可以定义为 枚举类。"></a>1.含义：当 一个类 不需要 被修改 被设置定义属性的时候 就可以定义为 枚举类。</h4></li><li><h4 id="2-自定义枚举类"><a href="#2-自定义枚举类" class="headerlink" title="2. 自定义枚举类"></a>2. 自定义枚举类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义 枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String dec;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//static：为了 可以直接访问 final：不能被修改</span></span><br><span class="line">    <span class="comment">//自定义 枚举类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AA SPRING=<span class="keyword">new</span> <span class="title class_">AA</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AA SUMMER=<span class="keyword">new</span> <span class="title class_">AA</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;热&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有get方法 但是 不能有set 方法 因为 不需要被修改属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDec</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">(String name, String dec)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.dec = dec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AA&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, dec=&#x27;&quot;</span> + dec + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="3-使用enum定义枚举类"><a href="#3-使用enum定义枚举类" class="headerlink" title="3.使用enum定义枚举类"></a>3.使用enum定义枚举类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum 使用 枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    <span class="comment">//枚举属性 必须在 第一行</span></span><br><span class="line">    <span class="comment">//other:是 无参构造器 的 枚举属性 可以连()都不使用</span></span><br><span class="line">    <span class="comment">//SPRING(&quot;春天&quot;,&quot;暖&quot;)= public static final BB SPRING=new BB(&quot;春天&quot;,&quot;暖&quot;);</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;暖&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;热&quot;</span>),other;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String dec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDec</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BB(String name, String dec) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.dec = dec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BB() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BB&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, dec=&#x27;&quot;</span> + dec + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="4-使用细节"><a href="#4-使用细节" class="headerlink" title="4.使用细节"></a>4.使用细节</h4><ul><li><h5 id="当我们-使用-enum关键字-类-开发枚举类时，默认-会继承-Enum类"><a href="#当我们-使用-enum关键字-类-开发枚举类时，默认-会继承-Enum类" class="headerlink" title="当我们 使用 enum关键字 类 开发枚举类时，默认 会继承 Enum类"></a>当我们 使用 enum关键字 类 开发枚举类时，默认 会继承 Enum类</h5></li><li><h5 id="枚举对象-必须-放在-行首"><a href="#枚举对象-必须-放在-行首" class="headerlink" title="枚举对象 必须 放在 行首"></a>枚举对象 必须 放在 行首</h5></li><li><h5 id="enum类-不能继承其它类-既不能extends"><a href="#enum类-不能继承其它类-既不能extends" class="headerlink" title="enum类 不能继承其它类 (既不能extends)"></a>enum类 不能继承其它类 (既不能extends)</h5></li><li><h5 id="enum类-可以-实现接口"><a href="#enum类-可以-实现接口" class="headerlink" title="enum类 可以 实现接口"></a>enum类 可以 实现接口</h5></li></ul></li><li><h4 id="5-Enum-类-成员方法"><a href="#5-Enum-类-成员方法" class="headerlink" title="5.Enum 类 成员方法"></a>5.Enum 类 成员方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BB spring=BB.SPRING;</span><br><span class="line">        <span class="comment">//1.name()方法 通过 对象 可以获取到</span></span><br><span class="line">        System.out.println(spring.name());</span><br><span class="line">        <span class="comment">//2.ordinal: 返回当前对象的位置号，默认从0开始 SPRING 是0号</span></span><br><span class="line">        System.out.println(spring.ordinal());</span><br><span class="line">        <span class="comment">//3.values:返回当前枚举类的 所有常量</span></span><br><span class="line">        BB[] bbs=BB.values();</span><br><span class="line">        <span class="keyword">for</span>(BB i:bbs)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.valueOf:将 字符串 转化成枚举对象 要求字符串 必须为 已有的常量名 不然会报错</span></span><br><span class="line">        BB b2=BB.valueOf(<span class="string">&quot;SUMMER&quot;</span>); <span class="comment">//通过 valueOf 来 获取 一个常量对象</span></span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        <span class="comment">//5. compareTo: 比较 两个枚举常量，比较的是位置号</span></span><br><span class="line">        <span class="comment">// spring(SPRING) 与 b2(SUMMER) 比较， 小：-1 大 ：1 等于：0</span></span><br><span class="line">        System.out.println(spring.compareTo(b2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//enum 使用 枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    <span class="comment">//枚举属性 必须在 第一行</span></span><br><span class="line">    <span class="comment">//other:是 无参构造器 的 枚举属性 可以连()都不使用</span></span><br><span class="line">    <span class="comment">//SPRING(&quot;春天&quot;,&quot;暖&quot;)= public static final BB SPRING=new BB(&quot;春天&quot;,&quot;暖&quot;);</span></span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;暖&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;热&quot;</span>),other;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String dec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDec</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BB</span><span class="params">(String name, String dec)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.dec = dec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BB</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BB&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, dec=&#x27;&quot;</span> + dec + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-注解类（Annotation）"><a href="#4-注解类（Annotation）" class="headerlink" title="4.注解类（Annotation）"></a>4.注解类（Annotation）</h3><ul><li><h4 id="1-含义：注解-用于-去修饰和解释-包、类、属性、构造器、方法等数据信息。"><a href="#1-含义：注解-用于-去修饰和解释-包、类、属性、构造器、方法等数据信息。" class="headerlink" title="1.含义：注解 用于 去修饰和解释 包、类、属性、构造器、方法等数据信息。"></a>1.含义：注解 用于 去修饰和解释 包、类、属性、构造器、方法等数据信息。</h4></li><li><h4 id="2-常用注解类型："><a href="#2-常用注解类型：" class="headerlink" title="2.常用注解类型："></a>2.常用注解类型：</h4><ul><li><h5 id="Override-注解"><a href="#Override-注解" class="headerlink" title="@Override 注解"></a>@Override 注解</h5><ul><li><h5 id="用处：用于-子类的-重写方法上面。审核该-重写方法是否已经重写。-只能用于-方法"><a href="#用处：用于-子类的-重写方法上面。审核该-重写方法是否已经重写。-只能用于-方法" class="headerlink" title="用处：用于 子类的 重写方法上面。审核该 重写方法是否已经重写。 (只能用于 方法)"></a>用处：用于 子类的 重写方法上面。审核该 重写方法是否已经重写。 (只能用于 方法)</h5></li></ul></li><li><h5 id="SuppressWarnings-注解"><a href="#SuppressWarnings-注解" class="headerlink" title="@ SuppressWarnings 注解"></a>@ SuppressWarnings 注解</h5><ul><li><h5 id="用处：用于-抑制编译器的警告"><a href="#用处：用于-抑制编译器的警告" class="headerlink" title="用处：用于 抑制编译器的警告"></a>用处：用于 抑制编译器的警告</h5></li><li><h5 id="使用方法：可以通过-右侧的警告信息来-用哪一个警告-其中-all-可以抑制-所有的警告"><a href="#使用方法：可以通过-右侧的警告信息来-用哪一个警告-其中-all-可以抑制-所有的警告" class="headerlink" title="使用方法：可以通过 右侧的警告信息来 用哪一个警告 其中(all)可以抑制 所有的警告"></a>使用方法：可以通过 右侧的警告信息来 用哪一个警告 其中(all)可以抑制 所有的警告</h5></li><li><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E8%AD%A6%E5%91%8A%E8%A7%82%E7%9C%8B.png"></p></li><li><pre><code class="java">@SuppressWarnings(&quot;unused&quot;)  //添加注解 unusedpublic class Test &#123;    public static void main(String[] args) &#123;        int i;        List list=new List();        list.add(&quot;1&quot;);        list.add(&quot;xxx&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - </span><br><span class="line"></span><br><span class="line">- #### 3.元注解：</span><br><span class="line"></span><br><span class="line">  - ##### 含义：用于 修饰 其他的 Annotation。 </span><br><span class="line"></span><br><span class="line">  - ##### 常用的元注解：Retention(指定 注解的使用范围),Target(指定 注解可以在哪些地方使用),Documented（指定 注解 是否会在javadoc中 体现 ),Inherited(子类 会 继承父类注解)</span><br><span class="line"></span><br><span class="line">  - ![](D:\blog\source\images\Java复习\元注解.png)</span><br><span class="line"></span><br><span class="line">  - ##### 其中，@Interface 可以作为 标识 该类为注解类 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5. 异常处理</span><br><span class="line"></span><br><span class="line">- #### 1.异常 主要分为 两大类：</span><br><span class="line"></span><br><span class="line">  - ##### Error(错误)：Java虚拟机 无法解决的错误，是严重的错误。会导致程序直接崩溃 无法运行。如 栈溢出、内存饱满</span><br><span class="line"></span><br><span class="line">  - ##### Exception: 因 编程出错，或是 偶然因素引起的错误。 Exception 分为：运行时异常 与 编译时异常(既 编写完 编译器直接给你辨认出错误)</span><br><span class="line"></span><br><span class="line">- #### 2.异常体系图</span><br><span class="line"></span><br><span class="line">  ![](D:\blog\source\images\Java复习\异常体系图.png)</span><br><span class="line"></span><br><span class="line">- #### 3.异常处理方式</span><br><span class="line"></span><br><span class="line">  - ##### try-catch-finally:  在代码中 捕获异常 并且处理异常</span><br><span class="line"></span><br><span class="line">    - ##### 如果 发生异常 异常后面的代码 就不会去执行 而是直接跳到catch去执行</span><br><span class="line"></span><br><span class="line">    - ##### 如果 没有发生异常 则 不会进入 catch里面</span><br><span class="line"></span><br><span class="line">    - ##### 不管 有没有异常 都会跳到finally里面去执行</span><br><span class="line"></span><br><span class="line">    - ##### 也可以使用 try-finally来 配合使用，主要 利用finally 去关闭一些资源 </span><br><span class="line"></span><br><span class="line">  - ##### throws：将异常抛出，交给调用该方法的类去 处理</span><br><span class="line"></span><br><span class="line">    - ##### 对于 运行时的异常，程序中如果没有处理。默认就是throws的方式处理</span><br><span class="line"></span><br><span class="line">    - ##### 子类 重写 父类的方法时，所抛出的异常类型 要么和父类一样 要么是父类异常类型的 子类</span><br><span class="line"></span><br><span class="line">- #### 4.自定义 异常类</span><br><span class="line"></span><br><span class="line">  - ##### 含义：当 程序 出现一些 ”错误“的时候，而该错误 没有在 Throwable子类中描述处理。我们可以 自己设计一个异常处理类.</span><br><span class="line"></span><br><span class="line">  - ##### 定义 的异常类 要继承 Exception（编译异常） 或 RuntimeException （运行异常）</span><br><span class="line">  </span><br><span class="line">    ```java</span><br><span class="line">     public static void main(String[] args) throws ParseException &#123;</span><br><span class="line">            int age;</span><br><span class="line">            Scanner scanner=new Scanner(System.in);</span><br><span class="line">            age=scanner.nextInt();</span><br><span class="line">            if(!(age&gt;=18 &amp;&amp; age&lt;=30))&#123;  //不符合 则抛出异常</span><br><span class="line">                throw new AgeException(&quot;年龄应在18-30之间&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    //年龄输入异常</span><br><span class="line">    class AgeException extends RuntimeException&#123;</span><br><span class="line">        public AgeException(String message) &#123;</span><br><span class="line">            super(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><h3 id="6-包装类"><a href="#6-包装类" class="headerlink" title="6. 包装类"></a>6. 包装类</h3><ul><li><h4 id="1-包装类-分类"><a href="#1-包装类-分类" class="headerlink" title="1.包装类 分类"></a>1.包装类 分类</h4><p>![](D:\blog\source\images\Java复习\包装类 分类.png)</p></li><li><h4 id="2-包装类-和-基本数据类型-的转换"><a href="#2-包装类-和-基本数据类型-的转换" class="headerlink" title="2.包装类 和 基本数据类型 的转换"></a>2.包装类 和 基本数据类型 的转换</h4><ul><li><h5 id="装箱-与-拆箱：基本数据类型-包装类型（装箱），反之-则为-拆箱"><a href="#装箱-与-拆箱：基本数据类型-包装类型（装箱），反之-则为-拆箱" class="headerlink" title="装箱 与 拆箱：基本数据类型-&gt;包装类型（装箱），反之 则为 拆箱"></a>装箱 与 拆箱：基本数据类型-&gt;包装类型（装箱），反之 则为 拆箱</h5></li><li><h5 id="在-jdk5之前-需要手动进行装箱，jdk5之后-则可以自动装箱"><a href="#在-jdk5之前-需要手动进行装箱，jdk5之后-则可以自动装箱" class="headerlink" title="在 jdk5之前 需要手动进行装箱，jdk5之后 则可以自动装箱"></a>在 jdk5之前 需要手动进行装箱，jdk5之后 则可以自动装箱</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Test&#123;</span><br><span class="line">    <span class="comment">//jdk5之前的手动装箱 与 拆箱</span></span><br><span class="line">    <span class="comment">//手动装箱</span></span><br><span class="line">    <span class="type">int</span> n1=<span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.第一种 装箱</span></span><br><span class="line">    Integer integer1=<span class="keyword">new</span> <span class="title class_">Integer</span>(n1);  <span class="comment">//int -&gt;Integer</span></span><br><span class="line">    <span class="comment">//第二种 装箱</span></span><br><span class="line">    Integer integer3=Integer.valueof(n1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//手动拆箱</span></span><br><span class="line">    <span class="type">int</span> i=n2.intValue(); <span class="comment">//Integer-&gt;int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//jdk5 后 的自动 装箱 与 拆箱</span></span><br><span class="line">    <span class="type">int</span> n2=<span class="number">200</span>;</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    Integer integer2=n2; <span class="comment">//自动装箱 底层使用 Integer.valueof(n2);</span></span><br><span class="line">    <span class="comment">//拆箱</span></span><br><span class="line">    <span class="type">int</span> n3=integer2; <span class="comment">//自动拆箱 底层使用的是 n3.intValue();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="包装类-值得注意的测试题"><a href="#包装类-值得注意的测试题" class="headerlink" title="包装类 值得注意的测试题"></a>包装类 值得注意的测试题</h5><ul><li><p><img src="D:\blog\source\images\Java复习\包装类测试1.png"></p><h5 id="在-上图中的-三元运算符中-结果是-true的-因此-运行-new-Integer-1-但是-根据-精度优先级-此时-obj1-1-0，-三元运算符是一个整体"><a href="#在-上图中的-三元运算符中-结果是-true的-因此-运行-new-Integer-1-但是-根据-精度优先级-此时-obj1-1-0，-三元运算符是一个整体" class="headerlink" title="在 上图中的 三元运算符中,结果是 true的 因此 运行 new Integer(1),但是 根据 精度优先级 此时 obj1&#x3D;1.0，(三元运算符是一个整体)"></a>在 上图中的 三元运算符中,结果是 true的 因此 运行 new Integer(1),但是 根据 精度优先级 此时 obj1&#x3D;1.0，(三元运算符是一个整体)</h5></li><li><p><img src="D:\blog\source\images\Java复习\测试题2.png"></p><h5 id="比较-i1-i2，-这样子-比较-是不是-同一个对象。-很明显-两者分别new了-对象实例，不是用一个对象。输出false"><a href="#比较-i1-i2，-这样子-比较-是不是-同一个对象。-很明显-两者分别new了-对象实例，不是用一个对象。输出false" class="headerlink" title="比较 i1 &#x3D;&#x3D; i2， 这样子 比较 是不是 同一个对象。 很明显 两者分别new了 对象实例，不是用一个对象。输出false"></a>比较 i1 &#x3D;&#x3D; i2， 这样子 比较 是不是 同一个对象。 很明显 两者分别new了 对象实例，不是用一个对象。输出false</h5></li><li><p><img src="D:\blog\source\images\Java复习\测试题3.png"></p><h5 id="根据-Integer源码可知，当赋值-范围-不在-128-127里面-则会new一个对象返回，在数值范围里面-则直接返回原本对象-因此-他们-都是同一个对象-输出-true"><a href="#根据-Integer源码可知，当赋值-范围-不在-128-127里面-则会new一个对象返回，在数值范围里面-则直接返回原本对象-因此-他们-都是同一个对象-输出-true" class="headerlink" title="根据 Integer源码可知，当赋值 范围 不在 -128~127里面 则会new一个对象返回，在数值范围里面 则直接返回原本对象.因此 他们 都是同一个对象 输出 true"></a>根据 Integer源码可知，当赋值 范围 不在 -128~127里面 则会new一个对象返回，在数值范围里面 则直接返回原本对象.因此 他们 都是同一个对象 输出 true</h5></li><li><p><img src="D:\blog\source\images\Java复习\测试题4.png"></p><h5 id="比较-i11-与-i12，因为-i12-是一个基本数据类型，因此-比较得不是-对象是否同一个，而是比较数值-是否-相等。-数值相等-输出-true"><a href="#比较-i11-与-i12，因为-i12-是一个基本数据类型，因此-比较得不是-对象是否同一个，而是比较数值-是否-相等。-数值相等-输出-true" class="headerlink" title="比较 i11 与 i12，因为 i12 是一个基本数据类型，因此 比较得不是 对象是否同一个，而是比较数值 是否 相等。 数值相等 输出 true"></a>比较 i11 与 i12，因为 i12 是一个基本数据类型，因此 比较得不是 对象是否同一个，而是比较数值 是否 相等。 数值相等 输出 true</h5></li></ul></li></ul></li><li><h4 id="3-包装类-和-string类型的转换"><a href="#3-包装类-和-string类型的转换" class="headerlink" title="3.包装类 和 string类型的转换"></a>3.包装类 和 string类型的转换</h4><ul><li><pre><code class="java">void Test&#123;    // 包装类(Integer) -&gt; String    Integer i=100;    //1.   String str=i+&quot;&quot;;     //2.    String str2=i.toString();    //3.    String str3=String.valueOf(i);        //String -&gt; 包装类(Integer)    Stirng str4=&quot;12345&quot;;    //1.    Integer n1=Integer.parseInt(str4);    //2.    Integer n2=new Integer(str4); //利用了 Integer的 构造器&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- #### 4. Integer 与 Character 常用的方法</span><br><span class="line"></span><br><span class="line">  ![](D:\blog\source\images\Java复习\Integet与Character常用的方法.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.String 的三种类型</span><br><span class="line"></span><br><span class="line">- #### 1.String类型 内部结构分析</span><br><span class="line"></span><br><span class="line">  ![](D:\blog\source\images\Java复习\String结构分析.png)</span><br><span class="line"></span><br><span class="line">  - ##### 串行化：可以 理解为 继承了该接口 可以在互联网上传输数据</span><br><span class="line"></span><br><span class="line">  - ##### 在源码中 可以看到 String类型的数据 主要存储在一个 final 类型的 value[]的字符数组中，这说明该字符（地址）是不能被修改的。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### 2.两种创建String类型的对象区别</span><br><span class="line"></span><br><span class="line">  - ##### 直接赋值 String str1=&quot;jack&quot;;</span><br><span class="line"></span><br><span class="line">    - 会直接 去 常量池中 查找 是否存在 &quot;jack&quot; 常量，有则直接指向该常量地址，没有则创建。最终 s会指向常量池中的 常量地址</span><br><span class="line"></span><br><span class="line">  - ##### 调用构造器 String str2=new String(&quot;s&quot;);</span><br><span class="line"></span><br><span class="line">    - 先 去 堆中创建空间 里面维护了 value的属性，value指向 常量池中的地址，就像直接赋值那样寻找常量。最终s指向 堆中的空间地址</span><br><span class="line"></span><br><span class="line">  - ![](D:\blog\source\images\Java复习\两种构建String对象.png)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### 3.字符串的特性</span><br><span class="line"></span><br><span class="line">  - ##### String 是一个final类，代表不可变的字符序列 (final value[] 中 可以看出)</span><br><span class="line"></span><br><span class="line">  - ##### 字符串是 不可变的，一个字符串对象一旦被创建, 其字符串内容 是不可变的。(字符串内容 指的是 常量池里面创建的 常量不可变 不是说 字符串对象 指向 的 常量不可变)</span><br><span class="line"></span><br><span class="line">  - ##### 具体实例</span><br><span class="line"></span><br><span class="line">    - ##### String a=&quot;hello&quot;+&quot;abc&quot; ，创建了一个对象 编译器 优化成 a=&quot;helloabc&quot; </span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">              String a=&quot;hello&quot;;</span><br><span class="line">              String b=&quot;abc&quot;;</span><br><span class="line">              String c=a+b;  //创建了三个对象 根据源码可知, 执行 a+b的操作中 创建了 StringBulider 对象（里面有value对象）</span><br><span class="line">          // c 指向 堆中的 value地址</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>- ![](.\Java复习\String测试题4.png)   ![](.\Java复习\String测试题4分布图.png)</code></pre></li></ul></li><li><h4 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h4><p><img src="/.%5CJava%E5%A4%8D%E4%B9%A0%5CString%E6%96%B9%E6%B3%95.png"></p><p><img src="/.%5CJava%E5%A4%8D%E4%B9%A0%5CString%E6%96%B9%E6%B3%952.png"></p></li><li><h4 id="4-StringBuffer类"><a href="#4-StringBuffer类" class="headerlink" title="4. StringBuffer类"></a>4. StringBuffer类</h4><ul><li><h5 id="1-含义：代表可变的-字符序列-可以对-字符串的内容-进行-增删操作-方法-与-String相同-StringBuffer是可变长度的"><a href="#1-含义：代表可变的-字符序列-可以对-字符串的内容-进行-增删操作-方法-与-String相同-StringBuffer是可变长度的" class="headerlink" title="1. 含义：代表可变的 字符序列, 可以对 字符串的内容 进行 增删操作.方法 与 String相同,StringBuffer是可变长度的."></a>1. 含义：代表可变的 字符序列, 可以对 字符串的内容 进行 增删操作.方法 与 String相同,StringBuffer是可变长度的.</h5></li><li><h5 id="2-String-与-StringBuffer-比较"><a href="#2-String-与-StringBuffer-比较" class="headerlink" title="2.String 与 StringBuffer 比较"></a>2.String 与 StringBuffer 比较</h5><ul><li><h5 id="String-保存的是字符串常量，里面的值不能更改-每次String类-的更新实际上-就是更改地址，效率极低。而StringBuffer可以更新内容，不用更新地址，效率极高。（放-在char-value）"><a href="#String-保存的是字符串常量，里面的值不能更改-每次String类-的更新实际上-就是更改地址，效率极低。而StringBuffer可以更新内容，不用更新地址，效率极高。（放-在char-value）" class="headerlink" title="String 保存的是字符串常量，里面的值不能更改,每次String类 的更新实际上 就是更改地址，效率极低。而StringBuffer可以更新内容，不用更新地址，效率极高。（放 在char [] value）"></a>String 保存的是字符串常量，里面的值不能更改,每次String类 的更新实际上 就是更改地址，效率极低。而StringBuffer可以更新内容，不用更新地址，效率极高。（放 在char [] value）</h5></li></ul></li><li><h5 id="3-构造器的使用-与-String和-StringBuffer的相互转换"><a href="#3-构造器的使用-与-String和-StringBuffer的相互转换" class="headerlink" title="3.构造器的使用 与 String和 StringBuffer的相互转换"></a>3.构造器的使用 与 String和 StringBuffer的相互转换</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//构造器的使用</span></span><br><span class="line">        <span class="comment">//1. 空参数 会创建一个 长度16的 字符数组 value[16]（不是 final修饰的）</span></span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 参数 为 初始化 字符数组value的长度</span></span><br><span class="line">        StringBuffer sb2=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 参数为 字符串，创建一个字符数组为  jack+16的 字符数组</span></span><br><span class="line">        StringBuffer sb3=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String 与 StringBuffer之间的转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String - StringBuffer</span></span><br><span class="line">        <span class="comment">//1. 构造器</span></span><br><span class="line">        String str1=<span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br><span class="line">        <span class="comment">//2.append方法</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer2=stringBuffer2.append(str1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuffer - String</span></span><br><span class="line">        <span class="comment">//1 .toString 方法</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        String jackStr=jack.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 构造器</span></span><br><span class="line">        String jackStr2=<span class="keyword">new</span> <span class="title class_">String</span>(jack);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="5-StringBuilder类"><a href="#5-StringBuilder类" class="headerlink" title="5. StringBuilder类"></a>5. StringBuilder类</h4><ul><li><h5 id="含义：一个可变的-字符序列-主要用于-对-字符串的-增改操作使用。与StringBuffer类似-不过不能保证线程安全"><a href="#含义：一个可变的-字符序列-主要用于-对-字符串的-增改操作使用。与StringBuffer类似-不过不能保证线程安全" class="headerlink" title="含义：一个可变的 字符序列, 主要用于 对 字符串的 增改操作使用。与StringBuffer类似 不过不能保证线程安全."></a>含义：一个可变的 字符序列, 主要用于 对 字符串的 增改操作使用。与StringBuffer类似 不过不能保证线程安全.</h5></li></ul></li><li><h4 id="6-使用总结：如果需要频繁的对字符串进行修改，且不需要考虑线程问题-用-StringBuilder-考虑则-使用StringBuffer。-正常情况用-String。"><a href="#6-使用总结：如果需要频繁的对字符串进行修改，且不需要考虑线程问题-用-StringBuilder-考虑则-使用StringBuffer。-正常情况用-String。" class="headerlink" title="6.使用总结：如果需要频繁的对字符串进行修改，且不需要考虑线程问题 用 StringBuilder 考虑则 使用StringBuffer。 正常情况用 String。"></a>6.使用总结：如果需要频繁的对字符串进行修改，且不需要考虑线程问题 用 StringBuilder 考虑则 使用StringBuffer。 正常情况用 String。</h4></li></ul><h3 id="8-Arrays类"><a href="#8-Arrays类" class="headerlink" title="8.Arrays类"></a>8.Arrays类</h3><ul><li><h4 id="1-用处：Aarrays-存储了-一系列的静态方法，用于管理-或者-操作-数组。"><a href="#1-用处：Aarrays-存储了-一系列的静态方法，用于管理-或者-操作-数组。" class="headerlink" title="1.用处：Aarrays 存储了 一系列的静态方法，用于管理 或者 操作 数组。"></a>1.用处：Aarrays 存储了 一系列的静态方法，用于管理 或者 操作 数组。</h4></li><li><h4 id="2-Arrays-常用方法："><a href="#2-Arrays-常用方法：" class="headerlink" title="2.Arrays 常用方法："></a>2.Arrays 常用方法：</h4><ul><li><img src="/../images/Java%E5%A4%8D%E4%B9%A0/Arrays%E6%96%B9%E6%B3%951.png"></li><li><img src="/../images/Java%E5%A4%8D%E4%B9%A0/Arrays%E6%96%B9%E6%B3%952.png"></li></ul></li></ul><h3 id="9-集合类"><a href="#9-集合类" class="headerlink" title="9.集合类"></a>9.集合类</h3><ul><li><h4 id="1-两大-集合体系图"><a href="#1-两大-集合体系图" class="headerlink" title="1. 两大 集合体系图"></a>1. 两大 集合体系图</h4><ul><li><h5 id="分为-单列集合（Collection）-和-双列集合（Map）"><a href="#分为-单列集合（Collection）-和-双列集合（Map）" class="headerlink" title="分为 单列集合（Collection） 和 双列集合（Map）"></a>分为 单列集合（Collection） 和 双列集合（Map）</h5><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/Collection%E4%BD%93%E7%B3%BB%E5%9B%BE.png"></p><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/Map%E4%BD%93%E7%B3%BB%E5%9B%BE.png"></p></li></ul></li><li><h4 id="2-Collection接口类"><a href="#2-Collection接口类" class="headerlink" title="2. Collection接口类"></a>2. Collection接口类</h4><ul><li><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><h5 id="1-Collection-实现子类可以存放多个元素，每个元素都是Object"><a href="#1-Collection-实现子类可以存放多个元素，每个元素都是Object" class="headerlink" title="1. Collection 实现子类可以存放多个元素，每个元素都是Object"></a>1. Collection 实现子类可以存放多个元素，每个元素都是Object</h5></li><li><h5 id="2-有些-Collection的-实现类-可以存放重复的元素-有些-则不可以"><a href="#2-有些-Collection的-实现类-可以存放重复的元素-有些-则不可以" class="headerlink" title="2. 有些 Collection的 实现类 可以存放重复的元素 有些 则不可以"></a>2. 有些 Collection的 实现类 可以存放重复的元素 有些 则不可以</h5></li><li><h5 id="3-有些-Collection的-实现类是-有序的-List-，有些不是有序的（Set）"><a href="#3-有些-Collection的-实现类是-有序的-List-，有些不是有序的（Set）" class="headerlink" title="3. 有些 Collection的 实现类是 有序的(List) ，有些不是有序的（Set）"></a>3. 有些 Collection的 实现类是 有序的(List) ，有些不是有序的（Set）</h5></li><li><h5 id="4-Collection接口-没有-直接的实现子类，是通过它的子接口-Set-和-List-来实现的"><a href="#4-Collection接口-没有-直接的实现子类，是通过它的子接口-Set-和-List-来实现的" class="headerlink" title="4. Collection接口 没有 直接的实现子类，是通过它的子接口 Set 和 List 来实现的"></a>4. Collection接口 没有 直接的实现子类，是通过它的子接口 Set 和 List 来实现的</h5></li></ul></li><li><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95.png"></p></li><li><h4 id="Collection接口的-遍历方式"><a href="#Collection接口的-遍历方式" class="headerlink" title="Collection接口的 遍历方式"></a>Collection接口的 遍历方式</h4><ul><li><h5 id="1-使用-Iterator-迭代器"><a href="#1-使用-Iterator-迭代器" class="headerlink" title="1. 使用 Iterator(迭代器)"></a>1. 使用 Iterator(迭代器)</h5><ul><li><h5 id="执行原理：Collection-中存入的元素-Interator都放在了一个-类似于-栈的空间中，遍历时-不断输入自身，并指向下一个元素来进行遍历"><a href="#执行原理：Collection-中存入的元素-Interator都放在了一个-类似于-栈的空间中，遍历时-不断输入自身，并指向下一个元素来进行遍历" class="headerlink" title="执行原理：Collection 中存入的元素  Interator都放在了一个 类似于 栈的空间中，遍历时 不断输入自身，并指向下一个元素来进行遍历"></a>执行原理：Collection 中存入的元素  Interator都放在了一个 类似于 栈的空间中，遍历时 不断输入自身，并指向下一个元素来进行遍历</h5><h5 id="images-Java复习-Iterator迭代器-执行原理-png"><a href="#images-Java复习-Iterator迭代器-执行原理-png" class="headerlink" title="![](&#x2F;..&#x2F;images&#x2F;Java复习&#x2F;Iterator迭代器 执行原理.png)"></a>![](&#x2F;..&#x2F;images&#x2F;Java复习&#x2F;Iterator迭代器 执行原理.png)</h5></li><li><h5 id="使用方法：-可以使用-itit快捷键-快速生成迭代器遍历"><a href="#使用方法：-可以使用-itit快捷键-快速生成迭代器遍历" class="headerlink" title="使用方法：(可以使用 itit快捷键 快速生成迭代器遍历)"></a>使用方法：(可以使用 itit快捷键 快速生成迭代器遍历)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        Collection co=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        co.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        co.add(<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        co.add(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">        <span class="comment">//通过 Collection 类来获得 迭代器</span></span><br><span class="line">        Iterator iterator=co.iterator();</span><br><span class="line">        <span class="comment">//通过 hasNext()方法 来判断是否还有数据</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object obj=iterator.next(); <span class="comment">//返回下一个数据</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//每次 遍历完 如果 想要再次遍历 需要对iterator再次进行初始化 才能遍历 。</span></span><br><span class="line">    iterator=co.iterator();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="2-使用-强化-for-循环"><a href="#2-使用-强化-for-循环" class="headerlink" title="2. 使用 强化 for 循环"></a>2. 使用 强化 for 循环</h5><ul><li><h5 id="原理：还是用了-迭代器的原理来进行遍历"><a href="#原理：还是用了-迭代器的原理来进行遍历" class="headerlink" title="原理：还是用了 迭代器的原理来进行遍历"></a>原理：还是用了 迭代器的原理来进行遍历</h5></li><li><h5 id="使用方法：-（快捷键-I-）"><a href="#使用方法：-（快捷键-I-）" class="headerlink" title="使用方法： （快捷键 I ）"></a>使用方法： （快捷键 I ）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强化for循环遍历</span></span><br><span class="line">       <span class="keyword">for</span>(Object obj:co)&#123;</span><br><span class="line">           System.out.println(obj);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><h4 id="3-List-接口"><a href="#3-List-接口" class="headerlink" title="3. List 接口"></a>3. List 接口</h4><ul><li><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><h5 id="List-集合中的元素是有序的-存入顺序-和-取出顺序-一样-、且可重复的-可以放相同的-元素"><a href="#List-集合中的元素是有序的-存入顺序-和-取出顺序-一样-、且可重复的-可以放相同的-元素" class="headerlink" title="List 集合中的元素是有序的(存入顺序 和 取出顺序 一样)、且可重复的( 可以放相同的 元素)"></a>List 集合中的元素是有序的(存入顺序 和 取出顺序 一样)、且可重复的( 可以放相同的 元素)</h5></li><li><h5 id="List集合-中的元素-都有相对应的索引-就像-数组一样"><a href="#List集合-中的元素-都有相对应的索引-就像-数组一样" class="headerlink" title="List集合 中的元素 都有相对应的索引 就像 数组一样"></a>List集合 中的元素 都有相对应的索引 就像 数组一样</h5></li></ul></li><li><h4 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/List%E6%96%B9%E6%B3%95.png"></p></li><li><h4 id="ArrayList-注意事项"><a href="#ArrayList-注意事项" class="headerlink" title="ArrayList 注意事项"></a>ArrayList 注意事项</h4><ul><li><h5 id="ArrayList-是由-数组-来实现数据存储的"><a href="#ArrayList-是由-数组-来实现数据存储的" class="headerlink" title="ArrayList 是由 数组 来实现数据存储的"></a>ArrayList 是由 数组 来实现数据存储的</h5></li><li><h5 id="ArrayList-基本等同于-Vector，除了-ArrayList是-线程不安全的-没有-synchronized修饰-，在多线程的情况下，不建议使用ArrayList"><a href="#ArrayList-基本等同于-Vector，除了-ArrayList是-线程不安全的-没有-synchronized修饰-，在多线程的情况下，不建议使用ArrayList" class="headerlink" title="ArrayList 基本等同于 Vector，除了 ArrayList是 线程不安全的(没有 synchronized修饰)，在多线程的情况下，不建议使用ArrayList"></a>ArrayList 基本等同于 Vector，除了 ArrayList是 线程不安全的(没有 synchronized修饰)，在多线程的情况下，不建议使用ArrayList</h5></li></ul></li><li><h4 id="ArrayList-底层扩容机制"><a href="#ArrayList-底层扩容机制" class="headerlink" title="ArrayList 底层扩容机制"></a>ArrayList 底层扩容机制</h4><ul><li><h5 id="无参构造创建-ArrayList对象"><a href="#无参构造创建-ArrayList对象" class="headerlink" title="无参构造创建 ArrayList对象"></a>无参构造创建 ArrayList对象</h5><ul><li><h5 id="开始的-list对象-的-数组为0-，第一次扩容会变为10-，随后需要扩容-扩容的长度为-原本长度的-1-5倍"><a href="#开始的-list对象-的-数组为0-，第一次扩容会变为10-，随后需要扩容-扩容的长度为-原本长度的-1-5倍" class="headerlink" title="开始的 list对象 的 数组为0 ，第一次扩容会变为10 ，随后需要扩容 扩容的长度为 原本长度的 1.5倍"></a>开始的 list对象 的 数组为0 ，第一次扩容会变为10 ，随后需要扩容 扩容的长度为 原本长度的 1.5倍</h5></li></ul></li><li><h5 id="有参构造-的-ArrayList-对象"><a href="#有参构造-的-ArrayList-对象" class="headerlink" title="有参构造 的 ArrayList 对象"></a>有参构造 的 ArrayList 对象</h5><ul><li><h5 id="开始的-list对象长度-为-参数，随后需要扩容就和-正常一样-为-1-5倍"><a href="#开始的-list对象长度-为-参数，随后需要扩容就和-正常一样-为-1-5倍" class="headerlink" title="开始的 list对象长度 为 参数，随后需要扩容就和 正常一样 为 1.5倍"></a>开始的 list对象长度 为 参数，随后需要扩容就和 正常一样 为 1.5倍</h5></li></ul></li></ul></li><li><h4 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h4><ul><li><h5 id="说明：Vector-底层也是一个对象数组（protected-Object-elementData）并且-线程是安全的"><a href="#说明：Vector-底层也是一个对象数组（protected-Object-elementData）并且-线程是安全的" class="headerlink" title="说明：Vector 底层也是一个对象数组（protected Object[] elementData）并且 线程是安全的"></a>说明：Vector 底层也是一个对象数组（protected Object[] elementData）并且 线程是安全的</h5></li><li><h5 id="Vector-与-ArrayList-的比较"><a href="#Vector-与-ArrayList-的比较" class="headerlink" title="Vector 与 ArrayList 的比较"></a>Vector 与 ArrayList 的比较</h5><p>![](&#x2F;..&#x2F;images&#x2F;Java复习&#x2F;Vector 与 ArrayList比较.png)</p></li></ul></li><li><h4 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h4><ul><li><h5 id="1-说明：LinkedList-实现了-双向链表-和-双端队列的特点、线程不安全。"><a href="#1-说明：LinkedList-实现了-双向链表-和-双端队列的特点、线程不安全。" class="headerlink" title="1. 说明：LinkedList 实现了 双向链表 和 双端队列的特点、线程不安全。"></a>1. 说明：LinkedList 实现了 双向链表 和 双端队列的特点、线程不安全。</h5></li><li><h5 id="2-ArrayList-与-LinkedList-比较"><a href="#2-ArrayList-与-LinkedList-比较" class="headerlink" title="2. ArrayList 与 LinkedList 比较"></a>2. ArrayList 与 LinkedList 比较</h5><p>![](&#x2F;..&#x2F;images&#x2F;Java复习&#x2F;LinkedList 与 ArrayList比较.png)</p></li><li><h5 id="3-如果-改查操作比较多-选择ArrayList，-增删操作多-选择LinkedList"><a href="#3-如果-改查操作比较多-选择ArrayList，-增删操作多-选择LinkedList" class="headerlink" title="3. 如果 改查操作比较多 选择ArrayList， 增删操作多 选择LinkedList"></a>3. 如果 改查操作比较多 选择ArrayList， 增删操作多 选择LinkedList</h5></li></ul></li></ul></li><li><h4 id="4-Set接口"><a href="#4-Set接口" class="headerlink" title="4. Set接口"></a>4. Set接口</h4><ul><li><h4 id="1-基本介绍："><a href="#1-基本介绍：" class="headerlink" title="1.基本介绍："></a>1.基本介绍：</h4><ul><li><h5 id="1-无序的（添加时的顺序-与-取出的顺序不一致）"><a href="#1-无序的（添加时的顺序-与-取出的顺序不一致）" class="headerlink" title="1.无序的（添加时的顺序 与 取出的顺序不一致）"></a>1.无序的（添加时的顺序 与 取出的顺序不一致）</h5></li><li><h5 id="2-不允许有重复的数据，所以-最多只有一个null值"><a href="#2-不允许有重复的数据，所以-最多只有一个null值" class="headerlink" title="2.不允许有重复的数据，所以 最多只有一个null值"></a>2.不允许有重复的数据，所以 最多只有一个null值</h5></li><li><h5 id="3-JDK的主要实现类有：HashSet-、LinkHashSet、TreeSet"><a href="#3-JDK的主要实现类有：HashSet-、LinkHashSet、TreeSet" class="headerlink" title="3.JDK的主要实现类有：HashSet 、LinkHashSet、TreeSet"></a>3.JDK的主要实现类有：HashSet 、LinkHashSet、TreeSet</h5></li></ul></li><li><h4 id="2-HashSet说明"><a href="#2-HashSet说明" class="headerlink" title="2.HashSet说明:"></a>2.HashSet说明:</h4><ul><li><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><ul><li><h5 id="1-HashSet-本质上-就是HashMap"><a href="#1-HashSet-本质上-就是HashMap" class="headerlink" title="1.HashSet 本质上 就是HashMap"></a>1.HashSet 本质上 就是HashMap</h5></li><li><h5 id="2-不能保证元素时有序的"><a href="#2-不能保证元素时有序的" class="headerlink" title="2.不能保证元素时有序的"></a>2.不能保证元素时有序的</h5></li><li><h5 id="3-不能添加-相同的-元素-对象"><a href="#3-不能添加-相同的-元素-对象" class="headerlink" title="3.不能添加 相同的   元素&#x2F;对象"></a>3.不能添加 相同的   元素&#x2F;对象</h5></li></ul></li><li><h4 id="2-底层机制分析"><a href="#2-底层机制分析" class="headerlink" title="2.底层机制分析"></a>2.底层机制分析</h4><ul><li><h4 id="1-HashSet的-底层是-HashMap-，而HashMap的底层机制是（数组-链表-红黑树）"><a href="#1-HashSet的-底层是-HashMap-，而HashMap的底层机制是（数组-链表-红黑树）" class="headerlink" title="1.HashSet的 底层是 HashMap ，而HashMap的底层机制是（数组+链表+红黑树）"></a>1.HashSet的 底层是 HashMap ，而HashMap的底层机制是（数组+链表+红黑树）</h4><img src="/../images/Java%E5%A4%8D%E4%B9%A0/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6.png"></li></ul></li><li><h4 id="2-HashSet的-扩容机制（实际既-HashMap的-扩容机制）"><a href="#2-HashSet的-扩容机制（实际既-HashMap的-扩容机制）" class="headerlink" title="2.HashSet的 扩容机制（实际既 HashMap的 扩容机制）"></a>2.HashSet的 扩容机制（实际既 HashMap的 扩容机制）</h4><ul><li><h5 id="1-底层结构：有一数组-名为-table，每一个-索引-都是一处-链表。"><a href="#1-底层结构：有一数组-名为-table，每一个-索引-都是一处-链表。" class="headerlink" title="1.底层结构：有一数组 名为 table，每一个 索引 都是一处 链表。"></a>1.底层结构：有一数组 名为 table，每一个 索引 都是一处 链表。</h5></li><li><h5 id="2-添加操作底层分析："><a href="#2-添加操作底层分析：" class="headerlink" title="2.添加操作底层分析："></a>2.添加操作底层分析：</h5><p>![](&#x2F;..&#x2F;images&#x2F;Java复习&#x2F;HashSet add方法底层分析.png)</p></li><li><h5 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h5><ul><li><h5 id="1-明白一点，数组的大小初始长度是16-但是，根据底层设计，能用的长度-其实-只有12-，-既-0-75-16-12。长度12-类似于-缓存长度。"><a href="#1-明白一点，数组的大小初始长度是16-但是，根据底层设计，能用的长度-其实-只有12-，-既-0-75-16-12。长度12-类似于-缓存长度。" class="headerlink" title="1. 明白一点，数组的大小初始长度是16 但是，根据底层设计，能用的长度 其实 只有12 ， 既 0.75 * 16 &#x3D;12。长度12 类似于 缓存长度。"></a>1. 明白一点，数组的大小初始长度是16 但是，根据底层设计，能用的长度 其实 只有12 ， 既 0.75 * 16 &#x3D;12。长度12 类似于 缓存长度。</h5></li><li><h5 id="2-扩容的条件是-里面有一种-size值-用来-记录-添加node结点的次数-。当-size值-达到-缓存长度-就会进行-扩容。-扩容大小-是原来长度的-两倍。这是-就会变成-长度32（缓存长度：0-75-32-24）"><a href="#2-扩容的条件是-里面有一种-size值-用来-记录-添加node结点的次数-。当-size值-达到-缓存长度-就会进行-扩容。-扩容大小-是原来长度的-两倍。这是-就会变成-长度32（缓存长度：0-75-32-24）" class="headerlink" title="2. 扩容的条件是 里面有一种 size值 用来 记录 添加node结点的次数 。当 size值 达到 缓存长度 就会进行 扩容。 扩容大小 是原来长度的 两倍。这是 就会变成 长度32（缓存长度：0.75 * 32 &#x3D; 24）"></a>2. 扩容的条件是 里面有一种 size值 用来 记录 添加node结点的次数 。当 size值 达到 缓存长度 就会进行 扩容。 扩容大小 是原来长度的 两倍。这是 就会变成 长度32（缓存长度：0.75 * 32 &#x3D; 24）</h5></li></ul></li><li><h5 id="4-红黑树化机制"><a href="#4-红黑树化机制" class="headerlink" title="4. 红黑树化机制"></a>4. 红黑树化机制</h5><ul><li><h5 id="1-树化-是为了-更好的-节省空间-。-优化效率"><a href="#1-树化-是为了-更好的-节省空间-。-优化效率" class="headerlink" title="1. 树化 是为了 更好的 节省空间 。 优化效率"></a>1. 树化 是为了 更好的 节省空间 。 优化效率</h5></li><li><h5 id="2-当-某索引的链表中的结点-已满8个-，并且-table数组的长度大小-要-64，才会进行树化操作。"><a href="#2-当-某索引的链表中的结点-已满8个-，并且-table数组的长度大小-要-64，才会进行树化操作。" class="headerlink" title="2. 当 某索引的链表中的结点 已满8个 ，并且 table数组的长度大小 要 &gt;&#x3D;64，才会进行树化操作。"></a>2. 当 某索引的链表中的结点 已满8个 ，并且 table数组的长度大小 要 &gt;&#x3D;64，才会进行树化操作。</h5></li><li><h5 id="3-要是-结点已满8个-但是-table数组-不满64，则会扩容table-，添加的结点会-继续-添加在链表的后面。"><a href="#3-要是-结点已满8个-但是-table数组-不满64，则会扩容table-，添加的结点会-继续-添加在链表的后面。" class="headerlink" title="3. 要是 结点已满8个 但是 table数组 不满64，则会扩容table ，添加的结点会 继续 添加在链表的后面。"></a>3. 要是 结点已满8个 但是 table数组 不满64，则会扩容table ，添加的结点会 继续 添加在链表的后面。</h5></li><li><h5 id="4-满足-两个树化条件后，会把该索引的Node结点-变成-treeNode-结点。-完成树化操作"><a href="#4-满足-两个树化条件后，会把该索引的Node结点-变成-treeNode-结点。-完成树化操作" class="headerlink" title="4. 满足 两个树化条件后，会把该索引的Node结点 变成 treeNode 结点。 完成树化操作"></a>4. 满足 两个树化条件后，会把该索引的Node结点 变成 treeNode 结点。 完成树化操作</h5></li></ul></li></ul></li></ul></li><li><h4 id="3-LinkHashSet说明"><a href="#3-LinkHashSet说明" class="headerlink" title="3.LinkHashSet说明"></a>3.LinkHashSet说明</h4><ul><li><h4 id="1-底层机构：LinkHashSet-的底层是-LinkHashMap-，维护的是-数组-双向链表的-结构。"><a href="#1-底层机构：LinkHashSet-的底层是-LinkHashMap-，维护的是-数组-双向链表的-结构。" class="headerlink" title="1.底层机构：LinkHashSet 的底层是 LinkHashMap ，维护的是 数组 + 双向链表的 结构。"></a>1.底层机构：LinkHashSet 的底层是 LinkHashMap ，维护的是 数组 + 双向链表的 结构。</h4></li><li><h4 id="2-特点：不允许-添加重复元素，存入的数据-与-取出-数据-是-有序的-。"><a href="#2-特点：不允许-添加重复元素，存入的数据-与-取出-数据-是-有序的-。" class="headerlink" title="2.特点：不允许 添加重复元素，存入的数据 与 取出 数据 是 有序的 。"></a>2.特点：不允许 添加重复元素，存入的数据 与 取出 数据 是 有序的 。</h4></li><li><h4 id="3-底层扩容机制-和-HashSet-是一样的。"><a href="#3-底层扩容机制-和-HashSet-是一样的。" class="headerlink" title="3.底层扩容机制 和 HashSet 是一样的。"></a>3.底层扩容机制 和 HashSet 是一样的。</h4></li></ul></li></ul></li><li><h4 id="5-Map接口"><a href="#5-Map接口" class="headerlink" title="5.Map接口"></a>5.Map接口</h4><ul><li><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="(1)  特点"></a>(1)  特点</h4><ul><li><h5 id="1-Map-中的-key-和-value-可以是-任何类型-，会封装到-HashMap-Node-中-。"><a href="#1-Map-中的-key-和-value-可以是-任何类型-，会封装到-HashMap-Node-中-。" class="headerlink" title="1.Map 中的 key 和 value 可以是 任何类型   ，会封装到 HashMap&amp;Node 中 。"></a>1.Map 中的 key 和 value 可以是 <em>任何类型</em>   ，会封装到 <em>HashMap&amp;Node</em> 中 。</h5></li><li><h5 id="2-Map-中的-key-是-不可以重复的-，而-Map中的value-是-可以重复的-如果-key值-重复，会覆盖-原来key值所对用的-value。"><a href="#2-Map-中的-key-是-不可以重复的-，而-Map中的value-是-可以重复的-如果-key值-重复，会覆盖-原来key值所对用的-value。" class="headerlink" title="2.Map 中的 key 是 不可以重复的  ，而 Map中的value 是 可以重复的  . 如果 key值 重复，会覆盖 原来key值所对用的 value。"></a>2.Map 中的 key 是 <em>不可以重复的</em>  ，而 Map中的value 是 <em>可以重复的</em>  . 如果 key值 重复，会覆盖 原来key值所对用的 value。</h5></li><li><h5 id="3-Map中的key-可以为-null-但是-只能是一个-而-value-的值-也可以为null-并且-可以是多个-。"><a href="#3-Map中的key-可以为-null-但是-只能是一个-而-value-的值-也可以为null-并且-可以是多个-。" class="headerlink" title="3.Map中的key 可以为 null 但是 只能是一个 而 value 的值 也可以为null 并且 可以是多个  。"></a>3.Map中的key 可以为 null 但是 <em>只能是一个</em> 而 value 的值 也可以为null 并且 <em>可以是多个</em>  。</h5></li><li><h5 id="4-Map中存放数据的-key-value，是放在Node中，Node-实现了-Entry-接口。为了方便遍历，entry里面-提供了-两个方法-getKey-与-getValue-通过这两个方法-可以获取-key-与-value。当然-里面提供了-entrySet-，可以用来获取每一个entry-从而获取-每一个-key-value"><a href="#4-Map中存放数据的-key-value，是放在Node中，Node-实现了-Entry-接口。为了方便遍历，entry里面-提供了-两个方法-getKey-与-getValue-通过这两个方法-可以获取-key-与-value。当然-里面提供了-entrySet-，可以用来获取每一个entry-从而获取-每一个-key-value" class="headerlink" title="4.Map中存放数据的 key-value，是放在Node中，Node 实现了 Entry 接口。为了方便遍历，entry里面 提供了 两个方法 getKey() 与 getValue()  通过这两个方法 可以获取 key 与 value。当然 里面提供了 entrySet&lt;entry&lt;k,v&gt;&gt;  ，可以用来获取每一个entry 从而获取 每一个 key-value"></a>4.Map中存放数据的 key-value，是放在Node中，Node 实现了 Entry 接口。为了方便遍历，entry里面 提供了 两个方法 <em>getKey() 与 getValue()</em>  通过这两个方法 可以获取 key 与 value。当然 里面提供了 <em>entrySet&lt;entry&lt;k,v&gt;&gt;</em>  ，可以用来获取每一个entry 从而获取 每一个 key-value</h5></li><li><h5 id="5-线程-是-不安全的（没有实现-Synchronized-接口）"><a href="#5-线程-是-不安全的（没有实现-Synchronized-接口）" class="headerlink" title="5. 线程 是 不安全的（没有实现 Synchronized 接口）"></a>5. 线程 是 不安全的（没有实现 Synchronized 接口）</h5></li></ul></li><li><h4 id="2-遍历方式"><a href="#2-遍历方式" class="headerlink" title="(2) 遍历方式"></a>(2) 遍历方式</h4><ul><li><pre><code class="java">            //准备条件              Employee2 e1=new Employee2(&quot;jack&quot;,200000,1);        Employee2 e2=new Employee2(&quot;ping&quot;,19000,2);        Employee2 e3=new Employee2(&quot;zs&quot;,2000,3);        Map map=new HashMap&lt;Integer,Employee2&gt;();        map.put(e1.getId(),e1);        map.put(e2.getId(),e2);        map.put(e3.getId(),e3); //key 为 id ，value 为 employee2类<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ##### 1. 利用 map.keySet() 进行遍历</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  Set set=map.keySet(); //拿到所有的 key</span><br><span class="line">  //1. 使用增强 for循环 进行 遍历</span><br><span class="line">  for(Object obj:set)&#123;</span><br><span class="line">      Employee2 m=(Employee2)map.get(obj); //拿到每一个 value</span><br><span class="line">      System.out.println(m);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //2.利用 迭代器 遍历</span><br><span class="line">  Iterator iterator=set.iterator();</span><br><span class="line">  while(iterator.hasNext())&#123;</span><br><span class="line">      Employee2 next =  (Employee2)iterator2.next();</span><br><span class="line">      System.out.println(next);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><h5 id="2-利用-map-entrySet-进行遍历"><a href="#2-利用-map-entrySet-进行遍历" class="headerlink" title="2.利用 map.entrySet() 进行遍历"></a>2.利用 map.entrySet() 进行遍历</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6.</span>Set entryset=map.entrySet(); <span class="comment">//获取 entrySet 里面包含所有的 entry&lt;k,v&gt;</span></span><br><span class="line"><span class="comment">//利用 增强for循环 遍历</span></span><br><span class="line"><span class="keyword">for</span>(Object entry:entryset)&#123;</span><br><span class="line">    Map.Entry m=(Map.entry)entry; <span class="comment">//把 每个entry 转型为 Map.entry. 因为 Map.entry 包含两个重要的遍历方法，getValue（）与 getKey（）</span></span><br><span class="line">    System.out.println(m.getValue()); <span class="comment">//输出 value 既 输出 employee2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用迭代器去 遍历</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> enterset.iterator();</span><br><span class="line"><span class="keyword">while</span>(iteratot.hasNext())&#123;</span><br><span class="line">    Object entry=iterator.next(); <span class="comment">//获取 每一个entry</span></span><br><span class="line">    Map.Entry m=(Map.Entry)entry; <span class="comment">//转型</span></span><br><span class="line">    Employee2 em=(Employee2)m.getValue();</span><br><span class="line">    System.out.println(em);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="6-HashTable接口"><a href="#6-HashTable接口" class="headerlink" title="6.HashTable接口"></a>6.HashTable接口</h4><ul><li><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="(1) 特点"></a>(1) 特点</h4><ul><li><h5 id="1-存放的元素是-键值对-既-key-value"><a href="#1-存放的元素是-键值对-既-key-value" class="headerlink" title="1. 存放的元素是 键值对 既 key-value"></a>1. 存放的元素是 <em>键值对</em> 既 key-value</h5></li><li><h5 id="2-HashTable-的-key-与-value-都-不可以为NULL"><a href="#2-HashTable-的-key-与-value-都-不可以为NULL" class="headerlink" title="2. HashTable 的 key 与 value 都 不可以为NULL"></a>2. HashTable 的 key 与 value 都 <em>不可以为NULL</em></h5></li><li><h5 id="3-HashTable-的-线程是安全的"><a href="#3-HashTable-的-线程是安全的" class="headerlink" title="3. HashTable 的 线程是安全的"></a>3. HashTable 的 <em>线程是安全的</em></h5></li></ul></li><li><h4 id="2-底层扩容机制"><a href="#2-底层扩容机制" class="headerlink" title="(2) 底层扩容机制"></a>(2) 底层扩容机制</h4><ul><li><h5 id="1-HashTable-的-底层-维护的-是一个-名为table-的数组-并且-初始的数组长度是-11。"><a href="#1-HashTable-的-底层-维护的-是一个-名为table-的数组-并且-初始的数组长度是-11。" class="headerlink" title="1.HashTable 的 底层 维护的 是一个 名为table 的数组, 并且 初始的数组长度是 11。"></a>1.HashTable 的 底层 维护的 是一个 <em>名为table 的数组</em>, 并且 初始的数组长度是 11。</h5></li><li><h5 id="2-当-数组到达-缓冲长度时（既-类似于-HashMap-，11-0-75-8，以此类推），便会进行扩容。"><a href="#2-当-数组到达-缓冲长度时（既-类似于-HashMap-，11-0-75-8，以此类推），便会进行扩容。" class="headerlink" title="2.当 数组到达 缓冲长度时（既 类似于 HashMap ，11*0.75&#x3D;8，以此类推），便会进行扩容。"></a>2.当 数组到达 缓冲长度时（既 类似于 HashMap ，11*0.75&#x3D;8，以此类推），便会进行扩容。</h5></li><li><h5 id="3-扩容的长度-为-int-newCapacity-oldCapacity-1-1"><a href="#3-扩容的长度-为-int-newCapacity-oldCapacity-1-1" class="headerlink" title="3. 扩容的长度 为  int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1; 既 原来的长度的 两倍 +1。"></a>3. 扩容的长度 为  <em>int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</em> 既 <em>原来的长度的 两倍 +1</em>。</h5></li></ul></li><li><h4 id="3-Properties接口"><a href="#3-Properties接口" class="headerlink" title="(3) Properties接口"></a>(3) Properties接口</h4><ul><li><h5 id="1-properties-是-继承HashTable-并且-实现-Map-接口-，因此-也是以-键值对-的形式存储数据的。"><a href="#1-properties-是-继承HashTable-并且-实现-Map-接口-，因此-也是以-键值对-的形式存储数据的。" class="headerlink" title="1.properties 是 继承HashTable 并且 实现 Map 接口 ，因此 也是以 键值对 的形式存储数据的。"></a>1.properties 是 继承HashTable 并且 实现 Map 接口 ，因此 也是以 <em>键值对</em> 的形式存储数据的。</h5></li><li><h5 id="2-Properties-可以用于-从-xx-properties-的配置文件中，加载到-peoperties-对象中-来进行读取-与-修改数据"><a href="#2-Properties-可以用于-从-xx-properties-的配置文件中，加载到-peoperties-对象中-来进行读取-与-修改数据" class="headerlink" title="2.Properties 可以用于 从 xx.properties 的配置文件中，加载到 peoperties 对象中 来进行读取 与 修改数据"></a>2.Properties 可以用于 从 xx.properties 的配置文件中，加载到 peoperties 对象中 来进行读取 与 修改数据</h5></li></ul></li></ul></li><li><h4 id="7-集合选择规则"><a href="#7-集合选择规则" class="headerlink" title="7. 集合选择规则"></a>7. 集合选择规则</h4><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E9%80%89%E6%8B%A9%E8%A7%84%E5%88%99.png" alt="te/"></h5></li><li><h4 id="8-TreeSet接口-类似于-TreeMap"><a href="#8-TreeSet接口-类似于-TreeMap" class="headerlink" title="8.TreeSet接口(类似于 TreeMap)"></a>8.TreeSet接口(类似于 TreeMap)</h4><ul><li><h4 id="1-特点-2"><a href="#1-特点-2" class="headerlink" title="(1) 特点"></a>(1) 特点</h4><ul><li><h5 id="TreeSet-接口-底层-就是-TreeMap。里面提供了-含有Compatator（比较类接口）为参数的-构造方法。可以自定义-数据的排序方式。"><a href="#TreeSet-接口-底层-就是-TreeMap。里面提供了-含有Compatator（比较类接口）为参数的-构造方法。可以自定义-数据的排序方式。" class="headerlink" title="TreeSet 接口 底层 就是 TreeMap。里面提供了  含有Compatator（比较类接口）为参数的 构造方法。可以自定义 数据的排序方式。"></a>TreeSet 接口 底层 就是 TreeMap。里面提供了  含有Compatator（比较类接口）为参数的 构造方法。可以自定义 数据的排序方式。</h5></li></ul></li><li><h4 id="2-底层实现"><a href="#2-底层实现" class="headerlink" title="(2) 底层实现"></a>(2) 底层实现</h4><ul><li><pre><code class="java">cmp = cpr.compare(key, t.key); //通过 这一段 来实现 对构造器的比较类的比较方法 进行 数据的存储方式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### 9.Collections 工具类</span><br><span class="line"></span><br><span class="line">  - #### (1) 用处：用来 操作 set、List、Map等集合的工具类</span><br><span class="line"></span><br><span class="line">  - #### (2) 具体方法:</span><br><span class="line"></span><br><span class="line">    ![](/../images/Java复习/Collections工具类方法1.png)</span><br><span class="line"></span><br><span class="line">    ![](/../images/Java复习/Colletions工具类方法2.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 10. 泛型</span><br><span class="line"></span><br><span class="line">- #### (1) 为什么使用泛型</span><br><span class="line"></span><br><span class="line">  - ##### 1. 在集合类型中（如 HashMap 或 ArrayList），可以通过定义泛型 来 *确定 该对象的 集合元素类型* ，这样 有助于遍历。</span><br><span class="line"></span><br><span class="line">  - ##### 2.  通过泛型，可以来 *定义一些 还不确定的属性*。在 初始化对象时，根据需求来 确定类型。 </span><br><span class="line"></span><br><span class="line">- #### (2) 泛型使用细节</span><br><span class="line"></span><br><span class="line">  - ##### 1. T、E 都只是一个 符号，没有具体意思。 </span><br><span class="line"></span><br><span class="line">  - ##### 2. 在指定 具体的 泛型类型后，可以传入该类型的 子类型。（既 子类 类型也可以）</span><br><span class="line"></span><br><span class="line">  - ##### 3. 若没有指定泛型，默认泛型类型时 Object。</span><br><span class="line"></span><br><span class="line">- #### （3）自定义泛型</span><br><span class="line"></span><br><span class="line">  - ##### 1.  注意事项</span><br><span class="line"></span><br><span class="line">    - ##### 1） 自定义泛型 不能运用于 静态的 方法/类。</span><br><span class="line"></span><br><span class="line">    - ##### 2） 使用泛型的数组 不能初始化。（因为不知道类型 不能分配空间）</span><br><span class="line"></span><br><span class="line">    - ##### 3） 没有指定泛型类型，默认是 Object。</span><br><span class="line"></span><br><span class="line">  - ##### 2. 自定义泛型的使用</span><br><span class="line"></span><br><span class="line">    - ##### 类的使用</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      class main()&#123;</span><br><span class="line">          //R:String M:Integer</span><br><span class="line">          Cat&lt;String,Integer&gt; cat=new Cat&lt;&gt;(); </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      class cat&lt;R,M&gt;&#123;</span><br><span class="line">          R r;</span><br><span class="line">          M m;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><h5 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Interface Cat&lt;R,M&gt;&#123;</span><br><span class="line"> <span class="keyword">public</span> R <span class="title function_">fly</span><span class="params">(M m)</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//R:String M:Integer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> implementss Cat&lt;String,Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fly</span><span class="params">(Integer integer)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">main</span>()&#123;</span><br><span class="line">    Person person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    String str=<span class="string">&quot;sss&quot;</span>;</span><br><span class="line">    person.fly(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        System.out.println(e.getClass().getSimpleName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="4-泛型继承与通配"><a href="#4-泛型继承与通配" class="headerlink" title="(4) 泛型继承与通配"></a>(4) 泛型继承与通配</h4><ul><li><h5 id="1-泛型-是-不具备-继承性-。-既-List-list-new-ArrayList-是错误的。"><a href="#1-泛型-是-不具备-继承性-。-既-List-list-new-ArrayList-是错误的。" class="headerlink" title="1.  泛型 是 不具备 继承性 。 既 List&lt;Object&gt; list=new ArrayList&lt;String&gt;;  是错误的。"></a>1.  泛型 是 不具备 <em>继承性</em> 。 既 <code>List&lt;Object&gt; list=new ArrayList&lt;String&gt;;</code>  是错误的。</h5></li><li><h5 id="2-List-中的-？-值的是-任意类型-的-泛型。"><a href="#2-List-中的-？-值的是-任意类型-的-泛型。" class="headerlink" title="2. List&lt;?&gt; 中的 ？ 值的是 任意类型 的 泛型。"></a>2. List&lt;?&gt; 中的 ？ 值的是 任意类型 的 泛型。</h5></li><li><h5 id="3-List-表示-支持泛型是-A类-或是-A类的子类。"><a href="#3-List-表示-支持泛型是-A类-或是-A类的子类。" class="headerlink" title="3. List&lt;? extends A&gt;: 表示 支持泛型是 A类 或是 A类的子类。"></a>3. List&lt;? extends A&gt;: 表示 支持泛型是 A类 或是 A类的子类。</h5></li><li><h5 id="4-List-表示-支持泛型是-A类-或是A类的-父类。"><a href="#4-List-表示-支持泛型是-A类-或是A类的-父类。" class="headerlink" title="4. List&lt;? super A&gt;: 表示 支持泛型是 A类 或是A类的 父类。"></a>4. List&lt;? super A&gt;: 表示 支持泛型是 A类 或是A类的 父类。</h5></li></ul></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-接口-interface&quot;&gt;&lt;a href=&quot;#1-接口-interface&quot; class=&quot;headerlink&quot; title=&quot;1.接口(interface)&quot;&gt;&lt;/a&gt;1.接口(interface)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1-含义：接</summary>
      
    
    
    
    
    <category term="-Java -复习" scheme="http://example.com/tags/Java-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java复习-2</title>
    <link href="http://example.com/2021/10/11/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-2/"/>
    <id>http://example.com/2021/10/11/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-2/</id>
    <published>2021-10-11T03:57:36.000Z</published>
    <updated>2023-09-21T04:21:27.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-对象创建流程分析"><a href="#1-对象创建流程分析" class="headerlink" title="1.对象创建流程分析"></a>1.对象创建流程分析</h3><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><ul><li><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><ul><li><strong>根据JVM的内存存储可知 空间可以分为 栈（存放对象名）、堆（存放整形数据 以及 其他类型的 地址）、常量区（存放常量数据 如 String类型之类的数据）、方法区（加载.clss文件 加载类）</strong></li><li><strong>1. 先在 方法区中 加载 Person类</strong></li><li><strong>2. 在 堆 中 进行给person类的属性进行 默认 赋值  age&#x3D;0，name&#x3D;null</strong></li><li><strong>3. 在堆中 进行 初始化 赋值 age&#x3D;90 name依然&#x3D;null</strong></li><li><strong>4. 开始 进行构造器的赋值 name&#x3D;小倩 age&#x3D;20</strong></li><li><strong>5.在 栈中 创建 p对象引用（对象名） 根据地址 找到 堆中的 对象</strong></li></ul></li></ul><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><ul><li><h4 id="含义：当某些属性或者方法-可以重复利用的时候-可以通过继承的方式来共享这些属性以及方法。被继承的-类-叫父类（基类），继承-父类的类-叫做子类（派生类）。"><a href="#含义：当某些属性或者方法-可以重复利用的时候-可以通过继承的方式来共享这些属性以及方法。被继承的-类-叫父类（基类），继承-父类的类-叫做子类（派生类）。" class="headerlink" title="含义：当某些属性或者方法 可以重复利用的时候 可以通过继承的方式来共享这些属性以及方法。被继承的 类 叫父类（基类），继承 父类的类 叫做子类（派生类）。"></a>含义：当某些属性或者方法 可以重复利用的时候 可以通过继承的方式来共享这些属性以及方法。被继承的 类 叫父类（基类），继承 父类的类 叫做子类（派生类）。</h4></li><li><h4 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h4><ul><li><h5 id="1-子类必须调用父类的构造器，完成父类的初始化。当运行子类的构造器时，会先运行父类的构造器，才运行子类的构造器。"><a href="#1-子类必须调用父类的构造器，完成父类的初始化。当运行子类的构造器时，会先运行父类的构造器，才运行子类的构造器。" class="headerlink" title="1.子类必须调用父类的构造器，完成父类的初始化。当运行子类的构造器时，会先运行父类的构造器，才运行子类的构造器。"></a>1.子类必须调用父类的构造器，完成父类的初始化。当运行子类的构造器时，会先运行父类的构造器，才运行子类的构造器。</h5></li><li><h5 id="2-在（1）中，若-父类没有无参构造器，则必须用-super（）来指定使用父类中的哪个构造器来完成-对父类的初始化操作"><a href="#2-在（1）中，若-父类没有无参构造器，则必须用-super（）来指定使用父类中的哪个构造器来完成-对父类的初始化操作" class="headerlink" title="2. 在（1）中，若 父类没有无参构造器，则必须用 super（）来指定使用父类中的哪个构造器来完成 对父类的初始化操作"></a>2. 在（1）中，若 父类没有无参构造器，则必须用 super（）来指定使用父类中的哪个构造器来完成 对父类的初始化操作</h5></li><li><h5 id="3-super-在使用的时候-必须放在-构造器-的第一行"><a href="#3-super-在使用的时候-必须放在-构造器-的第一行" class="headerlink" title="3. super 在使用的时候 必须放在 构造器 的第一行"></a>3. super 在使用的时候 必须放在 构造器 的第一行</h5></li><li><h5 id="4-java所有类-都是-Object的子类"><a href="#4-java所有类-都是-Object的子类" class="headerlink" title="4.java所有类 都是 Object的子类"></a>4.java所有类 都是 Object的子类</h5></li><li><h5 id="5-父类构造器的调用-不限于-直接父类！将一直往上追溯-直到-Object类"><a href="#5-父类构造器的调用-不限于-直接父类！将一直往上追溯-直到-Object类" class="headerlink" title="5.父类构造器的调用 不限于 直接父类！将一直往上追溯 直到 Object类"></a>5.父类构造器的调用 不限于 直接父类！将一直往上追溯 直到 Object类</h5></li></ul></li><li><h4 id="继承的本质"><a href="#继承的本质" class="headerlink" title="继承的本质"></a>继承的本质</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%88%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96%EF%BC%89.png"></p><ul><li><h5 id="1-先在-方法区中-理清楚-类与类之间的继承关系-形成层次关系-本例是-Son-Father-GrandPa-Object"><a href="#1-先在-方法区中-理清楚-类与类之间的继承关系-形成层次关系-本例是-Son-Father-GrandPa-Object" class="headerlink" title="1.先在 方法区中 理清楚 类与类之间的继承关系 形成层次关系 本例是 Son-&gt;Father-&gt;GrandPa-&gt;Object"></a>1.先在 方法区中 理清楚 类与类之间的继承关系 形成层次关系 本例是 Son-&gt;Father-&gt;GrandPa-&gt;Object</h5></li><li><h5 id="2-因此-开始在-堆中-对属性进行初始化-。-理所当然-先在GrandPa类-堆属性进行初始化-依次类推"><a href="#2-因此-开始在-堆中-对属性进行初始化-。-理所当然-先在GrandPa类-堆属性进行初始化-依次类推" class="headerlink" title="2.因此 开始在 堆中 对属性进行初始化 。 理所当然 先在GrandPa类 堆属性进行初始化 依次类推"></a>2.因此 开始在 堆中 对属性进行初始化 。 理所当然 先在GrandPa类 堆属性进行初始化 依次类推</h5></li><li><h5 id="3-最后在栈中-生成对象引用-来识别-堆中的-son对象。"><a href="#3-最后在栈中-生成对象引用-来识别-堆中的-son对象。" class="headerlink" title="3.最后在栈中 生成对象引用 来识别 堆中的 son对象。"></a>3.最后在栈中 生成对象引用 来识别 堆中的 son对象。</h5></li></ul></li></ul><h3 id="3-重写-重载"><a href="#3-重写-重载" class="headerlink" title="3.重写|重载"></a>3.重写|重载</h3><h4 id="1-含义：当子类-继承了-父类之后，子类存在一个方法与父类中的方法一样（既-方法名、参数、返回类型）则-会覆盖掉父类的该方法"><a href="#1-含义：当子类-继承了-父类之后，子类存在一个方法与父类中的方法一样（既-方法名、参数、返回类型）则-会覆盖掉父类的该方法" class="headerlink" title="1.含义：当子类 继承了 父类之后，子类存在一个方法与父类中的方法一样（既 方法名、参数、返回类型）则 会覆盖掉父类的该方法"></a>1.含义：当子类 继承了 父类之后，子类存在一个方法与父类中的方法一样（既 方法名、参数、返回类型）则 会覆盖掉父类的该方法</h4><h4 id="2-细节："><a href="#2-细节：" class="headerlink" title="2.细节："></a>2.细节：</h4><ul><li><h5 id="子类的方法的-参数，方法名称，必须要和父亲方法的参数、方法名完全一样。"><a href="#子类的方法的-参数，方法名称，必须要和父亲方法的参数、方法名完全一样。" class="headerlink" title="子类的方法的 参数，方法名称，必须要和父亲方法的参数、方法名完全一样。"></a>子类的方法的 参数，方法名称，必须要和父亲方法的参数、方法名完全一样。</h5></li><li><h5 id="子类的-返回类型-必须要与父类的返回类型一致，或者是-父亲返回类型的子类。比如，父类的返回类型是Object-子类的返回类型是String"><a href="#子类的-返回类型-必须要与父类的返回类型一致，或者是-父亲返回类型的子类。比如，父类的返回类型是Object-子类的返回类型是String" class="headerlink" title="子类的 返回类型 必须要与父类的返回类型一致，或者是 父亲返回类型的子类。比如，父类的返回类型是Object 子类的返回类型是String"></a>子类的 返回类型 必须要与父类的返回类型一致，或者是 父亲返回类型的子类。比如，父类的返回类型是Object 子类的返回类型是String</h5></li><li><h5 id="子类方法不能缩小父类方法的访问权限。"><a href="#子类方法不能缩小父类方法的访问权限。" class="headerlink" title="子类方法不能缩小父类方法的访问权限。"></a>子类方法不能缩小父类方法的访问权限。</h5></li></ul><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.多态</h3><ul><li><h4 id="1-含义："><a href="#1-含义：" class="headerlink" title="1.含义："></a>1.含义：</h4><ul><li><h5 id="方法多态：方法的-重写-与-重载-体现了-方法的多态性"><a href="#方法多态：方法的-重写-与-重载-体现了-方法的多态性" class="headerlink" title="方法多态：方法的 重写 与 重载 体现了 方法的多态性"></a>方法多态：方法的 重写 与 重载 体现了 方法的多态性</h5><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%BD%93%E7%8E%B0%E5%A4%9A%E6%80%81.png"></p><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%BD%93%E7%8E%B0%E5%A4%9A%E6%80%81.png"></p></li><li><h5 id="对象多态：（假设-A-是-B-的子类）"><a href="#对象多态：（假设-A-是-B-的子类）" class="headerlink" title="对象多态：（假设 A 是 B 的子类）"></a>对象多态：（假设 A 是 B 的子类）</h5><ul><li><h5 id="一个对象的-编译类型-和-运行类型-可以不一致。-如-B-b-new-A-编译类型是-B-而-运行类型是-A"><a href="#一个对象的-编译类型-和-运行类型-可以不一致。-如-B-b-new-A-编译类型是-B-而-运行类型是-A" class="headerlink" title="一个对象的 编译类型 和 运行类型 可以不一致。 如 B b &#x3D;new A(); 编译类型是 B 而 运行类型是 A"></a>一个对象的 编译类型 和 运行类型 可以不一致。 如 B b &#x3D;new A(); 编译类型是 B 而 运行类型是 A</h5></li><li><h5 id="编译类型-在-定义对象的时，就确定了，不能改变。"><a href="#编译类型-在-定义对象的时，就确定了，不能改变。" class="headerlink" title="编译类型 在 定义对象的时，就确定了，不能改变。"></a>编译类型 在 定义对象的时，就确定了，不能改变。</h5></li><li><h5 id="运行类型是可以变化的。-即-b-new-A-也可以-b-new-B"><a href="#运行类型是可以变化的。-即-b-new-A-也可以-b-new-B" class="headerlink" title="运行类型是可以变化的。 即 b&#x3D;new A(); 也可以 b&#x3D;new B();"></a>运行类型是可以变化的。 即 b&#x3D;new A(); 也可以 b&#x3D;new B();</h5></li></ul></li></ul></li><li><h4 id="2-多态的形式"><a href="#2-多态的形式" class="headerlink" title="2.多态的形式"></a>2.多态的形式</h4><ul><li><h5 id="向上转型：即-父类是-编译类型-子类是运行类型-B-b-new-A-；"><a href="#向上转型：即-父类是-编译类型-子类是运行类型-B-b-new-A-；" class="headerlink" title="向上转型：即 父类是 编译类型 子类是运行类型  B b&#x3D;new A()；"></a>向上转型：即 父类是 编译类型 子类是运行类型  B b&#x3D;new A()；</h5><ul><li><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul><li><h5 id="可以调用父类的所有成员（需要遵守访问权限-如-public、private）"><a href="#可以调用父类的所有成员（需要遵守访问权限-如-public、private）" class="headerlink" title="可以调用父类的所有成员（需要遵守访问权限 如 public、private）"></a>可以调用父类的所有成员（需要遵守访问权限 如 public、private）</h5></li><li><h5 id="不能调用子类的特有成员（即-子类特有的方法或者属性-父类没有）"><a href="#不能调用子类的特有成员（即-子类特有的方法或者属性-父类没有）" class="headerlink" title="不能调用子类的特有成员（即 子类特有的方法或者属性 父类没有）"></a>不能调用子类的特有成员（即 子类特有的方法或者属性 父类没有）</h5></li><li><h5 id="最终运行效果-看子类的具体实现（即-父类和子类都有相同的方法时，需要先看子类的方法）"><a href="#最终运行效果-看子类的具体实现（即-父类和子类都有相同的方法时，需要先看子类的方法）" class="headerlink" title="最终运行效果 看子类的具体实现（即 父类和子类都有相同的方法时，需要先看子类的方法）"></a>最终运行效果 看子类的具体实现（即 父类和子类都有相同的方法时，需要先看子类的方法）</h5></li></ul></li></ul></li><li><h5 id="向下转型：子类类型-引用名-（子类类型）-父类引用-A-a-A-b"><a href="#向下转型：子类类型-引用名-（子类类型）-父类引用-A-a-A-b" class="headerlink" title="向下转型：子类类型 引用名&#x3D;（子类类型） 父类引用 A a&#x3D;(A) b;"></a>向下转型：子类类型 引用名&#x3D;（子类类型） 父类引用 A a&#x3D;(A) b;</h5><ul><li><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul><li><h5 id="只能强转父类的引用，不能强转父类的对象。"><a href="#只能强转父类的引用，不能强转父类的对象。" class="headerlink" title="只能强转父类的引用，不能强转父类的对象。"></a>只能强转父类的引用，不能强转父类的对象。</h5></li><li><h5 id="要求父类的引用-必须指向的是当前目标类型的对象-即-要进行向下转型-则该-父类的父类的引用必须先进行-向上转型。"><a href="#要求父类的引用-必须指向的是当前目标类型的对象-即-要进行向下转型-则该-父类的父类的引用必须先进行-向上转型。" class="headerlink" title="要求父类的引用 必须指向的是当前目标类型的对象 即 要进行向下转型 则该 父类的父类的引用必须先进行 向上转型。"></a>要求父类的引用 必须指向的是当前目标类型的对象 即 要进行向下转型 则该 父类的父类的引用必须先进行 向上转型。</h5></li><li><h5 id="可以调用子类类型的所有成员。"><a href="#可以调用子类类型的所有成员。" class="headerlink" title="可以调用子类类型的所有成员。"></a>可以调用子类类型的所有成员。</h5></li><li><h5 id="最终运行效果-看子类的具体实现（先从子类开始找同名方法"><a href="#最终运行效果-看子类的具体实现（先从子类开始找同名方法" class="headerlink" title="最终运行效果 看子类的具体实现（先从子类开始找同名方法)"></a>最终运行效果 看子类的具体实现（先从子类开始找同名方法)</h5></li></ul></li></ul></li></ul></li><li><h4 id="3-属性的重写"><a href="#3-属性的重写" class="headerlink" title="3.属性的重写"></a>3.属性的重写</h4><ul><li><h5 id="属性没有重写的说法，属性的值主要看-编译类型。"><a href="#属性没有重写的说法，属性的值主要看-编译类型。" class="headerlink" title="属性没有重写的说法，属性的值主要看 编译类型。"></a>属性没有重写的说法，属性的值主要看 编译类型。</h5></li><li><h5 id="instanceOf-可以用来判断是否为XX类型-或是-XX类型的子类型。"><a href="#instanceOf-可以用来判断是否为XX类型-或是-XX类型的子类型。" class="headerlink" title="instanceOf 可以用来判断是否为XX类型 或是 XX类型的子类型。"></a>instanceOf 可以用来判断是否为XX类型 或是 XX类型的子类型。</h5></li><li><h5 id="方法的调用看-运行类型-。"><a href="#方法的调用看-运行类型-。" class="headerlink" title="方法的调用看 运行类型 。"></a>方法的调用看 运行类型 。</h5></li></ul></li><li><h4 id="4-java的动态绑定机制"><a href="#4-java的动态绑定机制" class="headerlink" title="4.java的动态绑定机制"></a>4.java的动态绑定机制</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E4%B8%BE%E4%BE%8B.png"></p><ul><li><h5 id="当调用-对象方法-的时候，该方法会和该对象的-内存地址-运行类型-进行绑定"><a href="#当调用-对象方法-的时候，该方法会和该对象的-内存地址-运行类型-进行绑定" class="headerlink" title="当调用 对象方法 的时候，该方法会和该对象的 内存地址&#x2F;运行类型 进行绑定"></a>当调用 对象方法 的时候，该方法会和该对象的 内存地址&#x2F;运行类型 进行绑定</h5></li><li><h5 id="当调用对象属性的时候，是-没有-动态绑定机制的。-哪里声明，哪里使用。"><a href="#当调用对象属性的时候，是-没有-动态绑定机制的。-哪里声明，哪里使用。" class="headerlink" title="当调用对象属性的时候，是 没有 动态绑定机制的。 哪里声明，哪里使用。"></a>当调用对象属性的时候，是 没有 动态绑定机制的。 哪里声明，哪里使用。</h5></li><li><h5 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line">System.out.println(a.num());  <span class="comment">//输出30</span></span><br><span class="line"><span class="comment">//（此时 B 中 的 sum 方法被注释）当 a 调用 sum方法时，经历的过程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 先去 找 编译类型B 是否存在 sum方法 。 发现没有（被注释掉）</span></span><br><span class="line"><span class="comment">    2. 根据 继承原则 去父类A 中 找 sum 方法 发现找到。 但 执行A中的 sum方法 需要执行 getI（）方法</span></span><br><span class="line"><span class="comment">    3. 此时 根据 java的 动态绑定机制 方法会和执行它的对象进行绑定 既 和 a 进行绑定。  而 a的 运行类型是 B，因此 getI（）方法 </span></span><br><span class="line"><span class="comment">       会 先去B 中寻找 getI（）方法 发现 找到 返回 20 .</span></span><br><span class="line"><span class="comment">    4. 继续执行 A中的 sum方法 20+10 返回 30.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">System.out.println(a.num1()); <span class="comment">//返回 20</span></span><br><span class="line"><span class="comment">//此时的 B中的 sum方法被注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 先去 找 编译类型B 是否存在 sum1方法 。 发现没有（被注释掉）</span></span><br><span class="line"><span class="comment">2. 根据 继承原则 去父类A 中 找 sum1 方法 发现找到</span></span><br><span class="line"><span class="comment">3. 此时的 属性i 没有什么动态绑定之说，直接看当前类 是否有定义属性 i，有则直接调用 没有则 去B找。 发现有 则执行 返回 10+10=20</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-Static类变量-类方法（静态变量）"><a href="#5-Static类变量-类方法（静态变量）" class="headerlink" title="5. Static类变量&#x2F;类方法（静态变量）"></a>5. Static类变量&#x2F;类方法（静态变量）</h3><ul><li><h4 id="介绍：Static-类变量-表示-它是全类公用的一个变量或者方法。所有该类的对象访问它时，都会得到同样的值。类变量-在-类加载时-就已经存在了。"><a href="#介绍：Static-类变量-表示-它是全类公用的一个变量或者方法。所有该类的对象访问它时，都会得到同样的值。类变量-在-类加载时-就已经存在了。" class="headerlink" title="介绍：Static 类变量 表示 它是全类公用的一个变量或者方法。所有该类的对象访问它时，都会得到同样的值。类变量 在 类加载时 就已经存在了。"></a>介绍：Static 类变量 表示 它是全类公用的一个变量或者方法。所有该类的对象访问它时，都会得到同样的值。类变量 在 类加载时 就已经存在了。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStatic</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//此时 a b c单个分别不同的对象 都会 共享同一个属性  num</span></span><br><span class="line">A a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">A b=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">A c=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a.num++;</span><br><span class="line">b.num++;</span><br><span class="line"><span class="comment">//此时 三个值应该是一样的 静态的特性 输出结果 均为 7</span></span><br><span class="line">        <span class="comment">//静态变量的 使用方法 可以是 对象名.num 也可以是类名.num 推荐第二种</span></span><br><span class="line">System.out.println(<span class="string">&quot;a num=&quot;</span>+a.num+<span class="string">&quot; A.num=&quot;</span>+b.num+<span class="string">&quot; c num=&quot;</span>+c.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num=<span class="number">5</span>;  <span class="comment">//定义 静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.print(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="静态变量运用场景："><a href="#静态变量运用场景：" class="headerlink" title="静态变量运用场景："></a>静态变量运用场景：</h4><ul><li><h5 id="1-当我们对该类-不需要太多的属性修改。直接实现对该类的代码进行-代码复用的时候，则可以使用静态变量。-例如-许许多多的-工具类。"><a href="#1-当我们对该类-不需要太多的属性修改。直接实现对该类的代码进行-代码复用的时候，则可以使用静态变量。-例如-许许多多的-工具类。" class="headerlink" title="1. 当我们对该类 不需要太多的属性修改。直接实现对该类的代码进行 代码复用的时候，则可以使用静态变量。 例如 许许多多的 工具类。"></a>1. 当我们对该类 不需要太多的属性修改。直接实现对该类的代码进行 代码复用的时候，则可以使用静态变量。 例如 许许多多的 工具类。</h5></li><li><h5 id="2-当我们-需要-该属性-，一修改-所有对象的该属性-都产生变化的时候-则可以运用。-例如-Student类中，统计-叫多少学费的-fee变量。"><a href="#2-当我们-需要-该属性-，一修改-所有对象的该属性-都产生变化的时候-则可以运用。-例如-Student类中，统计-叫多少学费的-fee变量。" class="headerlink" title="2. 当我们 需要 该属性 ，一修改 所有对象的该属性 都产生变化的时候 则可以运用。 例如 Student类中，统计 叫多少学费的 fee变量。"></a>2. 当我们 需要 该属性 ，一修改 所有对象的该属性 都产生变化的时候 则可以运用。 例如 Student类中，统计 叫多少学费的 fee变量。</h5></li></ul></li><li><h4 id="类方法使用注意事项："><a href="#类方法使用注意事项：" class="headerlink" title="类方法使用注意事项："></a>类方法使用注意事项：</h4><ul><li><h5 id="1-类方法和普通方法-都是随着-类的加载而加载。"><a href="#1-类方法和普通方法-都是随着-类的加载而加载。" class="headerlink" title="1. 类方法和普通方法 都是随着 类的加载而加载。"></a>1. 类方法和普通方法 都是随着 类的加载而加载。</h5></li><li><h5 id="2-类方法结构体中-不能使用this"><a href="#2-类方法结构体中-不能使用this" class="headerlink" title="2. 类方法结构体中 不能使用this"></a>2. 类方法结构体中 不能使用this</h5></li><li><h5 id="3-类方法中，只能使用类变量，不能使用其他的变量。"><a href="#3-类方法中，只能使用类变量，不能使用其他的变量。" class="headerlink" title="3. 类方法中，只能使用类变量，不能使用其他的变量。"></a>3. 类方法中，只能使用类变量，不能使用其他的变量。</h5></li></ul></li></ul><h3 id="6-main方法-public-static-void-main-String-args"><a href="#6-main方法-public-static-void-main-String-args" class="headerlink" title="6.main方法( public static void main(String[] args) )"></a>6.main方法( public static void main(String[] args) )</h3><ul><li><h5 id="main方法-因为会被-java虚拟机调用-因此访问权限必须是-public"><a href="#main方法-因为会被-java虚拟机调用-因此访问权限必须是-public" class="headerlink" title="main方法 因为会被 java虚拟机调用 因此访问权限必须是 public"></a>main方法 因为会被 java虚拟机调用 因此访问权限必须是 public</h5></li><li><h5 id="调用main方法-不需要创建对象-所以-用-static来修饰"><a href="#调用main方法-不需要创建对象-所以-用-static来修饰" class="headerlink" title="调用main方法 不需要创建对象 所以 用 static来修饰"></a>调用main方法 不需要创建对象 所以 用 static来修饰</h5></li><li><h5 id="main-方法的参数-args-用于存储-运行该命令时传递给所运行的类的参数。"><a href="#main-方法的参数-args-用于存储-运行该命令时传递给所运行的类的参数。" class="headerlink" title="main 方法的参数 args 用于存储 运行该命令时传递给所运行的类的参数。"></a>main 方法的参数 args 用于存储 运行该命令时传递给所运行的类的参数。</h5></li><li><h5 id="特别提示："><a href="#特别提示：" class="headerlink" title="特别提示："></a>特别提示：</h5><ul><li><h5 id="在-main-方法中，可以使用所在类的-静态变量-和-静态方法（即-遵守静态规则）"><a href="#在-main-方法中，可以使用所在类的-静态变量-和-静态方法（即-遵守静态规则）" class="headerlink" title="在 main() 方法中，可以使用所在类的 静态变量 和 静态方法（即 遵守静态规则）"></a>在 main() 方法中，可以使用所在类的 静态变量 和 静态方法（即 遵守静态规则）</h5></li><li><h5 id="若想在-main-方法中使用非静态的东西，则需要先创建该类的-对象-再使用对象来引用非静态的东西"><a href="#若想在-main-方法中使用非静态的东西，则需要先创建该类的-对象-再使用对象来引用非静态的东西" class="headerlink" title="若想在 main() 方法中使用非静态的东西，则需要先创建该类的 对象 再使用对象来引用非静态的东西"></a>若想在 main() 方法中使用非静态的东西，则需要先创建该类的 对象 再使用对象来引用非静态的东西</h5></li></ul></li></ul><h3 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7.代码块"></a>7.代码块</h3><ul><li><h4 id="1-含义：类似于方法，将逻辑语句封装在方法体中，通过-来包围起来-通常用于解决代码冗余。"><a href="#1-含义：类似于方法，将逻辑语句封装在方法体中，通过-来包围起来-通常用于解决代码冗余。" class="headerlink" title="1. 含义：类似于方法，将逻辑语句封装在方法体中，通过{}来包围起来. 通常用于解决代码冗余。"></a>1. 含义：类似于方法，将逻辑语句封装在方法体中，通过{}来包围起来. 通常用于解决代码冗余。</h4></li><li><h4 id="2-基本语法：【修饰符】-修饰符-可以加-可以不加-，要加也只能加-static-。-其中-后面的-号-可以不要。"><a href="#2-基本语法：【修饰符】-修饰符-可以加-可以不加-，要加也只能加-static-。-其中-后面的-号-可以不要。" class="headerlink" title="2.基本语法：【修饰符】{};  修饰符 可以加 可以不加 ，要加也只能加 static 。 其中 后面的 ;号 可以不要。"></a>2.基本语法：【修饰符】{};  修饰符 可以加 可以不加 ，要加也只能加 static 。 其中 后面的 ;号 可以不要。</h4></li><li><h4 id="3-代码块使用细节："><a href="#3-代码块使用细节：" class="headerlink" title="3.代码块使用细节："></a>3.代码块使用细节：</h4><ul><li><h5 id="static代码块，作用是对类进行初始化，它是随着-类的加载-而执行的，并且只会执行一次。-普通代码块，则是每创建一个对象就会执行一次。"><a href="#static代码块，作用是对类进行初始化，它是随着-类的加载-而执行的，并且只会执行一次。-普通代码块，则是每创建一个对象就会执行一次。" class="headerlink" title="static代码块，作用是对类进行初始化，它是随着 类的加载 而执行的，并且只会执行一次。 普通代码块，则是每创建一个对象就会执行一次。"></a>static代码块，作用是对类进行初始化，它是随着 类的加载 而执行的，并且只会执行一次。 普通代码块，则是每创建一个对象就会执行一次。</h5></li><li><h5 id="类是什么时候被加载"><a href="#类是什么时候被加载" class="headerlink" title="类是什么时候被加载"></a>类是什么时候被加载</h5><ul><li><h5 id="1-创建对象实例时-（如-new）"><a href="#1-创建对象实例时-（如-new）" class="headerlink" title="1. 创建对象实例时 （如 new）"></a>1. 创建对象实例时 （如 new）</h5></li><li><h5 id="2-创建子类对象实例时，父类也会被加载。并且时-父类先加载完后，在加载子类。"><a href="#2-创建子类对象实例时，父类也会被加载。并且时-父类先加载完后，在加载子类。" class="headerlink" title="2. 创建子类对象实例时，父类也会被加载。并且时 父类先加载完后，在加载子类。"></a>2. 创建子类对象实例时，父类也会被加载。并且时 父类先加载完后，在加载子类。</h5></li><li><h5 id="3-在使用-类的静态成员的时候（如-静态属性，静态方法）"><a href="#3-在使用-类的静态成员的时候（如-静态属性，静态方法）" class="headerlink" title="3. 在使用 类的静态成员的时候（如 静态属性，静态方法）"></a>3. 在使用 类的静态成员的时候（如 静态属性，静态方法）</h5></li></ul></li><li><h5 id="使用类的静态成员的时候，普通代码块-并不会-执行。只有在创建对象实例的时候-普通代码块才会执行"><a href="#使用类的静态成员的时候，普通代码块-并不会-执行。只有在创建对象实例的时候-普通代码块才会执行" class="headerlink" title="使用类的静态成员的时候，普通代码块 并不会 执行。只有在创建对象实例的时候 普通代码块才会执行"></a>使用类的静态成员的时候，普通代码块 并不会 执行。只有在创建对象实例的时候 普通代码块才会执行</h5></li><li><h5 id="创建一个对象时，在一个类-调用顺序："><a href="#创建一个对象时，在一个类-调用顺序：" class="headerlink" title="创建一个对象时，在一个类 调用顺序："></a>创建一个对象时，在一个类 调用顺序：</h5><ul><li><h5 id="1-先执行-静态的代码块-和-静态属性初始化（先执行静态资源-优先级是一样的）"><a href="#1-先执行-静态的代码块-和-静态属性初始化（先执行静态资源-优先级是一样的）" class="headerlink" title="1.先执行 静态的代码块 和 静态属性初始化（先执行静态资源 优先级是一样的）"></a>1.先执行 静态的代码块 和 静态属性初始化（先执行静态资源 优先级是一样的）</h5></li><li><h5 id="2-执行-普通代码块-和-普通属性-（执行-普通资源）"><a href="#2-执行-普通代码块-和-普通属性-（执行-普通资源）" class="headerlink" title="2. 执行 普通代码块 和 普通属性 （执行 普通资源）"></a>2. 执行 普通代码块 和 普通属性 （执行 普通资源）</h5></li><li><h5 id="3-执行-构造器"><a href="#3-执行-构造器" class="headerlink" title="3. 执行 构造器"></a>3. 执行 构造器</h5></li></ul></li><li><h5 id="构造方法-的-最前面-其实隐含了-super（）和-调用普通代码块。因此，每次执行构造器方法的时候，都会先去执行父类-以及该类中的-普通代码块"><a href="#构造方法-的-最前面-其实隐含了-super（）和-调用普通代码块。因此，每次执行构造器方法的时候，都会先去执行父类-以及该类中的-普通代码块" class="headerlink" title="构造方法 的 最前面 其实隐含了  super（）和 调用普通代码块。因此，每次执行构造器方法的时候，都会先去执行父类 以及该类中的 普通代码块"></a>构造方法 的 最前面 其实隐含了  super（）和 调用普通代码块。因此，每次执行构造器方法的时候，都会先去执行父类 以及该类中的 普通代码块</h5></li><li><h5 id="静态代码块-依然要遵守-静态的规则，因此-静态代码块中-只能使用-静态属性-和-静态方法。而-普通代码块-则可以调用任何的属性和方法。"><a href="#静态代码块-依然要遵守-静态的规则，因此-静态代码块中-只能使用-静态属性-和-静态方法。而-普通代码块-则可以调用任何的属性和方法。" class="headerlink" title="静态代码块 依然要遵守 静态的规则，因此 静态代码块中 只能使用 静态属性 和 静态方法。而 普通代码块 则可以调用任何的属性和方法。"></a>静态代码块 依然要遵守 静态的规则，因此 静态代码块中 只能使用 静态属性 和 静态方法。而 普通代码块 则可以调用任何的属性和方法。</h5></li><li><h5 id="子类与父类（继承关系）-调用顺序："><a href="#子类与父类（继承关系）-调用顺序：" class="headerlink" title="子类与父类（继承关系） 调用顺序："></a>子类与父类（继承关系） 调用顺序：</h5><ul><li><h5 id="1-父类的-静态资源"><a href="#1-父类的-静态资源" class="headerlink" title="1. 父类的 静态资源"></a>1. 父类的 静态资源</h5></li><li><h5 id="2-子类的-静态资源"><a href="#2-子类的-静态资源" class="headerlink" title="2. 子类的 静态资源"></a>2. 子类的 静态资源</h5></li><li><h5 id="3-父类的-普通资源"><a href="#3-父类的-普通资源" class="headerlink" title="3. 父类的 普通资源"></a>3. 父类的 普通资源</h5></li><li><h5 id="4-父类的-构造器"><a href="#4-父类的-构造器" class="headerlink" title="4. 父类的 构造器"></a>4. 父类的 构造器</h5></li><li><h5 id="5-子类的普通资源"><a href="#5-子类的普通资源" class="headerlink" title="5. 子类的普通资源"></a>5. 子类的普通资源</h5></li><li><h5 id="6-子类的构造器"><a href="#6-子类的构造器" class="headerlink" title="6. 子类的构造器"></a>6. 子类的构造器</h5></li></ul></li></ul></li></ul><h3 id="8-单例模式-设计模式中的一种"><a href="#8-单例模式-设计模式中的一种" class="headerlink" title="8.单例模式 (设计模式中的一种)"></a>8.单例模式 (设计模式中的一种)</h3><ul><li><h4 id="1-含义：采取-一定的方法-保证-整个程序中-对某一个类-只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法。"><a href="#1-含义：采取-一定的方法-保证-整个程序中-对某一个类-只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法。" class="headerlink" title="1. 含义：采取 一定的方法 保证 整个程序中 对某一个类 只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法。"></a>1. 含义：采取 一定的方法 保证 整个程序中 对某一个类 只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法。</h4></li><li><h4 id="2-分为-饿汉式-与-懒汉式"><a href="#2-分为-饿汉式-与-懒汉式" class="headerlink" title="2. 分为 饿汉式 与 懒汉式"></a>2. 分为 饿汉式 与 懒汉式</h4><ul><li><h5 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//在本类中 new 一个对象</span></span><br><span class="line">    <span class="keyword">static</span> Cat cat=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小猫&quot;</span>);</span><br><span class="line">    <span class="comment">//构造器 是 私有类型 private （为了防止 用户new对象）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个 让用户可以 获取对象实例的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Friend</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 在本类 中 创建对象 但是没有 new出对象实例</span></span><br><span class="line">    <span class="keyword">static</span> Friend friend;</span><br><span class="line">    <span class="comment">//构造器 私有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让用户 获取对象实例的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Friend <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//避免对象 被 多次创建</span></span><br><span class="line">        <span class="keyword">if</span>(friend==<span class="literal">null</span>)&#123;</span><br><span class="line">            friend=<span class="keyword">new</span> <span class="title class_">Friend</span>(<span class="string">&quot;朋友&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> friend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Friend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="3-两种方式的区别："><a href="#3-两种方式的区别：" class="headerlink" title="3. 两种方式的区别："></a>3. 两种方式的区别：</h4><ul><li><h5 id="饿汉式-的对象实例-是在-类加载的时候就创建了-若是程序没用该类，则会造成资源浪费。-而-懒汉氏则不会-但是会造成多线程问题。既-当多个线程访问-获取实体类方法时-类都为空-则可能会造成-创建三个类实例的效果，就不符合单例模式了-。"><a href="#饿汉式-的对象实例-是在-类加载的时候就创建了-若是程序没用该类，则会造成资源浪费。-而-懒汉氏则不会-但是会造成多线程问题。既-当多个线程访问-获取实体类方法时-类都为空-则可能会造成-创建三个类实例的效果，就不符合单例模式了-。" class="headerlink" title="饿汉式 的对象实例 是在 类加载的时候就创建了 若是程序没用该类，则会造成资源浪费。 而 懒汉氏则不会,但是会造成多线程问题。既 当多个线程访问 获取实体类方法时 类都为空 则可能会造成 创建三个类实例的效果，就不符合单例模式了 。"></a>饿汉式 的对象实例 是在 类加载的时候就创建了 若是程序没用该类，则会造成资源浪费。 而 懒汉氏则不会,但是会造成多线程问题。既 当多个线程访问 获取实体类方法时 类都为空 则可能会造成 创建三个类实例的效果，就不符合单例模式了 。</h5></li></ul></li></ul><h3 id="9-final关键字"><a href="#9-final关键字" class="headerlink" title="9.final关键字"></a>9.final关键字</h3><ul><li><h4 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h4><ul><li><h5 id="1-当-该类-不想要被继承时-可以使用-final-class-AA"><a href="#1-当-该类-不想要被继承时-可以使用-final-class-AA" class="headerlink" title="1.当 该类 不想要被继承时 可以使用  final class AA{}"></a>1.当 该类 不想要被继承时 可以使用  final class AA{}</h5></li><li><h5 id="2-当-父类-中-的某个方法-不想要被-子类去重写或者重载的时候-public-final-void-AA"><a href="#2-当-父类-中-的某个方法-不想要被-子类去重写或者重载的时候-public-final-void-AA" class="headerlink" title="2.当 父类 中 的某个方法 不想要被 子类去重写或者重载的时候  public final void AA(){}"></a>2.当 父类 中 的某个方法 不想要被 子类去重写或者重载的时候  public final void AA(){}</h5></li><li><h5 id="3-当-类中-的某一个变量-不想要被更改的时候（既-常量）-private-static-final-AA-3-14"><a href="#3-当-类中-的某一个变量-不想要被更改的时候（既-常量）-private-static-final-AA-3-14" class="headerlink" title="3.当 类中 的某一个变量 不想要被更改的时候（既 常量） private static final AA&#x3D;3.14"></a>3.当 类中 的某一个变量 不想要被更改的时候（既 常量） private static final AA&#x3D;3.14</h5></li><li><h5 id="4-当-不希望局部的变量被修改时"><a href="#4-当-不希望局部的变量被修改时" class="headerlink" title="4.当 不希望局部的变量被修改时"></a>4.当 不希望局部的变量被修改时</h5></li></ul></li><li><h4 id="使用细节："><a href="#使用细节：" class="headerlink" title="使用细节："></a>使用细节：</h4><ul><li><h5 id="1-final修饰属性的时候-必须要对该属性-进行-定义。赋值的情况有三种："><a href="#1-final修饰属性的时候-必须要对该属性-进行-定义。赋值的情况有三种：" class="headerlink" title="1. final修饰属性的时候 必须要对该属性 进行 定义。赋值的情况有三种："></a>1. final修饰属性的时候 必须要对该属性 进行 定义。赋值的情况有三种：</h5><ul><li><h5 id="直接-初始化-private-static-final-AA-3-14"><a href="#直接-初始化-private-static-final-AA-3-14" class="headerlink" title="直接 初始化 private static final AA&#x3D;3.14;"></a>直接 初始化 private static final AA&#x3D;3.14;</h5></li><li><h5 id="在-代码块中-初始化"><a href="#在-代码块中-初始化" class="headerlink" title="在 代码块中 初始化"></a>在 代码块中 初始化</h5></li><li><h5 id="在-构造器中-初始化"><a href="#在-构造器中-初始化" class="headerlink" title="在 构造器中 初始化"></a>在 构造器中 初始化</h5></li></ul></li><li><h5 id="2-如果-final-修饰的属性时-静态的（static）-既-初始化-只能在-静态-代码块-或者-直接-定义初始化"><a href="#2-如果-final-修饰的属性时-静态的（static）-既-初始化-只能在-静态-代码块-或者-直接-定义初始化" class="headerlink" title="2. 如果 final 修饰的属性时 静态的（static） 既 初始化 只能在 (静态)代码块 或者 直接 定义初始化"></a>2. 如果 final 修饰的属性时 静态的（static） 既 初始化 只能在 (静态)代码块 或者 直接 定义初始化</h5></li><li><h5 id="3-一般来说，如果该类是-final类-则该类-里面的-属性-和-方法-都无需再-修饰为final"><a href="#3-一般来说，如果该类是-final类-则该类-里面的-属性-和-方法-都无需再-修饰为final" class="headerlink" title="3. 一般来说，如果该类是 final类 则该类 里面的 属性 和 方法 都无需再 修饰为final"></a>3. 一般来说，如果该类是 final类 则该类 里面的 属性 和 方法 都无需再 修饰为final</h5></li><li><h5 id="4-final-不能修饰-构造器"><a href="#4-final-不能修饰-构造器" class="headerlink" title="4. final 不能修饰 构造器"></a>4. final 不能修饰 构造器</h5></li><li><h5 id="5-final-通常-会与-static-搭配使用-效率更高"><a href="#5-final-通常-会与-static-搭配使用-效率更高" class="headerlink" title="5. final 通常 会与  static 搭配使用 效率更高"></a>5. final 通常 会与  static 搭配使用 效率更高</h5></li></ul></li></ul><h3 id="10-抽象类-abstract"><a href="#10-抽象类-abstract" class="headerlink" title="10.抽象类 (abstract)"></a>10.抽象类 (abstract)</h3><ul><li><h4 id="1-含义：当父类中-存在一些-不确定的方法实现时（既每个子类都会去重写该方法），可以将父类-设置成-抽象类。"><a href="#1-含义：当父类中-存在一些-不确定的方法实现时（既每个子类都会去重写该方法），可以将父类-设置成-抽象类。" class="headerlink" title="1.含义：当父类中 存在一些 不确定的方法实现时（既每个子类都会去重写该方法），可以将父类 设置成 抽象类。"></a>1.含义：当父类中 存在一些 不确定的方法实现时（既每个子类都会去重写该方法），可以将父类 设置成 抽象类。</h4></li><li><h4 id="2-使用细节"><a href="#2-使用细节" class="headerlink" title="2.使用细节"></a>2.使用细节</h4><ul><li><h5 id="1-抽象类-不能被实例化-（既不能new-对象实例）"><a href="#1-抽象类-不能被实例化-（既不能new-对象实例）" class="headerlink" title="1. 抽象类 不能被实例化 （既不能new 对象实例）"></a>1. 抽象类 不能被实例化 （既不能new 对象实例）</h5></li><li><h5 id="2-一旦-某方法定义为-抽象方法-则该类-必须定义为-抽象类"><a href="#2-一旦-某方法定义为-抽象方法-则该类-必须定义为-抽象类" class="headerlink" title="2. 一旦 某方法定义为 抽象方法 则该类 必须定义为 抽象类"></a>2. 一旦 某方法定义为 抽象方法 则该类 必须定义为 抽象类</h5></li><li><h5 id="3-abstract-只能用来修饰-方法-和-类"><a href="#3-abstract-只能用来修饰-方法-和-类" class="headerlink" title="3. abstract 只能用来修饰 方法 和 类"></a>3. abstract 只能用来修饰 方法 和 类</h5></li><li><h5 id="4-如果某类-继承了-抽象类-则必须实现-抽象类-中的-抽象方法-，除非-该类也是一个抽象类"><a href="#4-如果某类-继承了-抽象类-则必须实现-抽象类-中的-抽象方法-，除非-该类也是一个抽象类" class="headerlink" title="4. 如果某类 继承了 抽象类 则必须实现 抽象类 中的  抽象方法 ，除非 该类也是一个抽象类"></a>4. 如果某类 继承了 抽象类 则必须实现 抽象类 中的  抽象方法 ，除非 该类也是一个抽象类</h5></li></ul></li></ul><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-对象创建流程分析&quot;&gt;&lt;a href=&quot;#1-对象创建流程分析&quot; class=&quot;headerlink&quot; title=&quot;1.对象创建流程分析&quot;&gt;&lt;/a&gt;1.对象创建流程分析&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../images/Java%E5%A4%8D%E4%</summary>
      
    
    
    
    
    <category term="-Java -复习" scheme="http://example.com/tags/Java-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb复习01</title>
    <link href="http://example.com/2021/09/21/javaWeb%E5%A4%8D%E4%B9%A0/javaWeb%E5%A4%8D%E4%B9%A001/"/>
    <id>http://example.com/2021/09/21/javaWeb%E5%A4%8D%E4%B9%A0/javaWeb%E5%A4%8D%E4%B9%A001/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Html-和-CSS"><a href="#一、Html-和-CSS" class="headerlink" title="一、Html 和 CSS"></a>一、Html 和 CSS</h1><h3 id="1-B-S-软件的结构"><a href="#1-B-S-软件的结构" class="headerlink" title="1. B&#x2F;S 软件的结构"></a>1. B&#x2F;S 软件的结构</h3><ul><li><h4 id="含义：即-Broswer（浏览器）-与-Server（服务端）-的软件结构"><a href="#含义：即-Broswer（浏览器）-与-Server（服务端）-的软件结构" class="headerlink" title="含义：即 Broswer（浏览器） 与 Server（服务端） 的软件结构"></a>含义：即 Broswer（浏览器） 与 Server（服务端） 的软件结构</h4></li><li><p>其中 javaEE项目 则是 C（client 客户端）&#x2F;S（server 服务端）结构</p></li></ul><h3 id="2-Html-简介"><a href="#2-Html-简介" class="headerlink" title="2. Html 简介"></a>2. Html 简介</h3><ul><li><p><strong>用处：</strong> html 通过 <strong>标签</strong>  来标记要显示的网页的各个部分。 </p></li><li><p><strong>书写规范：</strong> </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  <span class="comment">&lt;!-- 约束声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh_CN&quot;</span>&gt;</span> <span class="comment">&lt;!-- 表示html文件的开始，lang用于设置语言 zh_cn 表示中文 en 英文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  <span class="comment">&lt;!-- 表示头部信息，主要包括 标题，CSS文件，javaScript文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> <span class="comment">&lt;!-- 文件使用的编码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="comment">&lt;!-- 设置标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="comment">&lt;!-- 在body中 编写网页要显示的内容 --&gt;</span></span><br><span class="line">      hello Html</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-标签介绍"><a href="#3-标签介绍" class="headerlink" title="3. 标签介绍"></a>3. 标签介绍</h3><ul><li><p><strong>标签的格式：</strong> &lt;标签名&gt;  封装的数据 &lt;&#x2F;标签名&gt;</p></li><li><p><strong>标签名的 大小写不敏感</strong></p></li><li><p><strong>标签有自己的属性：</strong> 可以设置 <strong>基本的样式</strong> 与 <strong>事件属性（点击事件等）</strong> </p></li><li><p><strong>标签</strong> 分为 <strong>单标签（<code>&lt;/br&gt;</code>） 与 双标签 （<code>&lt;p&gt;&lt;/p&gt;</code>）</strong></p></li><li><h4 id="标签的语法："><a href="#标签的语法：" class="headerlink" title="标签的语法："></a>标签的语法：</h4><ul><li>标签 <strong>不能交叉嵌套</strong> 如 <code>&lt;div&gt;&lt;span&gt; ss &lt;/div&gt;&lt;/span&gt;</code></li><li>标签 <strong>必须正确的关闭</strong> </li><li>标签属性 <strong>必须有值，而且必须加 双引号</strong> </li><li><strong>注释不能嵌套</strong></li></ul></li><li><h4 id="常用标签用法："><a href="#常用标签用法：" class="headerlink" title="常用标签用法："></a>常用标签用法：</h4><ul><li><h5 id="font标签"><a href="#font标签" class="headerlink" title="font标签"></a>font标签</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>font标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      font : 字体标签</span></span><br><span class="line"><span class="comment">             color属性： 修改字体颜色</span></span><br><span class="line"><span class="comment">             face属性： 修改字体样式</span></span><br><span class="line"><span class="comment">             size属性： 修改字体大小</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">face</span>=<span class="string">&quot;宋体&quot;</span> <span class="attr">size</span>=<span class="string">&quot;7&quot;</span>&gt;</span>我是字体标签<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="显示特殊字符"><a href="#显示特殊字符" class="headerlink" title="显示特殊字符"></a>显示特殊字符</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>特殊字符<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当html需要显示 特殊字符时，需要用特定的语法</span></span><br><span class="line"><span class="comment">      &lt; : &amp;lt;</span></span><br><span class="line"><span class="comment">      &gt; : &amp;gt;</span></span><br><span class="line"><span class="comment">      空格符 ： &amp;nbsp;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">      我是<span class="symbol">&amp;lt;</span>br<span class="symbol">&amp;gt;</span>标签<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      这里演示空格符 <span class="symbol">&amp;nbsp;</span> 哈哈 &amp;nbsp</span><br></pre></td></tr></table></figure></li><li><h5 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      h1 -&gt; h6 ： 标题标签</span></span><br><span class="line"><span class="comment">        align: 设置对其方式 默认 左对齐</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>超链接标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      a：超链接标签</span></span><br><span class="line"><span class="comment">        href： 设置要条状的地址（当需要跳转到 servlet中 其中一个方法时，可以这样写）</span></span><br><span class="line"><span class="comment">&lt;a href=&quot;/cookie?action=createCookie&quot;&gt;创建Cookie&lt;/a&gt;</span></span><br><span class="line"><span class="comment">        target: 设置跳转的方式</span></span><br><span class="line"><span class="comment">          _self: 浏览器自身标签页跳转  默认</span></span><br><span class="line"><span class="comment">          _blank: 浏览器 新开一个标签页跳转</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>百度_self<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>百度_blank<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     ul: 无序列表标签</span></span><br><span class="line"><span class="comment">        type属性: 修改列表前的 样式</span></span><br><span class="line"><span class="comment">     li:  列表项</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>嵇康<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h5>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>img标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    img: 图像标签</span></span><br><span class="line"><span class="comment">      src: 图片的路径</span></span><br><span class="line"><span class="comment">          其中 路径分为 绝对路径 与 相对路径</span></span><br><span class="line"><span class="comment">          绝对路径:</span></span><br><span class="line"><span class="comment">              https://ip:port/工程名/资源路径</span></span><br><span class="line"><span class="comment">          相对路径:</span></span><br><span class="line"><span class="comment">              . : 表示当前文件路径</span></span><br><span class="line"><span class="comment">              .. : 表示 上一级的目录</span></span><br><span class="line"><span class="comment">      width: 图片的宽度</span></span><br><span class="line"><span class="comment">      height: 图片的长度</span></span><br><span class="line"><span class="comment">      border: 给图片添加边框</span></span><br><span class="line"><span class="comment">      alt: 当图片加载失败时,显示的内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/1.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">border</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../imgs/2.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片已失效&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/3.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="table表格"><a href="#table表格" class="headerlink" title="table表格"></a>table表格</h5>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>table表格<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    table: 表格标签</span></span><br><span class="line"><span class="comment">      cellpadding属性：设置表格里面的内容 与 边框 的距离</span></span><br><span class="line"><span class="comment">    tr：行标签</span></span><br><span class="line"><span class="comment">    td：表格的 单元格标签</span></span><br><span class="line"><span class="comment">    th：表头标签</span></span><br><span class="line"><span class="comment">    (th、td 共同拥有的)</span></span><br><span class="line"><span class="comment">      colspan属性：设置单元格占据几列</span></span><br><span class="line"><span class="comment">      rowspan属性：设置单元格占据几行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h5 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h5>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>ifarme标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    iframe标签： 可用作显示 一个单独页面的功能</span></span><br><span class="line"><span class="comment">      name属性：用作标记该 iframe标签</span></span><br><span class="line"><span class="comment">      src属性： 设置默认显示网页</span></span><br><span class="line"><span class="comment">    通过该标签配合a标签使用，通过a标签的 target属性 来把跳转的网页显示在 iframe中</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">我是一个单独的完整页面<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;testIframe&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">src</span>=<span class="string">&quot;index.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://mail.qq.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;testIframe&quot;</span>&gt;</span>QQ邮箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.bilibili.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;testIframe&quot;</span>&gt;</span>哔哩哔哩<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.taobao.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;testIframe&quot;</span>&gt;</span>淘宝<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>z</span><br></pre></td></tr></table></figure></li><li><h5 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h5>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>表单标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    form标签：表单标签</span></span><br><span class="line"><span class="comment">      action属性：设置表单提交到哪里</span></span><br><span class="line"><span class="comment">      methods属性： 设置提交的方式 get/post</span></span><br><span class="line"><span class="comment">        get: 会把表单的信息 显示到地址栏</span></span><br><span class="line"><span class="comment">        post：只显示action的值</span></span><br><span class="line"><span class="comment">      表单提交细节：</span></span><br><span class="line"><span class="comment">         1. 需要给 输入框设置 name属性来当作 key</span></span><br><span class="line"><span class="comment">         2. 需要给 输入框设置 value属性 来当作 value</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    input标签：用左各种的输入框</span></span><br><span class="line"><span class="comment">      name属性：给input标识，当表单提交时 作为key</span></span><br><span class="line"><span class="comment">      value属性：可给输入款设置 默认值</span></span><br><span class="line"><span class="comment">      checked属性： 默认选中该选项</span></span><br><span class="line"><span class="comment">      type属性：设置不同的属性 来把input设置成不同的输入框形式</span></span><br><span class="line"><span class="comment">        text：文本框</span></span><br><span class="line"><span class="comment">        password：密码框 输入的值会变成小黑点</span></span><br><span class="line"><span class="comment">        radio：单选框</span></span><br><span class="line"><span class="comment">          通过name属性，可以把单选框划为一组</span></span><br><span class="line"><span class="comment">        checkbox：多选框</span></span><br><span class="line"><span class="comment">        reset：表单重置按钮</span></span><br><span class="line"><span class="comment">        commit：表单提交按钮</span></span><br><span class="line"><span class="comment">    textarea标签：文本域标签</span></span><br><span class="line"><span class="comment">      rows属性：设置多少行</span></span><br><span class="line"><span class="comment">      cols属性：设置多少列</span></span><br><span class="line"><span class="comment">    select标签：下列框标签</span></span><br><span class="line"><span class="comment">    option标签：下拉框的选项标签</span></span><br><span class="line"><span class="comment">      selected属性： 默认选中该项</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">  用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;默认值&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  用户密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  确认密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> <span class="attr">name</span>=<span class="string">&quot;commitPass&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">checked</span>/&gt;</span> 男 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span> 女<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  兴趣爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>/&gt;</span> java <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;c语言&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>/&gt;</span> C++ <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;python&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>/&gt;</span> python<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  国籍：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;nationality&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>请选择国籍<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>俄罗斯<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>阿根廷<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  自我评价：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">name</span>=<span class="string">&quot;selfEvaluation&quot;</span>&gt;</span>我才是默认值<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h5>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>div、p、span标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  细节：</span></span><br><span class="line"><span class="comment">   1. div标签默认占据一行</span></span><br><span class="line"><span class="comment">   2. span标签 内容多大就多大</span></span><br><span class="line"><span class="comment">   3. p标签 上方 和 或下方 空一行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p标签1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p标签2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p标签3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-CSS介绍"><a href="#4-CSS介绍" class="headerlink" title="4. CSS介绍"></a>4. CSS介绍</h3><ul><li><p><strong>（1）作用：</strong> CSS是 <strong>层叠样式表单</strong>，用于 <strong>控制网页样式信息</strong> 的语言。</p></li><li><h5 id="（2）CSS-与-Html-的结合方式"><a href="#（2）CSS-与-Html-的结合方式" class="headerlink" title="（2）CSS 与 Html 的结合方式"></a>（2）CSS 与 Html 的结合方式</h5><ul><li><p><strong>通过标签的 style属性上进行设置</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red; border: 1px solid blue&quot;</span>&gt;</span>这里是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在head标签中，使用style标签来编写CSS</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>学习CSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;  <span class="comment">/* 标签选择器*/</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>通过link标签来引入CSS文件</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* learnCss.css*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../css/learnCss.css&quot;&gt;</code></p></li></ul></li><li><h5 id="（3）选择器分类"><a href="#（3）选择器分类" class="headerlink" title="（3）选择器分类"></a>（3）选择器分类</h5><ul><li><p><strong>标签名选择器</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>id选择器</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#test</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>这是是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>class选择器</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.test</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>这是是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>组合选择器</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.test</span>,<span class="selector-id">#testId</span>,<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>这是是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;testId&quot;</span>&gt;</span>这里是idDiv<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这里是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="二、JavaScript"><a href="#二、JavaScript" class="headerlink" title="二、JavaScript"></a>二、JavaScript</h1><h3 id="1-javascript介绍"><a href="#1-javascript介绍" class="headerlink" title="1. javascript介绍"></a>1. javascript介绍</h3><ul><li><strong>用处：</strong> 主要完成 对页面的 <strong>数据验证</strong>。</li><li><strong>特点：</strong> <strong>交互性、安全性、跨平台性</strong></li><li><strong>JS是弱类型，即变量的类型可以随时变化。</strong> <code>var i=1; i=&quot;abc&quot;</code> 。</li></ul><h3 id="2-JavaScript与Html-结合的方式"><a href="#2-JavaScript与Html-结合的方式" class="headerlink" title="2. JavaScript与Html 结合的方式"></a>2. JavaScript与Html 结合的方式</h3><ul><li><p>在 <strong>head标签 或者 body标签中，使用 script标签</strong> 书写Javascript代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(i);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>script标签 单独 引入JS文件</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="title function_">alert</span>(i);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 引入 js文件 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/test01.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-JavaScript变量"><a href="#3-JavaScript变量" class="headerlink" title="3. JavaScript变量"></a>3. JavaScript变量</h3><ul><li>变量类型分别有：<strong>数值类型（number）、字符串类型（string）、对象类型（object）、布尔类型（boolean）、函数类型（function）</strong>。</li><li>JavaScript存在有特殊的值：<ul><li><strong>undefined（未定义）：</strong> 当变量 <strong>没有被初始化时，都会是undifined</strong>。</li><li><strong>null（空值）</strong></li><li><strong>NAN：</strong> 全称是 <strong>not a number 意为 非数字</strong>。</li></ul></li></ul><h3 id="4-JavaScript的运算符"><a href="#4-JavaScript的运算符" class="headerlink" title="4. JavaScript的运算符"></a>4. JavaScript的运算符</h3><ul><li><p><strong>关系运算符</strong></p><ul><li><p><strong>&#x3D;&#x3D;（等于）：</strong> 用于做 简单的字面上的 数值比较（甚至可以 不同类型的 数值比较）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( a == b); <span class="comment">// 结果为 true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>&#x3D;&#x3D;&#x3D;（全等于）：</strong> 除了做字面上的数值比较，<strong>还会做 类型上面的比较</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( a === b); <span class="comment">// 结果为 false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>逻辑运算符</strong></p><ul><li><p>在 JavaScript语言中，<strong>0，null，undefined，”“（空串） 都被认为是 false</strong>。</p></li><li><p><strong>&amp;&amp; 且运算符</strong></p><ul><li><p>当 <strong>表达式全为 真时，返回最后一个表达式 的 值</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( a &amp;&amp; b); <span class="comment">//返回 abc</span></span><br></pre></td></tr></table></figure></li><li><p>当 表达式中，<strong>有一个为假时，返回第一个为假的表达式的值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">alert</span>( a &amp;&amp; b); <span class="comment">//返回值为 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>|| 或运算符</strong></p><ul><li><p>当 表达式全为假时，返回 <strong>最后一个表达式的值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( a || b); <span class="comment">//返回 ”“</span></span><br></pre></td></tr></table></figure></li><li><p>当 <strong>表达式中 有为真时，返回 第一个为真的值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( a || b); <span class="comment">//返回 abc</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="5-JavaScript-的数组"><a href="#5-JavaScript-的数组" class="headerlink" title="5. JavaScript 的数组"></a>5. JavaScript 的数组</h3><ul><li><p>JavaScript 的数组，可以存放 <strong>各种类型的元素</strong>。 <code>var arr = [1,&quot;abc&quot;,true]</code> 。</p></li><li><p>JavaScript数组，只要我们 通过 <strong>数组下标赋值，那么最大的下标值就会该表，数组会自动扩容。</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//此时数组的最大下标变为5，数组长度为 5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-JavaScript函数"><a href="#6-JavaScript函数" class="headerlink" title="6. JavaScript函数"></a>6. JavaScript函数</h3><ul><li><p><strong>函数的定义方式：</strong></p><ul><li><p><strong>使用function关键字来定义函数</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;a=&quot;</span>a+<span class="string">&quot;,b=&quot;</span>+b);</span><br><span class="line">    <span class="keyword">return</span> a;  <span class="comment">//可以直接用 return关键字来 返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用var关键字来创建函数</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun= fuction <span class="title function_">fun</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>JS 允许 函数重载，</strong> 但是 JS中的 <strong>重载的函数 会 直接 覆盖掉 上一次的定义函数</strong>。</p></li><li><p>JS 中 存在 一个 <strong>隐形参数 arguments 的 参数列表。</strong> 可以获取 所有的传参。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(auguments.<span class="property">length</span>); <span class="comment">//这里会输出 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-JavaScript自定义对象"><a href="#7-JavaScript自定义对象" class="headerlink" title="7.JavaScript自定义对象"></a>7.JavaScript自定义对象</h3><ul><li><p><strong>自定义对象的两种方式</strong></p><ul><li><p>​<strong>Object形式的自定义对象</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//定义对象</span></span><br><span class="line"><span class="comment">//给student进行属性/方法 初始化赋值</span></span><br><span class="line">student.<span class="property">name</span> = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">student.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">student.<span class="property">address</span> = <span class="string">&quot;广州&quot;</span>;</span><br><span class="line">student.<span class="property">introduce</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="variable language_">this</span>.<span class="property">age</span>+<span class="variable language_">this</span>.<span class="property">address</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用student的属性 或 方法</span></span><br><span class="line"><span class="title function_">alert</span>(student.<span class="property">name</span>);</span><br><span class="line">student.<span class="title function_">introduce</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用{}的方式来自定义对象</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = &#123;</span><br><span class="line">  name : <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">  age : <span class="number">24</span>,</span><br><span class="line">  tel : <span class="string">&quot;152184&quot;</span>,</span><br><span class="line">  toString : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="variable language_">this</span>.<span class="property">age</span>+<span class="variable language_">this</span>.<span class="property">tel</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">teacher.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8-JavaScript事件"><a href="#8-JavaScript事件" class="headerlink" title="8. JavaScript事件"></a>8. JavaScript事件</h3><ul><li><p><strong>事件，</strong> 是电脑输入设备 与 页面 进行交互的响应。 </p></li><li><p>事件的注册 分为：</p><ul><li><strong>静态注册：</strong> 通过 <strong>html标签的属性</strong> 来 赋予 <strong>事件响应后的代码</strong> 则为 静态注册</li><li><strong>动态注册：</strong> 先通过 <strong>js代码获取标签的dom对象</strong>，通过 <strong>dom对象.事件名 &#x3D; function(){}</strong> 这种形式赋予 响应后的代码 为 动态注册。</li></ul></li><li><p><strong>常用事件使用：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--    <span class="title function_">onload</span>()事件： 该事件用于 在浏览器页面执行时，自动调用的事件。--&gt;</span><br><span class="line">&lt;!-- 静态注册 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onunload</span>=<span class="string">&quot;onupload01()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 动态注册 --&gt;</span></span></span><br><span class="line"><span class="language-xml">window.onload = function ()&#123;</span></span><br><span class="line"><span class="language-xml">  alert(&quot;动态注册 onload事件&quot;);</span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 动态注册点击事件 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  var btnObj = document.getElementById(&quot;btn02&quot;);</span></span><br><span class="line"><span class="language-xml">  btnObj.onclick = function ()&#123;</span></span><br><span class="line"><span class="language-xml">    alert(&quot;按钮2被点击&quot;);</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 动态注册onchange事件 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    var selectObj = document.getElementById(&quot;select01&quot;);</span></span><br><span class="line"><span class="language-xml">  selectObj.onblur = function ()&#123;</span></span><br><span class="line"><span class="language-xml">    alert(&quot;选项改变&quot;);</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--  onclick()：点击事件--&gt;</span> </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;click01();&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span> = <span class="string">&quot;btn02&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;onblur01();&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input01&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- onchange（）： 下拉列表选项改变事件 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">onchange</span>=<span class="string">&quot;onchange01();&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>---请选择---<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>唱歌<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>跳舞<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>跳大神<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select01&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>---请选择---<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>驱魔<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>辟邪<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>跳大神<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">      //其余类似</span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!--onsubmit()：表单提交事件--&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-document对象"><a href="#9-document对象" class="headerlink" title="9. document对象"></a>9. document对象</h3><ul><li><p><strong>作用：</strong> 可以把 html中的 标签、属性、文本等 <strong>转化为对象来管理。</strong> </p></li><li><p><strong>方法介绍：</strong> </p><ul><li><p><strong>document.getElementById(elementId) 通过标签id 获取 标签对象</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;commitID&quot;</span> onclick=<span class="string">&quot;commitById()&quot;</span>&gt;通过<span class="variable constant_">ID</span>获取&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitById</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//获取到 id为 commitID 的对象</span></span><br><span class="line">  <span class="keyword">var</span> commitBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;commitID&quot;</span>);</span><br><span class="line">  <span class="title function_">alert</span>(commitBtn.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>document.getElementsByName(elementName) 通过标签name属性 获取对象</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;通过getElementName获取多个标签&lt;/h1&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C++&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>/&gt;</span></span>C++</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>/&gt;</span></span>java</span><br><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;python&quot;</span> name=<span class="string">&quot;hobby&quot;</span>/&gt;python&lt;br/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;checkAll()&quot;</span>&gt;</span>全选<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;cancelAll()&quot;</span>&gt;</span>全不选<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;inverse()&quot;</span>&gt;</span>反选<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAll</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> elementsByName = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;elementsByName.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    elementsByName[i].<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cancelAll</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> elementsByName = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;elementsByName.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    elementsByName[i].<span class="property">checked</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inverse</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> elementsByName = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;elementsByName.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(elementsByName[i].<span class="property">checked</span>)&#123;</span><br><span class="line">      elementsByName[i].<span class="property">checked</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      elementsByName[i].<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>document.getElementsByTag ：通过标签名 获取 多个标签对象。使用方法与 getElementByName一样。</strong></p></li><li><p><strong>document.createElement：创建标签</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> htmlDivElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);  <span class="comment">//创建一个div标签</span></span><br><span class="line">  htmlDivElement.<span class="property">innerHTML</span> = <span class="string">&quot;我真的好帅&quot;</span>; <span class="comment">//给div标签赋予内容</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(htmlDivElement); <span class="comment">//加入到body标签体中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p><strong>节点的操作方法和属性：</strong></p><ul><li><img src="E:\blog\source\images\JavaWeb复习\节点的常用方法.png"></li><li><img src="E:\blog\source\images\JavaWeb复习\节点的常用属性.png"></li></ul></li></ul><h1 id="三、-JQuery"><a href="#三、-JQuery" class="headerlink" title="三、 JQuery"></a>三、 JQuery</h1><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>JQuery 顾名思义就是 <strong>javaScript 与 查询（Query）</strong>， 他是辅助 JavaScript 开发的类库。其核心思想的就是 <strong>写的更少，做的更多。简洁代码，并且实现了许多浏览器的兼容问题。</strong></p><h3 id="2-JQuery核心函数"><a href="#2-JQuery核心函数" class="headerlink" title="2. JQuery核心函数"></a>2. JQuery核心函数</h3><p><strong>$是JQuery的核心函数，能完成很多的JQuery功能。其中，$()就是调用 $这个函数。</strong></p><ul><li><p><strong>传入参数为 [函数时]：</strong> 表示 <strong>JavaScript的 window.onload &#x3D; function (){}</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--先引入<span class="title class_">JQuery</span>--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/jquery-3.5.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;xx&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>传入参数为 [HTML字符串]时，根据这个字符串来 创建元素节点对象。</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  $(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;&lt;div&gt;&quot;</span> +</span><br><span class="line">      <span class="string">&quot;    &lt;span&gt;span1&lt;/span&gt;&quot;</span> +</span><br><span class="line">      <span class="string">&quot;    &lt;span&gt;span2&lt;/span&gt;&quot;</span> +</span><br><span class="line">      <span class="string">&quot;  &lt;/div&gt;&quot;</span>).<span class="title function_">appendTo</span>(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>传入参数为 [选择器字符串]时，根据这个字符串来 查找元素节点对象</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  $(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> $btn1 = $(<span class="string">&quot;#btn1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    $btn1.<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&quot;按钮1被点击&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>传入参数为[DOM对象] , 将Dom对象包装为 Query对象返回</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  $(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> btn1ByDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> $btn1ByJQu = $(btn1ByDom);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>($btn1ByJQu);</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-如何区分-JQuery对象-与-dom对象"><a href="#3-如何区分-JQuery对象-与-dom对象" class="headerlink" title="3. 如何区分 JQuery对象 与 dom对象"></a>3. 如何区分 JQuery对象 与 dom对象</h3><ul><li><p><strong>什么是jquery对象 什么是 dom对象</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E4%BB%80%E4%B9%88%E6%98%AFdom%E5%AF%B9%E8%B1%A1.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E4%BB%80%E4%B9%88%E6%98%AFjquery%E5%AF%B9%E8%B1%A1.png"></p></li><li><p><strong>JQuery对象的本质是：</strong> 有 <strong>dom对象组成的数组</strong> + <strong>JQuery提供的一系列功能函数。</strong></p></li><li><p><strong>JQuery对象 与 Dom对象的 方法是不能够 相互使用的。</strong></p></li><li><p><strong>JQuery对象 与 Dom 对象互转的方法：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  $(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//dom对象 转 JQuery对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> btn1ByDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> $btn1ByJQu = $(btn1ByDom); <span class="comment">//直接使用 $(dom对象) 来转化成 jquery对象//jquery对象 转 dom对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>($btn1ByJQu);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//jquery对象 转 dom对象</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> $btn01 = $(<span class="string">&quot;#btn1&quot;</span>); <span class="comment">//jquery对象</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> btn01ByDom = $btn01[<span class="number">0</span>]; <span class="comment">//通过数组下标来 把 jquery对象 =》 dom对象</span></span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-JQuery选择器"><a href="#4-JQuery选择器" class="headerlink" title="4.JQuery选择器"></a>4.JQuery选择器</h3><ul><li><p><strong>基本选择器</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8.png"></p></li><li><p><strong>层级选择器</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E5%B1%82%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8.png"></p></li><li><p><strong>过滤选择器</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E8%BF%87%E6%BB%A4%E9%80%89%E6%8B%A9%E5%99%A8.png"></p></li><li><p><strong>内容选择器</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E5%86%85%E5%AE%B9%E9%80%89%E6%8B%A9%E5%99%A8.png"></p></li><li><p><strong>属性选择器</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8.png"></p></li><li><p><strong>表单过滤器</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E8%A1%A8%E5%8D%95%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p></li></ul><h3 id="5-元素的筛选"><a href="#5-元素的筛选" class="headerlink" title="5.元素的筛选"></a>5.元素的筛选</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/%E5%85%83%E7%B4%A0%E7%9A%84%E7%AD%9B%E9%80%89.png"></p><h3 id="6-JQuery常用方法"><a href="#6-JQuery常用方法" class="headerlink" title="6.JQuery常用方法"></a>6.JQuery常用方法</h3><p><img src="E:\blog\source\images\JavaWeb复习\JQuery常用方法01.png"></p><p><img src="E:\blog\source\images\JavaWeb复习\JQuery常用方法02.png"></p><h3 id="7-DOM的增删改操作方法"><a href="#7-DOM的增删改操作方法" class="headerlink" title="7.DOM的增删改操作方法"></a>7.DOM的增删改操作方法</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/dom%E5%86%85%E9%83%A8%E6%8F%92%E5%85%A5.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/dom%E5%A4%96%E9%83%A8%E6%8F%92%E5%85%A5.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/dom%E6%9B%BF%E6%8D%A2.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/dom%E5%88%A0%E9%99%A4.png"></p><h3 id="8-CSS样式操作"><a href="#8-CSS样式操作" class="headerlink" title="8.CSS样式操作"></a>8.CSS样式操作</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/css%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C.png"></p><h3 id="9-JQuery动画"><a href="#9-JQuery动画" class="headerlink" title="9.JQuery动画"></a>9.JQuery动画</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/jquery%E5%8A%A8%E7%94%BB01.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JavaScript/jquery%E5%8A%A8%E7%94%BB02.png"></p><h3 id="10-JQuery事件操作"><a href="#10-JQuery事件操作" class="headerlink" title="10.JQuery事件操作"></a>10.JQuery事件操作</h3><ul><li><p><strong>$(function(){}) 与 window.onload &#x3D; function() {} 有什么区别</strong></p><ul><li>JQuery是在 <strong>浏览器的内核 分析完页面的标签 创建好Dom对象</strong> 之后 立刻执行的。而 原生的JS 则不仅需要这样，<strong>还要等标签显示时 需要加载的内容 加载完成</strong> 后 才执行。 因此，<strong>JQuery 比 JS 的 页面加载后 执行方法要快。</strong></li><li>原生的JS的页面加载后方法 <strong>只会执行最后一次的赋值。</strong> 而 JQuery 则会 <strong>每一个的 页面加载后方法 按照顺序 依次执行。</strong></li></ul></li><li><p><strong>JQuerry常用事件方法</strong></p><p><strong>mousemove（）：鼠标移动事件</strong> </p><p>!<img src="E:\blog\source\images\JavaWeb复习\JQuery常用事件方法.png"></p></li><li><p><strong>事件的冒泡</strong></p><ul><li><strong>含义：</strong> 事件的冒泡 是指 当 <strong>父子元素 绑定了 同一个事件时，当子元素的事件被触发，那么父元素的事件也会被触发。</strong> </li><li><strong>解决冒泡：</strong> 在 <strong>子元素 的函数体中 加入 return false; 即可</strong></li></ul></li><li><p><strong>事件的对象</strong></p><ul><li><strong>事件的对象：</strong> 是指 <strong>封装了 有触发事件信息 的 对象</strong></li><li><strong>如何获取：</strong> 在 <strong>事件函数的 function 中 加入参数 event 即可。</strong> 例如 <code>$(&quot;div&quot;).click(function(event))</code></li><li><strong>用处：</strong> 例如 当使用 bind绑定了多个事件之后，可用事件对象来 判断 当前触发了哪个对象 来进行 特异性处理。</li></ul></li></ul><h2 id="四、XML"><a href="#四、XML" class="headerlink" title="四、XML"></a>四、XML</h2><h3 id="1-xml介绍与作用"><a href="#1-xml介绍与作用" class="headerlink" title="1. xml介绍与作用"></a>1. xml介绍与作用</h3><p>xml是一种 <strong>可扩展的标记性语言。</strong> 主要用于三个方面：<strong>保存数据、作为项目或者模块的配置文件、作为网格传输数据的格式（现已JSON为主）。</strong></p><h3 id="2-使用dom4j库-来对xml文件进行读取（需引入dom4j-jar）"><a href="#2-使用dom4j库-来对xml文件进行读取（需引入dom4j-jar）" class="headerlink" title="2.使用dom4j库 来对xml文件进行读取（需引入dom4j.jar）"></a>2.使用dom4j库 来对xml文件进行读取（需引入dom4j.jar）</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以Book为根属性 产开数据编写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ISBN</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">ISBN</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>《鲁宾孙漂流记》<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>45.6<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ISBN</span>&gt;</span>15342432<span class="tag">&lt;/<span class="name">ISBN</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>《三体》<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>67.8<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ISBN</span>&gt;</span>56343242<span class="tag">&lt;/<span class="name">ISBN</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>《月亮与六便士》<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>54<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Books</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDom4j</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建saxReader流 去读取xml文件</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//2. 获取到 xml文件</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="string">&quot;XMLDemo/src/book.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//3. 获取rootElement对象 来 获取根元素标签</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">            <span class="comment">//4. 获取到根元素为Book 的 里面所有子标签</span></span><br><span class="line">            List&lt;Element&gt; books = rootElement.elements(<span class="string">&quot;Book&quot;</span>);</span><br><span class="line">            <span class="comment">//5. 遍历 books 来 获取子标签内容 并输出</span></span><br><span class="line">            <span class="keyword">for</span>(Element book:books)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">isbn</span> <span class="operator">=</span> book.elementText(<span class="string">&quot;ISBN&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> book.elementText(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">price</span> <span class="operator">=</span> book.elementText(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;ISBN: &quot;</span>+isbn+<span class="string">&quot; name：&quot;</span>+name+<span class="string">&quot; price：&quot;</span>+price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、Tomcat服务器"><a href="#五、Tomcat服务器" class="headerlink" title="五、Tomcat服务器"></a>五、Tomcat服务器</h1><h3 id="1-Tomcat版本与Servlet版本对应关系"><a href="#1-Tomcat版本与Servlet版本对应关系" class="headerlink" title="1. Tomcat版本与Servlet版本对应关系"></a>1. Tomcat版本与Servlet版本对应关系</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/tomcat%E4%B8%8EServlet%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94.png"></p><h3 id="2-tomcat目录介绍"><a href="#2-tomcat目录介绍" class="headerlink" title="2.tomcat目录介绍"></a>2.tomcat目录介绍</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/tomcat%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D.png"></p><h3 id="3-如何启动tomcat"><a href="#3-如何启动tomcat" class="headerlink" title="3.如何启动tomcat"></a>3.如何启动tomcat</h3><ul><li><strong>在tomcat目录下的 bin目录 中 打开 startup.bat 即可 启动 tomcat。</strong></li><li>在命令行中 <strong>cd到 tomcat目录下的 bin目录，执行语句 catalina run</strong></li><li>可通过 <strong><a href="http://localhost:8080/">http://localhost:8080</a> 来测试 是否成功启动</strong></li></ul><h3 id="4-如何停止tomcat"><a href="#4-如何停止tomcat" class="headerlink" title="4. 如何停止tomcat"></a>4. 如何停止tomcat</h3><ul><li><strong>在tomcat服务窗口中 点击x关闭窗口 或者 按 ctrl+c 退出</strong></li><li><strong>在tomcat 目录下bin目录的 shutdown.bat 点击关闭</strong></li></ul><h3 id="5-修改tomcat端口号"><a href="#5-修改tomcat端口号" class="headerlink" title="5.修改tomcat端口号"></a>5.修改tomcat端口号</h3><p>在 <strong>tomcat目录下的 conf目录下的 server.xml 文件中，找到 connector标签修改</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/%E4%BF%AE%E6%94%B9tomcat%E7%AB%AF%E5%8F%A3.png"></p><h3 id="6-如何把项目放进tomcat进行部署"><a href="#6-如何把项目放进tomcat进行部署" class="headerlink" title="6.如何把项目放进tomcat进行部署"></a>6.如何把项目放进tomcat进行部署</h3><ul><li><p>1）把 web工程 拷贝到 <strong>tomcat目录&#x2F;webapp</strong> 目录下即可</p></li><li><p>2）找到 <strong>tomcat目录&#x2F;conf&#x2F;catalina&#x2F;localhos</strong>t 中，创建如下配置文件(xml文件):</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;<span class="comment">&lt;!-- context : 为上下文标签</span></span><br><span class="line"><span class="comment"> path： web工程的地址访问路径</span></span><br><span class="line"><span class="comment">docBase: web工程的 目录文件路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/abc&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;E:\book&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>3）<strong>如果tomcat地址输入没有 工程名 则默认执行 root项目。tomcat会 自动首先打开 index.html 页面</strong></p></li></ul><h3 id="7-tomcat如何整合-idea"><a href="#7-tomcat如何整合-idea" class="headerlink" title="7.tomcat如何整合 idea"></a>7.tomcat如何整合 idea</h3><ul><li><p><strong>创建javaWeb项目，并整合Tomcat</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\idea添加tomcat.png"></p><p><img src="E:\blog\source\images\JavaWeb复习\新建javaWeb项目01.png"></p></li><li><p><strong>Web项目目录介绍</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\web项目工程目录介绍.png"></p></li><li><p><strong>Idea 设置 tomcat实例</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\idea中tomcat设置.png"></p></li></ul><h2 id="六、Servlet"><a href="#六、Servlet" class="headerlink" title="六、Servlet"></a>六、Servlet</h2><h3 id="1-什么是Servlet"><a href="#1-什么是Servlet" class="headerlink" title="1. 什么是Servlet"></a><strong>1. 什么是Servlet</strong></h3><p>servlet 是 JavaEE的 <strong>规范之一，也是 JavaWeb的三大组件之一（Servlet程序、Filter过滤器、Listener监听器）</strong>。它主要能够 <strong>接收客户端发送过来的请求，并响应数据给客户端。</strong></p><h3 id="2-手动实现一个Servlet程序"><a href="#2-手动实现一个Servlet程序" class="headerlink" title="2. 手动实现一个Servlet程序"></a>2. 手动实现一个Servlet程序</h3><p><img src="E:\blog\source\images\JavaWeb复习\新建Servlet程序01.png"></p><p><strong>新建好之后，去web.xml 配置 <servlet-mapper></servlet-mapper></strong> </p><h3 id="3-解析如何定位到Servlet程序中"><a href="#3-解析如何定位到Servlet程序中" class="headerlink" title="3.解析如何定位到Servlet程序中"></a>3.解析如何定位到Servlet程序中</h3><p><img src="E:\blog\source\images\JavaWeb复习\解析url如何定位到servlet程序中.png"></p><h3 id="4-Servlet的生命周期"><a href="#4-Servlet的生命周期" class="headerlink" title="4.Servlet的生命周期"></a>4.Servlet的生命周期</h3><p>生命周期的顺序：<strong>执行Servlet的构造器方法-》执行init初始化方法-》执行service方法-》执行destory销毁方法</strong> 其中，<strong>第一二步是在第一次访问时执行。service方法是 每次访问都会执行，而 desroty方法 是在程序结束时执行。</strong> </p><h3 id="5-Servlet的继承关系图"><a href="#5-Servlet的继承关系图" class="headerlink" title="5.Servlet的继承关系图"></a>5.Servlet的继承关系图</h3><p><img src="E:\blog\source\images\JavaWeb复习\servlet继承图.png"></p><h3 id="6-ServletConfig类"><a href="#6-ServletConfig类" class="headerlink" title="6.ServletConfig类"></a>6.ServletConfig类</h3><ul><li><p><strong>作用：</strong> 可用于获取Servlet程序的 <strong>一些配置信息。</strong> 如 <strong>获取 servlet-name的值、获取初始化参数 init-param 、获取servletContext对象。</strong></p></li><li><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以在init方法中使用 ServletConfig类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//这一步在init方法中必须要调用一下父类的init方法</span></span><br><span class="line">        <span class="comment">//因为该init的方法是会把GenericServlet 中的 init方法覆盖掉，导致ServletConfig对象没有得到保存就会无效</span></span><br><span class="line">        <span class="built_in">super</span>.init(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 获取servlet-name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> config.getServletName();</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet-name：&quot;</span>+servletName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取init-param</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name：&quot;</span>+name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 获取servletContext对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;servletContext对象：&quot;</span>+config.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//也可以在其他方式中使用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 通过该方法来获取servletConfig对象</span></span><br><span class="line">        <span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>细节：</strong></p><p><strong>ServletConfig类 是在每一个 Servlet程序创建的时候，就会创建一个对应的ServletConfig类</strong></p></li></ul><h3 id="7-ServletContext类"><a href="#7-ServletContext类" class="headerlink" title="7.ServletContext类"></a>7.ServletContext类</h3><ul><li><p><strong>什么是ServletContext</strong></p><ul><li>ServletContext是一个接口，<strong>它表示Servlet的上下文对象。</strong></li><li>一个Web工程，<strong>只会有一个ServletContext对象。</strong></li><li><strong>它是一个域对象（即作用范围是整个项目）</strong></li><li>它是在 <strong>Web工程部署启动的时候创建，在Web工程停止运行时销毁。</strong></li></ul></li><li><p><strong>作用：</strong></p><ul><li>获取在 web.xml中配置的 context-param</li><li>获取当地的工程路径（格式：&#x2F;工程路径）</li><li>获取工程部署后在服务器硬盘上的绝对路径</li><li>可以像Map一样存储数据（不同的Servlet程序可获取相同值）</li></ul></li><li><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//通过方法 getServletContext()来获取 ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 获取context-param的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;全局的context-param：&quot;</span>+password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取当地的工程路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> servletContext.getContextPath();</span><br><span class="line">        System.out.println(<span class="string">&quot;工程路径：&quot;</span>+contextPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 获取工程部署后在服务器硬盘上的绝对路径</span></span><br><span class="line">        <span class="comment">//这里的/代表的是  http://ip:post/工程名/   （可以理解为 / 代表的是 项目的 web目录）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;绝对路径：&quot;</span>+realPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 存取数据</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userName</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userName：&quot;</span>+userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="8-Http协议"><a href="#8-Http协议" class="headerlink" title="8.Http协议"></a>8.Http协议</h3><ul><li><p><strong>含义：</strong> 客户端 和 服务端 之间通信时，发送的数据 ，都需要遵守的协议。 其中，Http中的数据 <strong>也称为报文。</strong> </p></li><li><p><strong>http的请求格式：</strong></p><ul><li><p><strong>get请求</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\get请求格式.png"></p></li><li><p><strong>post请求</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\post请求格式.png"></p></li></ul></li><li><p><strong>get请求 与 post请求 引用场景</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\get请求与post请求应用场景.png"></p></li><li><p><strong>http响应的格式：</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\http响应格式.png"></p></li><li><p><strong>常用的响应码：</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\http常用响应码.png"></p></li><li><p><strong>MIME类型说明：</strong></p><p>MIME 是 http 协议中的 数据类型 </p><p><img src="E:\blog\source\images\JavaWeb复习\http的MIME类型.png"></p></li></ul><h3 id="9-HttpServletRequest类"><a href="#9-HttpServletRequest类" class="headerlink" title="9.HttpServletRequest类"></a>9.HttpServletRequest类</h3><ul><li><p><strong>作用：</strong> 每次只要有 请求进入 tomcat服务器，tomcat服务器 就会把 请求过来的 <strong>http协议信息解析好封装到 Request对象中。</strong> 然后 **传递到 service方法中（doGet 和 doPost）。 ** 我们通过 <strong>httpServletRequest 对象来获取信息。</strong> </p></li><li><p><strong>常用方法：</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\httpServletRequest对象的常用方法.png"></p></li><li><p><strong>如何获取参数：</strong></p></li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码为UTF-8 防止乱码（必须在获取参数前设置才有效）</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过getParameter（）来获取 从表单传来的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userName: &quot;</span>+username);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;password: &quot;</span>+password);</span><br><span class="line">        String[] hobbies = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hobbies: &quot;</span>+ Arrays.asList(hobbies));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>请求的转发</strong></p><ul><li><p><strong>含义：</strong> 服务器 收到请求后，从一次资源 跳转到 另一个资源的操作 为 请求转发。</p></li><li><p><strong>示意图：</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\请求转发示意图.png"></p></li><li><p><strong>举例：servlet1 请求转发到 servlet2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 获取请求的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet1的name: &quot;</span>+name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 传递一个 值 给域</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;path&quot;</span>,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取跳转到servlet的RequestDispatcher对象</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/servlet2&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 跳转到 servlet2 forward（）方法 向前跳转</span></span><br><span class="line">        requestDispatcher.forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//1.获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet2的name: &quot;</span>+name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取servlet的值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">path</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到servlet1存储的域值: &quot;</span>+path.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.处理业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;servlet2在处理业务&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;业务处理完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>base标签使用</strong></p><ul><li><p>在<strong>请求转发</strong>后，地址栏便会发生变化。 那么 <strong>对于跳转后的页面的相对路径跳转就 不能够找到 地址了</strong>。 这时，就可以通过 <strong>base标签来指定 只要是该页面 即 不管地址栏目前是什么地址 都会按照base标签的href值来 进行 路径跳转。</strong></p></li><li><p>实例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">这是首页的index.html<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;a/b/c.html&quot;</span>&gt;</span>跳到到c.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:8080/FirstJavaWeb/baseTag&quot;</span>&gt;</span>重定向到c.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    如果不加base标签 请求转发过来的地址栏 就无法通过 ../../index.html跳转到 index.html--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:8080/FirstJavaWeb/a/b/c.html&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">这是c.html<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;../../index.html&quot;</span>&gt;</span>跳转到首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/a/b/c.html&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>web中的绝对路径 与 相对路径</strong></p><p><img src="E:\blog\source\images\JavaWeb复习\Web中的绝对路径与相对路径.png"></p></li></ul></li></ul><h3 id="10-HttpServletResponse类"><a href="#10-HttpServletResponse类" class="headerlink" title="10.HttpServletResponse类"></a>10.HttpServletResponse类</h3><ul><li><p><strong>介绍：</strong> 每当有请求进入 tomcat服务器后，<strong>都会生成一个Response对象 传递到 Servlet程序。主要用于 响应给 客户端的信息。</strong>  </p></li><li><p><strong>两个流的使用：</strong></p><p>主要分为 <strong>字节流（getOutputStream() ） 和 字符流（getWriter() ）</strong> ，字节流 主要用于 <strong>下载与上传（传递二进制数据）</strong> 而 字符流 常用于 <strong>传输字符串</strong>.</p><p><strong>注意：两个流只能使用其中一个，在使用 字符流时，若需要传递中文，则需要设置 response.setContentType(“text&#x2F;html; charset&#x3D;UTF-8”); 防止中文乱码。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置 服务器 和 浏览器的编码格式为 UTF-8 避免中文乱码</span></span><br><span class="line">       response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter(); <span class="comment">//获取字符流</span></span><br><span class="line">        writer.write(<span class="string">&quot;response传递数据&quot;</span>); <span class="comment">//数据信息</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>请求重定向</strong></p><ul><li><p><strong>介绍：</strong> 当客户端 访问请求 一个 服务端A时，服务端A 会告诉 客户端 已停止使用，并把新的服务端B的地址告诉给客户端，让客户端去访问 服务端B。这种方式 就叫请求重定向。</p><p><img src="E:\blog\source\images\JavaWeb复习\请求重定向解析.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//servletA:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一共有两种方式进行重定向</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            <span class="comment">//方法1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;访问了response1&quot;</span>);</span><br><span class="line">            response.setStatus(<span class="number">302</span>); <span class="comment">//设置代码302 标识为重定向</span></span><br><span class="line">            response.setHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;http://localhost:8080/FirstJavaWeb/servletB&quot;</span>); <span class="comment">//说明重定向的地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法2(推荐)</span></span><br><span class="line">            <span class="comment">//直接使用sendRedirect（url） 来执行重定向</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;http://localhost:8080/FirstJavaWeb/servletB&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//servletB</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;访问了response2&quot;</span>);</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="11-解决-Servlet类冗余问题"><a href="#11-解决-Servlet类冗余问题" class="headerlink" title="11. 解决 Servlet类冗余问题"></a>11. 解决 Servlet类冗余问题</h3><ul><li><p><strong>问题体现：</strong> 照目前来说，我们每一个URL 就代表了一个 Servlet类，这样很明显会 出现许多的Servlet类，这样显而不好。因此，我们需要创建 一个BaseServlet程序，让Servlet类继承后，每一个普通方法 就能相当于 一个URL</p></li><li><p><strong>代码实现：</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;JSP - Hello World&lt;/title&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;http://localhost:8080/CookieDemo/&quot;</span>/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;&lt;%= <span class="string">&quot;Hello World!&quot;</span> %&gt;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"> &lt;!-- 通过a标签的 href属性中 action 跳转到Servlet程序中的方法 --&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;cookie?action=createCookie&quot;</span> target=<span class="string">&quot;target&quot;</span>&gt;创建Cookie&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//baseServlet类 通过反射机制 获取到每一个方法 然后执行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">            request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            method.invoke(<span class="built_in">this</span>,request,response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过继承 BaseServlert 让普通方法 也能访问到。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieServlet</span> <span class="keyword">extends</span> <span class="title class_">BaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   创建Cookie</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">createCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException,ServletException &#123;</span><br><span class="line">        <span class="comment">//1. 创建Cookie对象</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 通知客户端 接收 cookie</span></span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Cookie创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Html-和-CSS&quot;&gt;&lt;a href=&quot;#一、Html-和-CSS&quot; class=&quot;headerlink&quot; title=&quot;一、Html 和 CSS&quot;&gt;&lt;/a&gt;一、Html 和 CSS&lt;/h1&gt;&lt;h3 id=&quot;1-B-S-软件的结构&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    
    <category term="-Java -JavaWeb复习" scheme="http://example.com/tags/Java-JavaWeb%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java复习02</title>
    <link href="http://example.com/2021/09/21/javaWeb%E5%A4%8D%E4%B9%A0/javaWeb%E5%A4%8D%E4%B9%A002/"/>
    <id>http://example.com/2021/09/21/javaWeb%E5%A4%8D%E4%B9%A0/javaWeb%E5%A4%8D%E4%B9%A002/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JSP"><a href="#一、JSP" class="headerlink" title="一、JSP"></a>一、JSP</h1><h3 id="1-什么是JSP？"><a href="#1-什么是JSP？" class="headerlink" title="1.什么是JSP？"></a>1.什么是JSP？</h3><ul><li><p><strong>含义：</strong> jsp全名 <strong>java server pages</strong> 意为 Java的服务器页面。</p></li><li><p><strong>作用：</strong> <strong>代替Servlet程序 回传数据 到 Html页面</strong> </p></li><li><p><strong>本质：</strong> Jsp本质上 是 <strong>一个Servlet程序。</strong> </p><p>当我们第一次访问Jsp文件时，Tomcat服务器 <strong>会把jsp页面 翻译成一个Java源文件，并对它进行 编译成.class的字节码文件。其中 Java源代码如下：</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/jsp%E6%9C%AC%E8%B4%A8%E5%9B%BE1.png"></p><p>由图可知，在源代码中 <strong>a.jsp 成为了一个类 其中 继承了 HttpJspBase 的类，而这个类 继承了 HttpServlet。因此，jsp间接的继承了 HttpServlet，是一个Servlet程序。</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/jsp%E6%9C%AC%E8%B4%A8%E5%9B%BE2.png"></p><p>上图是在 <strong>方法_jspService中 的一段代码，可以看出 jsp之间能够 显示html，是用out输出流来输出 html语句的。</strong></p></li></ul><h3 id="2-jsp的三种语法"><a href="#2-jsp的三种语法" class="headerlink" title="2.jsp的三种语法"></a>2.jsp的三种语法</h3><ul><li><p><strong>jsp头部的page指令</strong></p><p>jsp的page指令 <strong>可以修改jsp页面中一些  重要的属性或者行为。</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/page%E6%8C%87%E4%BB%A4%E5%B1%9E%E6%80%A701.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/page%E6%8C%87%E4%BB%A4%E5%B1%9E%E6%80%A702.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/page%E6%8C%87%E4%BB%A4%E5%B1%9E%E6%80%A703.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/page%E6%8C%87%E4%BB%A4%E5%B1%9E%E6%80%A704.png"></p></li><li><p><strong>jsp中常用脚本</strong></p><ul><li><p><strong>声明脚本</strong></p><ul><li><p><strong>格式：</strong> <strong>&lt;%!  声明Java代码  %&gt;</strong></p></li><li><p><strong>作用：</strong> 可以在jsp中 <strong>声明 类、方法、代码块、属性 等。</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%!</span><br><span class="line">        <span class="comment">//声明类属性</span></span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明静态代码块</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            map.put(<span class="string">&quot;password&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明方法</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  id;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//声明内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> Integer id;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>表达式脚本</strong></p></li><li><p><strong>格式：</strong> <strong>&lt;%&#x3D;表达式 %&gt;</strong></p></li><li><p><strong>作用：</strong> 主要用于 <strong>在jsp页面上显示数据</strong></p></li><li><pre><code class="jsp">&lt;body&gt;&lt;%=12%&gt;&lt;/body&gt;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - **特点：**</span><br><span class="line"></span><br><span class="line">    - **所有的表达式脚本都会翻译到 _jspService()方法中，输出的内容使用 out.print()方法输出到页面的**</span><br><span class="line">    - **由于翻译在 _jspService()方法中，因此 _jspService（）方法的对象也能够使用 如 request、response等**</span><br><span class="line">    - **表达式脚本中的表达式 不能用 分号结尾。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **代码脚本**</span><br><span class="line"></span><br><span class="line">  - **格式：** **&lt;%  java语句 %&gt;**</span><br><span class="line">  - **作用：** 可在Jsp页面中 ,**编写Java代码** </span><br><span class="line">  - **特点：**</span><br><span class="line">    - **代码脚本 被翻译在 _jspService()方法中，同样对象也可以使用。**</span><br><span class="line">    - **可以由 多个代码脚本 组合 完成一个完成的 Java语句**</span><br><span class="line">    - **代码脚本 还可以和 表达式脚本 组合使用，在JSP中输出数据** </span><br><span class="line"></span><br><span class="line">  ```jsp</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">      for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">  %&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;%=i%&gt;&lt;br/&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;%</span><br><span class="line">      &#125;</span><br><span class="line">  %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><strong>JSP的三种注释：</strong></p><p><strong>Html注释：</strong> <!-- --> </p><p><strong>Java注释：</strong> &#x2F;&#x2F;单行注释  &#x2F;**&#x2F; 多行注释</p><p><strong>Jsp注释：</strong> &lt;%– –%&gt;</p></li></ul><h3 id="3-JSP的九大内置对象"><a href="#3-JSP的九大内置对象" class="headerlink" title="3.JSP的九大内置对象"></a>3.JSP的九大内置对象</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/jsp%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1.png"></p><h3 id="4-JSP四大域对象"><a href="#4-JSP四大域对象" class="headerlink" title="4.JSP四大域对象"></a>4.JSP四大域对象</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/jsp%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1.png"></p><p><strong>含义：</strong> 域对象 可以像 Map一样存取数据，<strong>不同的是 它们对数据的存取范围。而他们的使用是由顺序的，条件允许 优先使用 范围小的。</strong></p><p><strong>使用范围：</strong> <strong>pageContext-&gt;request-&gt;session-&gt;application</strong>  </p><h3 id="5-jsp中out输出与response输出的区别"><a href="#5-jsp中out输出与response输出的区别" class="headerlink" title="5.jsp中out输出与response输出的区别"></a>5.jsp中out输出与response输出的区别</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/jsp%E4%B8%ADout%E8%BE%93%E5%87%BA%E4%B8%8Eresponse%E8%BE%93%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p><p><strong>上图可以看出，对于JSP，会执行out.flush（）方法 把out的缓冲区 加入到 response缓冲区去。这是最主要的特点。由于底层源码都是用 out来对我们的数据进行输出 ，因此，我们尽量用 out来进行输出数据 避免输出混乱。</strong></p><h3 id="6-jsp的常用标签"><a href="#6-jsp的常用标签" class="headerlink" title="6.jsp的常用标签"></a>6.jsp的常用标签</h3><ul><li><p><strong>1）静态包含：（常使用）</strong></p><ul><li><p><strong>含义：</strong> 当多个页面需要 用到同一部分元素的时候（例如 网页导航栏 或者 底部的版权声明），<strong>可以把这些共有的部分 分别写成一个个的 JSP页面</strong> 哪里需要用到 则 <strong>通过 包含标签 引入即可。</strong> </p></li><li><p><strong>使用：</strong> </p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- -</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;jsp页面地址&quot;</span>%&gt; 静态包含语法 </span><br><span class="line">-&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;/include/footer.jsp&quot;</span>%&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><p><strong>被静态包含的页面 不会被翻译成 class文件</strong></p></li><li><p><strong>其 包含本质 是 在main的class文件中，加入了 footer 的页面信息输出。</strong></p></li></ul></li></ul></li><li><p><strong>2）动态包含：</strong></p><ul><li><p><strong>含义：</strong> 与 静态包含的含义一致</p></li><li><p><strong>使用：</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">main.jsp</span><br><span class="line">&lt;%--</span><br><span class="line">    动态包含：&lt;jsp:include page=<span class="string">&quot;包含jsp地址&quot;</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;/include/head.jsp&quot;</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">head.jsp</span><br><span class="line">头部信息页面&lt;br/&gt;<span class="number">22</span></span><br><span class="line">&lt;!-- 获取参数 --&gt;</span><br><span class="line">&lt;%=request.getParameter(<span class="string">&quot;password&quot;</span>)%&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><strong>动态包含的jsp页面 也会被翻译成 class文件</strong></li><li><strong>在main.java文件中 主要使用该语句 进行包含 head.jsp页面 JspRuntimeLibrary.include（request，reponse，“&#x2F;include&#x2F;head.jsp”，out，false）来引入 head.jsp页面</strong> </li><li><strong>动态包含 还可以传输参数</strong></li></ul></li><li><p><strong>原理图：</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/jsp%E5%8A%A8%E6%80%81%E5%8C%85%E5%90%AB%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p></li></ul></li><li><p><strong>3）请求转发标签</strong></p><ul><li><p><strong>使用：</strong> </p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"> &lt;!-- 请求转发标签  --&gt; </span><br><span class="line">&lt;jsp:forward page=<span class="string">&quot;/include/main.jsp&quot;</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="7-Listener监听器"><a href="#7-Listener监听器" class="headerlink" title="7.Listener监听器"></a>7.Listener监听器</h3><ul><li><p><strong>介绍：</strong> 监听器 是 JavaWeb的三大组件之一。 其只要作用是 <strong>监听某种 类或者事物 ，通过回调函数，对不同的状态做出处理。</strong></p></li><li><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="comment">//在servletCOntext 创建后 调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;servletContext被创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 servletCOntext 销毁后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletContext被销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="二、EL表达式"><a href="#二、EL表达式" class="headerlink" title="二、EL表达式"></a>二、EL表达式</h1><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><ul><li><p>EL 全称是 Expression Language 表达式语言，其主要作用是 <strong>代替JSP的脚本，进行数据的输出。</strong> 因为 EL表达式 可以 <strong>大大的简化 JSP脚本的输出代码。</strong> </p></li><li><p><strong>使用格式：</strong> <strong>${表达式}</strong> </p></li><li><p><strong>细节：</strong> </p><ul><li><strong>EL表达式 主要是输出 域对象中的数据(pageContext、request、session、application)</strong></li><li><strong>如果输出的对象数据为空 ， 则页面直接不显示输出，而不是像 JSP脚本 输出NULL</strong></li><li>如果 四个域对象 都存在相同的key， 那么EL表达式 会 按照 <strong>域对象范围 从小到大的顺序 去输出</strong></li></ul></li><li><p><strong>基本使用：(根据 实体类 的 get方法进行 找到属性值 并 输出的)</strong> </p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">使用EL表达式进行输出&lt;br/&gt;</span><br><span class="line">学生姓名：$&#123;student.name&#125;&lt;br/&gt;           &lt;!-- 输出student的属性 --&gt;</span><br><span class="line">输出列表：$&#123;student.addressList[<span class="number">0</span>]&#125;&lt;br/&gt;  &lt;!-- 输出list集合  --&gt;</span><br><span class="line">输出Map：$&#123;student.map.password&#125;&lt;br/&gt;   &lt;!-- 输出map集合 -- &gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-EL运算符"><a href="#2-EL运算符" class="headerlink" title="2.EL运算符"></a>2.EL运算符</h3><ul><li><p><strong>1）关系运算符</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/EL%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6.png"></p></li><li><p><strong>2）逻辑运算符</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/EL%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.png"></p></li><li><p><strong>3）算术运算符</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/EL%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6.png"></p></li><li><p><strong>4）empty 运算符</strong></p><p><strong>empty运算符 可以 判断一个数据 是否为空 如果为空 返回true ，否则返回 false。</strong><br>以下情况 判定为空</p><p><strong>值为NULL、空串、长度为0的数组、list集合元素个数为0、map集合元素个数为0</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">$&#123;empty str&#125;  <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>5）EL支持 三元运算</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$&#123;<span class="number">12</span>==<span class="number">12</span>? <span class="literal">true</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>6）.运算 与 [] 运算</strong></p><p><strong>.运算 可以用来 输出 实体类的 属性。${student.name}</strong></p><p><strong>[]中括号对象 可以 用来输出 集合的元素 ${arrays[1]}</strong> </p><p><strong>此外 中括号[] 可以用来 输出 特殊字符的  key值。 ${map[“a.b.c”]}</strong></p></li></ul><h3 id="3-EL11个隐含对象"><a href="#3-EL11个隐含对象" class="headerlink" title="3. EL11个隐含对象"></a>3. EL11个隐含对象</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/EL11%E4%B8%AA%E9%9A%90%E5%90%AB%E5%AF%B9%E8%B1%A1.png"></p><h1 id="三、JSTL标签库"><a href="#三、JSTL标签库" class="headerlink" title="三、JSTL标签库"></a>三、JSTL标签库</h1><h3 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. <strong>基本介绍</strong></h3><p>JSTL 标签库 JSP Standard Tag Library ，<strong>主要是为了 优化 JSP的 代码脚本。</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JSTL%E4%BA%94%E5%A4%A7%E6%A0%87%E7%AD%BE%E5%BA%93.png"></p><p><strong>JSTL使用步骤：</strong></p><ol><li><p>引入jar包</p><p>taglibs-standard-impl-1.2.5.jar</p><p>taglibs-standard-spec-1.2.5.jar</p></li><li><p>加入到 工程的 webapp目录下的 libs目录 并把jar包 加入工程 </p><p><strong>错误记录：如果已经把jar包引入了 lib目录，并且加入项目。运行还是报错无法解析 ，则可以直接把 jar包放到 tomcat目录下的 lib目录</strong></p></li><li><p>完成准备 开始使用（idea自动会引入对应的包）&lt;%@ taglib prefix&#x3D;”c” uri&#x3D;”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</p></li></ol><h3 id="2-标签库的使用"><a href="#2-标签库的使用" class="headerlink" title="2. 标签库的使用"></a>2. 标签库的使用</h3><ul><li><p><strong>Set标签：用于给域对象 进行 数据保存</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">    scope: 在哪个域进行保存</span><br><span class="line">    <span class="keyword">var</span> : 表示 key</span><br><span class="line">    value: 表示 value</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;c:set scope=<span class="string">&quot;request&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;abc&quot;</span> value=<span class="string">&quot;abcValue&quot;</span>&gt;&lt;/c:set&gt;</span><br><span class="line">$&#123;requestScope.abc&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>if标签： 用于做条件判断</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">    test: 判断的条件 (可以使用EL表达式来表示)</span><br><span class="line">    注意: jstl中的<span class="keyword">if</span>标签,只能做一重判断 ,没有 <span class="keyword">if</span>-<span class="keyword">else</span> / <span class="keyword">else</span> </span><br><span class="line">--%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;12 == 12&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;正确&lt;/h1&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>choose,when,otherwise标签：类似于 switch-case-defaule 做判断</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    request.setAttribute(<span class="string">&quot;num&quot;</span>,<span class="number">123</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">    <span class="number">1.</span> when标签的 父元素 必须是 choose标签</span><br><span class="line">    <span class="number">2.</span> 在choose标签里,不能使用html注释,得使用 jsp注释&lt;% %&gt;</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.num&gt;200&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;$&#123;<span class="string">&quot;大于200&quot;</span>&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;requestScope.num&gt;100&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;$&#123;<span class="string">&quot;大于100&quot;</span>&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;h1&gt;小于<span class="number">100</span>&lt;/h1&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>forEach标签：用于遍历</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">    begin: 开始索引</span><br><span class="line">    end: 结束索引</span><br><span class="line">    <span class="keyword">var</span>: 当前索引 以及 当前索引的值</span><br><span class="line">    items: 需要遍历的集合/数组</span><br><span class="line">    step: 遍历的步长(即每次遍历的索引递增)</span><br><span class="line">    varStatus: 当前遍历到的数据的状态(该属性 有许多的方法)</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%--正常遍历--%&gt;</span><br><span class="line">&lt;c:forEach begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;10&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;%--遍历数组--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;array&quot;</span>,array);</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;肇庆&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;map&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;requestScope.array&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">    $&#123;item&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;%--遍历Map集合--%&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;requestScope.map&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">    $&#123;item.key&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/JSTL%E7%9A%84forEach%E7%9A%84varStatus%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95.png"></p></li></ul><h1 id="四、文件的上传与下载"><a href="#四、文件的上传与下载" class="headerlink" title="四、文件的上传与下载"></a>四、文件的上传与下载</h1><h3 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1.文件上传"></a>1.文件上传</h3><ul><li><p><strong>基本使用过程：</strong></p><ul><li><strong>1）在一个form表单中，使用 post提交方式</strong></li><li><strong>2) 设置form表单的 encType属性 为 multpart&#x2F;form-data</strong></li><li><strong>3) 设置 input type&#x3D;file 添加上传的文件</strong></li><li><strong>4) 编写servlet程序 处理 表单提交的表单信息</strong></li></ul></li><li><p><strong>上传的Http协议解析：</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0http%E5%8D%8F%E8%AE%AE%E5%86%85%E5%AE%B9%E8%A7%A3%E6%9E%90.png"></p><ul><li><p><strong>如何在Servlet程序中处理 表单上传的 表单信息（主要是文件）:</strong></p><ol><li><p>引入 第三方jar包 方便处理（<strong>添加失败 可以直接把jar包放到tomcat的lib中</strong>）</p><p><strong>commons-fileupload-1.4.jar</strong></p><p><strong>commons-io-2.11.0.jar</strong></p><p><strong>commons-codec-1.15.jar</strong></p></li><li><p>jar包的常用类方法介绍：</p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6jar%E5%8C%85%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%9501.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/%E6%96%87%E4%BB%B6jar%E5%8C%85%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%9502.png"></p></li><li><p>具体实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1,先判断 表单上传的数据 是不是多段数据</span></span><br><span class="line">        <span class="keyword">if</span>(ServletFileUpload.isMultipartContent(request))&#123;</span><br><span class="line">            <span class="comment">//2. 创建FileItemFactory对象</span></span><br><span class="line">            <span class="type">FileItemFactory</span> <span class="variable">fileItemFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();</span><br><span class="line">            <span class="comment">//3. 创建ServletFileUpload对象</span></span><br><span class="line">            <span class="type">ServletFileUpload</span> <span class="variable">servletFileUpload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(fileItemFactory);</span><br><span class="line">            <span class="comment">//4. 解析表单数据 获取到fileItems的 集合 里面包含所有的表单提交信息</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;FileItem&gt; fileItems = servletFileUpload.parseRequest(request);</span><br><span class="line">                <span class="comment">//5. 遍历fileItems 并判断 每个 fileItem 是普通表单项 还是 文件表单项</span></span><br><span class="line">                <span class="keyword">for</span> (FileItem fileItem : fileItems) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fileItem.isFormField())&#123;</span><br><span class="line">                        <span class="comment">//正常表单项</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;表单项的name属性值为: &quot;</span>+fileItem.getFieldName());</span><br><span class="line">                        <span class="comment">//通过getString() 获取 value值,UTF-8解决中文乱码</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;表单项的value属性值为: &quot;</span>+fileItem.getString(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//文件表单项</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;表单项的name属性值为: &quot;</span>+fileItem.getFieldName());</span><br><span class="line">                        System.out.println(<span class="string">&quot;文件名: &quot;</span>+fileItem.getName());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//把文件保存在本地硬盘中</span></span><br><span class="line">                        fileItem.write(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\&quot;</span>+fileItem.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表单提交不是多端数据,解析失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h3 id="2-文件下载"><a href="#2-文件下载" class="headerlink" title="2.文件下载"></a>2.文件下载</h3><ul><li><p><strong>基本流程：</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p><strong>具体实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//1. 获取需要下载的文件名</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;exam.jpg&quot;</span>;</span><br><span class="line">       <span class="comment">//2. 获取要下载的文件内容</span></span><br><span class="line">       ServletContext servletContext= getServletContext();</span><br><span class="line">       <span class="comment">//3. 获取要下载的文件类型</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> servletContext.getMimeType(<span class="string">&quot;/file/&quot;</span> + fileName);</span><br><span class="line">       System.out.println(<span class="string">&quot;下载的文件类型：&quot;</span>+mimeType);</span><br><span class="line">       <span class="comment">//4. 通过响应头 告诉客户端返回的数据类型</span></span><br><span class="line">       resp.setContentType(mimeType);</span><br><span class="line">       <span class="comment">//5. 通过响应头，告诉客户端 该Servlet程序是下载文件的</span></span><br><span class="line">       <span class="comment">// 通过User-Agent 来判断 是火狐浏览器 还是 其他浏览器 不同的浏览器 的编码不一样</span></span><br><span class="line">       <span class="keyword">if</span>(req.getHeader(<span class="string">&quot;User-Agent&quot;</span>).contains(<span class="string">&quot;Firefox&quot;</span>))&#123;</span><br><span class="line">           <span class="comment">//火狐浏览器 使用 Base64编码</span></span><br><span class="line">           resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment; filename==?UTF-8?B?&quot;</span>+<span class="keyword">new</span> <span class="title class_">Base64</span>().encode(<span class="string">&quot;中国.jpb&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>))+<span class="string">&quot;?=&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//其他浏览器</span></span><br><span class="line">           resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment; filename=&quot;</span>+ URLEncoder.encode(<span class="string">&quot;中国.jpg&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//6. 获取文件的内容 生成输入流</span></span><br><span class="line">       <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> servletContext.getResourceAsStream(<span class="string">&quot;/file/&quot;</span> + fileName);</span><br><span class="line">       <span class="comment">//7. 获取 响应的输出流</span></span><br><span class="line">       <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">       <span class="comment">//8. 通过commons-io.jar 的IOUtils类 进行数据的传输</span></span><br><span class="line">       IOUtils.copy(resourceAsStream,outputStream);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="五、Cookie"><a href="#五、Cookie" class="headerlink" title="五、Cookie"></a>五、Cookie</h1><h3 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><ul><li>cookie 是 <strong>服务器 发送給 客户端 保存键值对的一种技术。</strong></li><li><strong>客户端 拥有了Cookie之后， 每一次的请求 都会发送给 服务端</strong></li><li><strong>每个 Cookie 的大小 不能超过 4kb</strong></li></ul><h3 id="2-Cookie的操作"><a href="#2-Cookie的操作" class="headerlink" title="2.Cookie的操作"></a>2.Cookie的操作</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/Cookie%E5%88%9B%E5%BB%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p><strong>代码实现(创建Cookie)：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   *   创建Cookie</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">createCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException,ServletException &#123;</span><br><span class="line">       <span class="comment">//1. 创建Cookie对象</span></span><br><span class="line">       <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">       <span class="comment">//2. 通知客户端 接收 cookie</span></span><br><span class="line">       response.addCookie(cookie);</span><br><span class="line">       response.getWriter().write(<span class="string">&quot;Cookie创建成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现（获取Cookie）:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 获取Cookie</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">getCookie</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">       <span class="comment">//1. 获取Cookie 数组</span></span><br><span class="line">       Cookie[] cookies = request.getCookies();</span><br><span class="line">       <span class="comment">//2, 遍历输出 或者 查找你需要的 Cookie</span></span><br><span class="line">       <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;cookie的name：&quot;</span>+cookie.getName()+<span class="string">&quot; cookie的值：&quot;</span>+cookie.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现（修改Cookie的值）:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 修改Cookie 的值</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">updateCookie</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">       <span class="comment">//方案一:通过创建新的Cookie(name要相同) 来 修改Cookie值</span></span><br><span class="line">       <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;newValue1&quot;</span>);</span><br><span class="line">       response.addCookie(cookie);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//方案二：先通过resquest获取 cookie数组，找到需要修改的cookie 然后 通过setValue()方法 修改value值 再添加到response</span></span><br><span class="line">       Cookie[] cookies = request.getCookies();</span><br><span class="line">       <span class="type">Cookie</span> <span class="variable">updateCook</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (Cookie cookie1 : cookies) &#123;</span><br><span class="line">           <span class="keyword">if</span>(cookie1.getName().equals(<span class="string">&quot;key1&quot;</span>))&#123;</span><br><span class="line">               cookie1.setValue(<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">               updateCook = cookie1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(updateCook!=<span class="literal">null</span>)&#123;</span><br><span class="line">           response.addCookie(updateCook);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Cookie的生命控制"><a href="#3-Cookie的生命控制" class="headerlink" title="3.Cookie的生命控制"></a>3.Cookie的生命控制</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/Cookie%E7%94%9F%E5%91%BD%E6%8E%A7%E5%88%B6.png"></p><h3 id="4-Cookie的有效路径Path设置"><a href="#4-Cookie的有效路径Path设置" class="headerlink" title="4. Cookie的有效路径Path设置"></a>4. Cookie的有效路径Path设置</h3><ul><li><p><strong>含义：</strong> Cookie 的 path属性 可以有效的判定 哪些Cookie 是需要发送给 服务端的。 有效的过滤不需要的cookie传送。</p></li><li><p><strong>示意图：</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/Cookie%E7%9A%84path%E5%B1%9E%E6%80%A7%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p><strong>设置Cookie的path属性：</strong> <strong>可以使用 cookid.setPath(xxx) 来 设置 cookie的path属性。</strong></p></li></ul><h1 id="六、Seesion"><a href="#六、Seesion" class="headerlink" title="六、Seesion"></a>六、Seesion</h1><h3 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><ul><li>Seesion <strong>是一个对话</strong>， 它是用来维护 <strong>客户端 和 服务端 之间进行关联的 技术。</strong> </li><li><strong>每个客户端 都有一个 自己 Seesion</strong></li><li>通常可以用来 保存 <strong>用户登录后 的信息。</strong></li></ul><h3 id="2-如何创建和获取Session"><a href="#2-如何创建和获取Session" class="headerlink" title="2.如何创建和获取Session"></a>2.如何创建和获取Session</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/Session%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%8E%B7%E5%8F%96.png"></p><h3 id="3-Session-的-存值-与-取值"><a href="#3-Session-的-存值-与-取值" class="headerlink" title="3. Session 的 存值 与 取值"></a>3. Session 的 存值 与 取值</h3><p><strong>主要通过 setAttribute() 与 getAttribute() 实现。</strong></p><h3 id="4-Seesion的生命周期"><a href="#4-Seesion的生命周期" class="headerlink" title="4. Seesion的生命周期"></a>4. Seesion的生命周期</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/session%E7%9A%84%E7%94%9F%E5%91%BD%E6%97%B6%E9%95%BF%E8%AE%BE%E7%BD%AE.png"></p><p><strong>Seesion 的 默认生命时长是 30分钟。</strong> 因为在 tomcat 服务器的 <strong>配置文件 web.xml 中 有以下配置</strong></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/tomcat%E9%85%8D%E7%BD%AEsession%E9%BB%98%E8%AE%A4%E6%97%B6%E9%95%BF.png"></p><p><strong>如果想要修改Seesion的默认时长 可在项目的 web.xml中 配置</strong> 即可。</p><h3 id="5-Seesion-与-浏览器的关系"><a href="#5-Seesion-与-浏览器的关系" class="headerlink" title="5. Seesion  与 浏览器的关系"></a>5. Seesion  与 浏览器的关系</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/session%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E8%81%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p><strong>因此，Seesion 的 本质就是 一个 Cookie。</strong> </p><h1 id="七、Filter过滤器"><a href="#七、Filter过滤器" class="headerlink" title="七、Filter过滤器"></a>七、Filter过滤器</h1><h3 id="1-基本介绍-4"><a href="#1-基本介绍-4" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>Filter 过滤器 是 JavaWeb 的三大组件之一，它主要的作用就是 <strong>拦截请求（常用）、过滤响应。</strong> 常见的应用场景有：<strong>权限检查、事务操作等的。</strong> </p><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h3><p><strong>使用的步骤主要是3步：编写一个类 去 实现Filter接口、在doFilter中去写业务代码、其次在Web.xml中配置 Filter过滤器。</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意： init（） 与 destory（） 方法 尽管不写代码 也要实现 不然会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过doFilter方法 来 判断session中 是否已经存在 用户信息。 有则放行 没有则拦截回到登录页面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(servletRequest,servletResponse);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果已经有登录 则放行 即继续执行 资源路径下的东西</span></span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 web.xml 中 配置Filter --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.jack.learn.filter.LoginFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        表示拦截/admin/ 下的所有资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Filter的生命周期方法"><a href="#3-Filter的生命周期方法" class="headerlink" title="3. Filter的生命周期方法"></a>3. Filter的生命周期方法</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/Filter%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95.png"></p><h3 id="4-FilterConfig类"><a href="#4-FilterConfig类" class="headerlink" title="4. FilterConfig类"></a>4. FilterConfig类</h3><ul><li><p><strong>介绍：</strong> 通过 FilterConfig类 可以 <strong>获取一些 Filter的信息。如 filter-name、init-param 、获取ServletContext 对象。</strong> </p></li><li><p><strong>基本使用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> filterConfig.getFilterName();</span><br><span class="line">      System.out.println(<span class="string">&quot;FilterName：&quot;</span>+filterName);</span><br><span class="line">  </span><br><span class="line">      <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Driver：&quot;</span>+driver);</span><br><span class="line">  </span><br><span class="line">      <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> filterConfig.getServletContext();</span><br><span class="line">      System.out.println(<span class="string">&quot;servletContext：&quot;</span>+servletContext);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-多个Filter的使用关系"><a href="#5-多个Filter的使用关系" class="headerlink" title="5. 多个Filter的使用关系"></a>5. 多个Filter的使用关系</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/%E5%A4%9A%E4%B8%AAFilter%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><h3 id="6-Filter拦截路径"><a href="#6-Filter拦截路径" class="headerlink" title="6. Filter拦截路径"></a>6. Filter拦截路径</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/Filter%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%8401.png"></p><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/Filter%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%8402.png"></p><h1 id="八、JSON"><a href="#八、JSON" class="headerlink" title="八、JSON"></a>八、JSON</h1><h3 id="1-基本介绍-5"><a href="#1-基本介绍-5" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>JSON 是一个轻量级的 数据格式。 <strong>主要用于 客户端 与 服务端 的 之间进行数据传输 的 格式。</strong> </p><h3 id="2-常用方法（JavaScript中）"><a href="#2-常用方法（JavaScript中）" class="headerlink" title="2. 常用方法（JavaScript中）"></a>2. 常用方法（JavaScript中）</h3><ul><li><strong>JSON.stringify（）：</strong> 把 JSON 对象 转化成 字符串类型</li><li><strong>JSON.parse（）：</strong> 把 JSON字符串 转换成 对象。</li></ul><h3 id="3-JSON在-Java中的使用"><a href="#3-JSON在-Java中的使用" class="headerlink" title="3. JSON在 Java中的使用"></a>3. JSON在 Java中的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>(); <span class="comment">//用于json转换的关键类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//JavaBean -》JSON</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">studentJson</span> <span class="operator">=</span> gson.toJson(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JSON -》JavaBean</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">fromStudent</span> <span class="operator">=</span> gson.fromJson(studentJson, student.getClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test02</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Student&gt; studentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;ping&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;kang&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//list -》JSON</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> gson.toJson(studentList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JSON -》List</span></span><br><span class="line">        List&lt;Student&gt; students = gson.fromJson(s, <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;List&lt;Student&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType());</span><br><span class="line">        System.out.println(students);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test03</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Student&gt; studentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        studentMap.put(<span class="string">&quot;1&quot;</span>,<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        studentMap.put(<span class="string">&quot;2&quot;</span>,<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;ping&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        studentMap.put(<span class="string">&quot;3&quot;</span>,<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;kang&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map -&gt; JSON</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> gson.toJson(studentMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Json -&gt; Map</span></span><br><span class="line">        HashMap&lt;String,Student&gt; stringStudentHashMap = gson.fromJson(s, <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;HashMap&lt;String, Student&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType());</span><br><span class="line">        System.out.println(stringStudentHashMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、JSP&quot;&gt;&lt;a href=&quot;#一、JSP&quot; class=&quot;headerlink&quot; title=&quot;一、JSP&quot;&gt;&lt;/a&gt;一、JSP&lt;/h1&gt;&lt;h3 id=&quot;1-什么是JSP？&quot;&gt;&lt;a href=&quot;#1-什么是JSP？&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="-JavaWeb -复习" scheme="http://example.com/tags/JavaWeb-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb复习03</title>
    <link href="http://example.com/2021/09/21/javaWeb%E5%A4%8D%E4%B9%A0/javaWeb%E5%A4%8D%E4%B9%A003/"/>
    <id>http://example.com/2021/09/21/javaWeb%E5%A4%8D%E4%B9%A0/javaWeb%E5%A4%8D%E4%B9%A003/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、AJAX"><a href="#一、AJAX" class="headerlink" title="一、AJAX"></a>一、AJAX</h1><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>AJAX 全称 Asynchroncus JavaScript And Xml 异步 JavaScript 和 Xml。 主要用于 创建 <strong>交互式的 网页开发技术。</strong> 即 可以做到 <strong>局部更新页面的技术。</strong> </p><p><strong>同步与异步：</strong> 当 前端发送请求后 ，<strong>必须等 后端 发送数据到前端后 才能 继续执行 下面的代码</strong>。而 <strong>异步 则不需要等待</strong>，直接执行 下面的代码。</p><h3 id="2-原生JavaScript使用AJAX"><a href="#2-原生JavaScript使用AJAX" class="headerlink" title="2. 原生JavaScript使用AJAX"></a>2. 原生JavaScript使用AJAX</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AJAXServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前端发来请求&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传输数据给前端</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;test/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;伟杰&quot;</span>);</span><br><span class="line">        <span class="comment">//把对象 封装成 json字符串  传递给前端</span></span><br><span class="line">        <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">stuStr</span> <span class="operator">=</span> gson.toJson(student);</span><br><span class="line">        <span class="comment">//传输数据</span></span><br><span class="line">        response.getWriter().write(stuStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        function <span class="title function_">AXAJRequest</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//1. 创建 XMLHttpRequest</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            <span class="comment">//2. 使用 open 方法设置请求参数</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 参数1： 什么方式请求</span></span><br><span class="line"><span class="comment">            * 参数2：请求地址</span></span><br><span class="line"><span class="comment">            * 参数3：是否异步请求</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            request.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://localhost:8080/AJAXDemo/ajax&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//3. 先接收从 后端传来的数据</span></span><br><span class="line">            request.onreadystatechange = function ()&#123;</span><br><span class="line">                <span class="comment">//只有这种状态 才算正常接收到 数据</span></span><br><span class="line">                <span class="keyword">if</span>(request.readyState==<span class="number">4</span> &amp;&amp; request.status==<span class="number">200</span>)&#123;</span><br><span class="line">                    <span class="comment">//把 后端数据 封装成 json对象</span></span><br><span class="line">                    <span class="type">var</span> <span class="variable">jsonObj</span> <span class="operator">=</span> JSON.parse(request.responseText);</span><br><span class="line">                    <span class="comment">//把Json 输出到 div中</span></span><br><span class="line">                    document.getElementById(<span class="string">&quot;div01&quot;</span>).innerHTML=<span class="string">&quot;id: &quot;</span>+jsonObj.id+<span class="string">&quot; name：&quot;</span>+jsonObj.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4. 发送请求</span></span><br><span class="line">            request.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-Jquery使用Ajax"><a href="#3-Jquery使用Ajax" class="headerlink" title="3. Jquery使用Ajax"></a>3. Jquery使用Ajax</h3><ul><li><p>JQuery 使用 Ajax 主要有四个方法： <strong>$.ajax、$.get、$.post、$.getJSON</strong> </p></li><li><p><strong>演示：</strong> </p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$(<span class="string">&quot;#ajax_btn&quot;</span>).click(function ()&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url:<span class="string">&quot;http://localhost:8080/AJAXDemo/ajax&quot;</span>,</span><br><span class="line">                    type:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">                    <span class="comment">//传输的格式有两种</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * name1=value1&amp;name2=value2</span></span><br><span class="line"><span class="comment">                    * &#123;name1=value1,name2=value2&#125;</span></span><br><span class="line"><span class="comment">                    * */</span></span><br><span class="line">                    data:<span class="literal">null</span>,</span><br><span class="line">                    <span class="comment">//接收 后端传来的数据</span></span><br><span class="line">                    success:function (data)&#123;</span><br><span class="line">                        $(<span class="string">&quot;#show&quot;</span>).html(<span class="string">&quot;ajax 编号：&quot;</span>+data.id+<span class="string">&quot; 姓名：&quot;</span>+data.name);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">//后端返回的类型：text、xml、json</span></span><br><span class="line">                    dataType:<span class="string">&quot;json&quot;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#get_btn&quot;</span>).click(function ()&#123;</span><br><span class="line">              <span class="comment">//get 或 post方法 比ajax方式 少了个 type的参数</span></span><br><span class="line">              $.get(<span class="string">&quot;http://localhost:8080/AJAXDemo/ajax&quot;</span>,<span class="literal">null</span>,function (data)&#123;</span><br><span class="line">                  $(<span class="string">&quot;#show&quot;</span>).html(<span class="string">&quot;get 编号：&quot;</span>+data.id+<span class="string">&quot; 姓名：&quot;</span>+data.name);</span><br><span class="line">              &#125;,<span class="string">&quot;json&quot;</span>)</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#json_btn&quot;</span>).click(function ()&#123;</span><br><span class="line">                <span class="comment">//getJSON方法 比 get/post 少了 dataType参数</span></span><br><span class="line">                $.getJSON(<span class="string">&quot;http://localhost:8080/AJAXDemo/ajax&quot;</span>,<span class="literal">null</span>,function (data)&#123;</span><br><span class="line">                    $(<span class="string">&quot;#show&quot;</span>).html(<span class="string">&quot;get 编号：&quot;</span>+data.id+<span class="string">&quot; 姓名：&quot;</span>+data.name);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>表单提交格式 serialize()方法的使用：</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">&quot;ajax_form&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userName&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;login()&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//$(&quot;#ajax_form&quot;).serialize() 方法 ： 可以把 表单里的每个输入项 变成 name1=value1&amp;name2=value2的形式。 方便了 ajax 对 后端的数据传输。</span></span><br><span class="line">function <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">            $.getJSON(<span class="string">&quot;http://localhost:8080/AJAXDemo/ajax&quot;</span>,$(<span class="string">&quot;#ajax_form&quot;</span>).serialize(),function (data)&#123;</span><br><span class="line">                alert(data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二、i18n国际化"><a href="#二、i18n国际化" class="headerlink" title="二、i18n国际化"></a>二、i18n国际化</h1><h3 id="1-基本介绍："><a href="#1-基本介绍：" class="headerlink" title="1. 基本介绍："></a><strong>1. 基本介绍：</strong></h3><p>当不同的国家 访问 同一个网站时，<strong>可以根据 不同语言的人 得到 对应语言的网站。这就是 国家化。</strong> </p><h3 id="2-国际化三要素："><a href="#2-国际化三要素：" class="headerlink" title="2. 国际化三要素："></a>2. 国际化三要素：</h3><p><img src="/JavaWeb%E5%A4%8D%E4%B9%A0/i18n%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%89%E8%A6%81%E7%B4%A0.png"></p><h3 id="3-通过请求头实现国际化"><a href="#3-通过请求头实现国际化" class="headerlink" title="3.  通过请求头实现国际化"></a>3.  通过请求头实现国际化</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//创建一个 local对象</span></span><br><span class="line">    <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">lan</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;lan&quot;</span>);</span><br><span class="line">    <span class="comment">//根据地址栏 不同的语言 使用 不同的语言</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;cn&quot;</span>.equals(lan))&#123;</span><br><span class="line">        locale = Locale.CHINA; </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;us&quot;</span>.equals(lan))&#123;</span><br><span class="line">        locale = Locale.US;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取本地的locale信息</span></span><br><span class="line">        locale = request.getLocale();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ResourceBundle</span> <span class="variable">i18n</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;i18n&quot;</span>, locale);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;index.jsp?lan=cn&quot;</span>&gt;中文&lt;/a&gt;|</span><br><span class="line">&lt;a href=<span class="string">&quot;index.jsp?lan=us&quot;</span>&gt;english&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;p&gt;&lt;%=i18n.getString(<span class="string">&quot;username&quot;</span>)%&gt;&lt;/p&gt;&lt;br/&gt;</span><br><span class="line">&lt;p&gt;&lt;%=i18n.getString(<span class="string">&quot;password&quot;</span>)%&gt;&lt;/p&gt;&lt;br/&gt;</span><br><span class="line">&lt;p&gt;&lt;%=i18n.getString(<span class="string">&quot;age&quot;</span>)%&gt;&lt;/p&gt;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">i18n_en_US.properties文件(注意</span> <span class="string">peoperties文件 放到 resources文件夹中)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">username</span>=<span class="string">username</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">password</span></span><br><span class="line"><span class="attr">age</span>=<span class="string">age</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">i18n_zh_CN.properties文件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">username</span>=<span class="string">用户名</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">密码</span></span><br><span class="line"><span class="attr">age</span>=<span class="string">年龄</span></span><br></pre></td></tr></table></figure><h3 id="4-使用JSTL标签库实现国际化"><a href="#4-使用JSTL标签库实现国际化" class="headerlink" title="4. 使用JSTL标签库实现国际化"></a>4. 使用JSTL标签库实现国际化</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/fmt&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 设置 locale 信息 --&gt;</span><br><span class="line">&lt;fmt:setLocale value=<span class="string">&quot;$&#123;param.lan&#125;&quot;</span>&gt;&lt;/fmt:setLocale&gt;</span><br><span class="line">&lt;!-- 设置baseName --&gt;</span><br><span class="line">&lt;fmt:setBundle basename=<span class="string">&quot;i18n&quot;</span>&gt;&lt;&lt;/fmt:setBundle&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;index.jsp?lan=zh_CN&quot;</span>&gt;中文&lt;/a&gt;|</span><br><span class="line">&lt;a href=<span class="string">&quot;index.jsp?lan=en_US&quot;</span>&gt;english&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">  &lt;!-- 输出信息 --&gt;</span><br><span class="line">&lt;p&gt;&lt;fmt:message key=<span class="string">&quot;username&quot;</span>&gt;&lt;/p&gt;&lt;br/&gt;</span><br><span class="line">&lt;p&gt;&lt;fmt:message key=<span class="string">&quot;password&quot;</span>&gt;&lt;/p&gt;&lt;br/&gt;</span><br><span class="line">&lt;p&gt;&lt;fmt:message key=<span class="string">&quot;age&quot;</span>&gt;&lt;/p&gt;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、AJAX&quot;&gt;&lt;a href=&quot;#一、AJAX&quot; class=&quot;headerlink&quot; title=&quot;一、AJAX&quot;&gt;&lt;/a&gt;一、AJAX&lt;/h1&gt;&lt;h3 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="-Java -Web" scheme="http://example.com/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>Java复习-1</title>
    <link href="http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-1/"/>
    <id>http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-1/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-09-21T04:20:46.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-JDK-JRE-JVM-三者之间的关系"><a href="#1-JDK-JRE-JVM-三者之间的关系" class="headerlink" title="1.JDK,JRE,JVM 三者之间的关系"></a>1.JDK,JRE,JVM 三者之间的关系</h3><ul><li><p><strong>JDK: 俗称Java工具包 里面包含有JRE和JVM 没有JDK java就不能运行</strong></p></li><li><p><strong>JRE：里面包含有JVM 以及各种 Java各种的类包方法</strong></p></li><li><p><strong>JVM：又称为Java虚拟机 主要负责java文件的运行功能</strong></p></li></ul><h3 id="2-类型转换细节"><a href="#2-类型转换细节" class="headerlink" title="2.类型转换细节"></a>2.类型转换细节</h3><p><strong>需要强制转换的类型：int类型 -》short类型、int-&gt;byte、byte-&gt;short</strong></p><h3 id="3-短路与-或-、逻辑与-或"><a href="#3-短路与-或-、逻辑与-或" class="headerlink" title="3.短路与&amp;  | 或 | 、逻辑与&amp;&amp; | 或 ||"></a>3.短路与&amp;  | 或 | 、逻辑与&amp;&amp; | 或 ||</h3><p><strong>1. 短路和逻辑的区别</strong></p><ul><li><p><strong>短路：当符合条件时，会强制结束掉剩余的条件判定。直接执行结果。</strong></p></li><li><p><strong>逻辑：不管前面的条件符合与否，都会 全部 执行完条件再判定结果</strong></p></li></ul><h3 id="4-进制转换"><a href="#4-进制转换" class="headerlink" title="4.进制转换"></a>4.进制转换</h3><p>1.<strong>二、八、十六 进制 转 十进制</strong></p><ul><li><p><strong>规则：二进制 0b开头，十六进制 0x 开头，八进制02开头.    在十六进制中，A&#x3D;10 其他则往后带入就行 B&#x3D;11</strong></p></li><li><p><strong>方法：从最低位（最右边），将每个数的数提取出来，乘以 被转化的进制数 的 （位数-1）次方，然后求和</strong></p></li><li><p><strong>例子：二进制转十进制-》 0b1011的十进制是 1<em>2^0 + 1</em>2^1+1*2^3 &#x3D;  11 其他进制一样</strong></p></li></ul><p>2.<strong>十进制 转 二、八、十六进制</strong></p><ul><li><strong>当十进制 转 二进制时 需要补0 补到十位数</strong></li><li><strong>方法：对<em>十进制数</em> 进行除法运算 对该数除以要转的进制数字 直到商为0 然后把余数倒过来</strong></li><li><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.png"></li></ul><p>3.<strong>二进制 转 八、十六进制</strong></p><ul><li><p><strong>规则</strong></p><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99.png"></p></li><li><p><strong>转八进制：从最低位开始，把三位组成一组，转成对应的八进制即可。如 1101 代表的 八位进制数 是1+（这里的+号 是拼接的意思）（5）&#x3D; 15&#x3D;D</strong></p></li><li><p><strong>转十六进制：从最低位开始，把四位组成一组，转成对应的十六进制即可 如 0b11010101 -&gt; 0x(13&#x3D;D)+(5)-&gt;0xD5</strong></p></li></ul><p>4.<strong>八、十六进制 转 二进制</strong></p><ul><li><strong>八-》二：把八进制的每一位数 转为 三位数的二进制即可。 如 01230 -》 (001)(010)(011)</strong></li><li><strong>十六-》二：把八进制的每一位数 转为 四位数的二进制即可。如0x23B-》(0010)(0011)(1011)-&gt;0b001000111011</strong></li></ul><h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5.位运算符"></a>5.位运算符</h3><p><strong>1.运算法符</strong></p><ul><li><strong>按位与(&amp;)：两位都是 1，结果则为1 反则为0</strong></li><li><strong>按位或(|)：两位其中有一位是1 ，结果为1 反则为0</strong></li><li><strong>按位异或(^)：两位一个为0，一个为1 结果为1 反则为0</strong></li><li><strong>按位取反(~)：0-&gt;1,1-&gt;0</strong></li><li><strong>算术右移(&gt;&gt;)：低位溢出，符号位不变，并用符号位补溢出的高位</strong></li><li><strong>算术左移(&lt;&lt;)：符号位不变，低位补0</strong></li><li><strong>逻辑右移(&gt;&gt;&gt;)：低位溢出，高位补0</strong></li></ul><p><strong>2. 使用举例</strong></p><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E6%BC%94%E7%BB%83.png"></p><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB.png"></p><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E7%AE%97%E6%9C%AF%E5%B7%A6%E7%A7%BB.png"></p><h3 id="6-源码、反码、补码"><a href="#6-源码、反码、补码" class="headerlink" title="6.源码、反码、补码"></a>6.源码、反码、补码</h3><ul><li><p><strong>二进制的最高位 是 符号位（0是正数，1是负数）</strong></p></li><li><p><strong>正数的反码、补码、原码都一样（三码合一）</strong></p></li><li><p><strong>负数的补码 &#x3D; 它的反码+1 ， 负数的反码 &#x3D; 负数的补码 -1</strong></p></li><li><p><strong>负数的反码 &#x3D; 它的符号位不变，其它位取反</strong></p></li><li><p><strong>0的反码，补码都是 0</strong></p></li><li><p><strong>在计算机运行的时候，都是以 补码 的方式进行</strong></p></li><li><p><strong>当我们看结果时，需要看它的原码</strong></p></li></ul><h3 id="7-对象的存储布局"><a href="#7-对象的存储布局" class="headerlink" title="7.对象的存储布局"></a>7.对象的存储布局</h3><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p><ul><li><strong>java中的对象 是 根据jvm的内存方式进行存储的，存储布局中 有 栈、堆、方法区。</strong></li><li><strong>栈用来存储对象（并赋予一个地址来指定 堆中 那一组是该对象的属性）。</strong></li><li><strong>堆 用来存放 基本类型（如 int）类型的 内容 以及 特殊类型（String类型）的特有地址</strong></li><li><strong>方法区 则用来存储 由堆的特殊类型地址 指定 的 内容，以及 对象的行为（即方法）</strong></li></ul><h3 id="8-方法重载"><a href="#8-方法重载" class="headerlink" title="8.方法重载"></a>8.方法重载</h3><ul><li><h4 id="含义：方法名一样-但是-传入的参数不一样-就叫-方法重载。-如-cat-int-num-与-cat-String-name-是合法的-为重载方法"><a href="#含义：方法名一样-但是-传入的参数不一样-就叫-方法重载。-如-cat-int-num-与-cat-String-name-是合法的-为重载方法" class="headerlink" title="含义：方法名一样 但是 传入的参数不一样  就叫 方法重载。   如 cat(int num) 与 cat(String name) 是合法的 为重载方法"></a>含义：方法名一样 但是 传入的参数不一样  就叫 方法重载。   如 cat(int num) 与 cat(String name) 是合法的 为重载方法</h4></li><li><h4 id="使用细节："><a href="#使用细节：" class="headerlink" title="使用细节："></a>使用细节：</h4><ul><li><h5 id="方法名-必须相同"><a href="#方法名-必须相同" class="headerlink" title="方法名 必须相同"></a>方法名 必须相同</h5></li><li><h5 id="各个重载方法-的-形参列表-必须-不同-（个数-或者-顺序-至少要其中一样不相同-）"><a href="#各个重载方法-的-形参列表-必须-不同-（个数-或者-顺序-至少要其中一样不相同-）" class="headerlink" title="各个重载方法 的 形参列表 必须 不同 （个数 或者 顺序 至少要其中一样不相同 ）"></a>各个重载方法 的 形参列表 必须 不同 （个数 或者 顺序 至少要其中一样不相同 ）</h5></li><li><h5 id="返回类型-无要求"><a href="#返回类型-无要求" class="headerlink" title="返回类型 无要求"></a>返回类型 无要求</h5></li></ul></li></ul><h3 id="9-可变参数"><a href="#9-可变参数" class="headerlink" title="9.可变参数"></a>9.可变参数</h3><ul><li><h4 id="含义：可以理解为-方法重载的优化-既-可通过特殊的写法-让传参方便-如-cat-int…-nums-表示-cat方法-可传多个-int类型的参数-而-nums-为-数组-可用数组的方法-来获取-具体的实参数值"><a href="#含义：可以理解为-方法重载的优化-既-可通过特殊的写法-让传参方便-如-cat-int…-nums-表示-cat方法-可传多个-int类型的参数-而-nums-为-数组-可用数组的方法-来获取-具体的实参数值" class="headerlink" title="含义：可以理解为 方法重载的优化 既 可通过特殊的写法 让传参方便 如 cat(int… nums)  &#x2F;&#x2F;表示 cat方法 可传多个 int类型的参数 而 nums 为 数组 可用数组的方法 来获取 具体的实参数值"></a>含义：可以理解为 方法重载的优化 既 可通过特殊的写法 让传参方便 如 cat(int… nums)  &#x2F;&#x2F;表示 cat方法 可传多个 int类型的参数 而 nums 为 数组 可用数组的方法 来获取 具体的实参数值</h4></li><li><h4 id="使用细节：-1"><a href="#使用细节：-1" class="headerlink" title="使用细节："></a>使用细节：</h4><ul><li><h5 id="可变参数的实参-可以为-0-个-或者-多个"><a href="#可变参数的实参-可以为-0-个-或者-多个" class="headerlink" title="可变参数的实参 可以为 0 个 或者 多个"></a>可变参数的实参 可以为 0 个 或者 多个</h5></li><li><p><strong>可变参数的实参 可以是 数组</strong></p></li><li><p><strong>可变参数的本质 就是 数组</strong></p></li><li><h5 id="可变参数可以-和-普通类型的参数-一起放在形参列表中，但必须保证可变参数-在-最后-如-cat-string-s-int…-nums"><a href="#可变参数可以-和-普通类型的参数-一起放在形参列表中，但必须保证可变参数-在-最后-如-cat-string-s-int…-nums" class="headerlink" title="可变参数可以 和 普通类型的参数 一起放在形参列表中，但必须保证可变参数 在 最后 如 cat(string s,int… nums)"></a>可变参数可以 和 普通类型的参数 一起放在形参列表中，但必须保证可变参数 在 最后 如 cat(string s,int… nums)</h5></li><li><h5 id="一个形参列表中-只能出现-一个-可变参数"><a href="#一个形参列表中-只能出现-一个-可变参数" class="headerlink" title="一个形参列表中 只能出现 一个 可变参数"></a>一个形参列表中 只能出现 一个 可变参数</h5></li></ul></li></ul><h3 id="10-构造器"><a href="#10-构造器" class="headerlink" title="10.构造器"></a>10.构造器</h3><ul><li><h4 id="含义：在创造对象的时候-，可以通过进行传参的方式来给对象中的属性赋值。-也可以在构造器中-自己进行赋值"><a href="#含义：在创造对象的时候-，可以通过进行传参的方式来给对象中的属性赋值。-也可以在构造器中-自己进行赋值" class="headerlink" title="含义：在创造对象的时候 ，可以通过进行传参的方式来给对象中的属性赋值。 也可以在构造器中 自己进行赋值"></a>含义：在创造对象的时候 ，可以通过进行传参的方式来给对象中的属性赋值。 也可以在构造器中 自己进行赋值</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E6%9E%84%E9%80%A0%E5%99%A81.png"></p><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E6%9E%84%E9%80%A0%E5%99%A82.png"></p></li><li><h4 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h4><ul><li><strong>构造器 和 类名必须相同</strong></li><li><strong>构造器是完成对象的初始化 而非创建对象</strong></li><li><strong>如果我们没有 定义构造器 系统则会 自动给类 生成一个无参的默认构造器 既 person();</strong></li><li><strong>一旦 定义了构造器 则默认的构造器就会被覆盖 除非 我们自己写一个 默认的构造器</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-JDK-JRE-JVM-三者之间的关系&quot;&gt;&lt;a href=&quot;#1-JDK-JRE-JVM-三者之间的关系&quot; class=&quot;headerlink&quot; title=&quot;1.JDK,JRE,JVM 三者之间的关系&quot;&gt;&lt;/a&gt;1.JDK,JRE,JVM 三者之间的关系&lt;/</summary>
      
    
    
    
    
    <category term="-Java -复习" scheme="http://example.com/tags/Java-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java复习-4</title>
    <link href="http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-4/"/>
    <id>http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-4/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-09-21T04:26:09.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java绘图"><a href="#1-Java绘图" class="headerlink" title="1. Java绘图"></a>1. Java绘图</h3><ul><li><h4 id="1-绘图坐标体系"><a href="#1-绘图坐标体系" class="headerlink" title="(1) 绘图坐标体系"></a>(1) 绘图坐标体系</h4><h5 id="坐标原点位于-左上角，以像素为单位。"><a href="#坐标原点位于-左上角，以像素为单位。" class="headerlink" title="坐标原点位于 左上角，以像素为单位。"></a>坐标原点位于 左上角，以像素为单位。</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB.png"></p></li><li><h4 id="2-绘图入门"><a href="#2-绘图入门" class="headerlink" title="(2) 绘图入门"></a>(2) 绘图入门</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让类 继承 JFrame（窗体）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyPanel mp=<span class="literal">null</span>;  <span class="comment">//面板对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建一个 面板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span>&#123;</span><br><span class="line">    <span class="comment">//重写paint方法：用于画图</span></span><br><span class="line">    <span class="comment">//Graphics g:相当于 画笔的功能</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.paint(g);</span><br><span class="line">            g.drawOval(<span class="number">10</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">40</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造方法 :执行 添加组件 和 设置窗体的作用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        mp=<span class="keyword">new</span> <span class="title class_">MyPanel</span>();</span><br><span class="line">        <span class="comment">//给窗体 设置大小</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(mp);</span><br><span class="line">        <span class="comment">//设置是否可见</span></span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//设置 点击x 关闭程序</span></span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="3-绘图方法"><a href="#3-绘图方法" class="headerlink" title="(3) 绘图方法"></a>(3) 绘图方法</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E7%BB%98%E5%9B%BE%E6%96%B9%E6%B3%95.png"></p></li></ul><h3 id="2-Java事件处理"><a href="#2-Java事件处理" class="headerlink" title="2.Java事件处理"></a>2.Java事件处理</h3><p><img src="/images/Java%E5%A4%8D%E4%B9%A0/java%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><ul><li><h4 id="1-基本说明：java事件处理-采取-“委派事件模型”-既，当事件发生的时候，会产生事件的对象（如-keyEvent-e）-会把该-“信息”-交给-“事件监听器去处理”-如-KeyListener-。"><a href="#1-基本说明：java事件处理-采取-“委派事件模型”-既，当事件发生的时候，会产生事件的对象（如-keyEvent-e）-会把该-“信息”-交给-“事件监听器去处理”-如-KeyListener-。" class="headerlink" title="(1) 基本说明：java事件处理 采取 “委派事件模型” 既，当事件发生的时候，会产生事件的对象（如 keyEvent e）, 会把该 “信息” 交给 “事件监听器去处理”(如 KeyListener) 。"></a>(1) 基本说明：java事件处理 采取 “委派事件模型” 既，当事件发生的时候，会产生事件的对象（如 keyEvent e）, 会把该 “信息” 交给 “事件监听器去处理”(如 KeyListener) 。</h4></li><li><h4 id="2-详细说明："><a href="#2-详细说明：" class="headerlink" title="(2) 详细说明："></a>(2) 详细说明：</h4><ul><li><h5 id="1-事件源：是一个产生事件的对象-可以是一个窗口、按钮-或是-键盘上的一个键"><a href="#1-事件源：是一个产生事件的对象-可以是一个窗口、按钮-或是-键盘上的一个键" class="headerlink" title="1.事件源：是一个产生事件的对象 可以是一个窗口、按钮 或是 键盘上的一个键"></a>1.事件源：是一个产生事件的对象 可以是一个窗口、按钮 或是 键盘上的一个键</h5></li><li><h5 id="2-事件：根据-事件源状态-改变时的对象，如-鼠标事件、键盘事件、窗口事件等等。-会产生一个事件对象-既如KeyEvent，里面承载着各种定义的方法"><a href="#2-事件：根据-事件源状态-改变时的对象，如-鼠标事件、键盘事件、窗口事件等等。-会产生一个事件对象-既如KeyEvent，里面承载着各种定义的方法" class="headerlink" title="2.事件：根据 事件源状态 改变时的对象，如 鼠标事件、键盘事件、窗口事件等等。 会产生一个事件对象 既如KeyEvent，里面承载着各种定义的方法"></a>2.事件：根据 事件源状态 改变时的对象，如 鼠标事件、键盘事件、窗口事件等等。 会产生一个事件对象 既如KeyEvent，里面承载着各种定义的方法</h5></li><li><h5 id="3-事件类型："><a href="#3-事件类型：" class="headerlink" title="3.事件类型："></a>3.事件类型：</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/java%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B.png"></p></li><li><h5 id="4-事件监听器接口："><a href="#4-事件监听器接口：" class="headerlink" title="4.事件监听器接口："></a>4.事件监听器接口：</h5><ul><li><h5 id="1-：当事件源产生事件时，可以传送给-事件监听器去处理-如-keyListener"><a href="#1-：当事件源产生事件时，可以传送给-事件监听器去处理-如-keyListener" class="headerlink" title="1)：当事件源产生事件时，可以传送给 事件监听器去处理 如 keyListener"></a>1)：当事件源产生事件时，可以传送给 事件监听器去处理 如 keyListener</h5></li><li><h5 id="2-：一个类-可以-实现多个监听接口"><a href="#2-：一个类-可以-实现多个监听接口" class="headerlink" title="2)：一个类 可以 实现多个监听接口"></a>2)：一个类 可以 实现多个监听接口</h5></li></ul></li></ul></li></ul><h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><ul><li><h4 id="1-概念说明"><a href="#1-概念说明" class="headerlink" title="(1) 概念说明"></a>(1) 概念说明</h4><ul><li><h5 id="1-进程：进程是指-运行中的程序，例如-开启了QQ，就是启动了一个进程。-操作系统会为它分配内存空间。-进程-就是-程序的一次运行过程，或是正在运行的程序，有它自身的-产生、存在、消亡。"><a href="#1-进程：进程是指-运行中的程序，例如-开启了QQ，就是启动了一个进程。-操作系统会为它分配内存空间。-进程-就是-程序的一次运行过程，或是正在运行的程序，有它自身的-产生、存在、消亡。" class="headerlink" title="1) 进程：进程是指 运行中的程序，例如 开启了QQ，就是启动了一个进程。 操作系统会为它分配内存空间。 进程 就是 程序的一次运行过程，或是正在运行的程序，有它自身的 产生、存在、消亡。"></a>1) 进程：进程是指 运行中的程序，例如 开启了QQ，就是启动了一个进程。 操作系统会为它分配内存空间。 进程 就是 程序的一次运行过程，或是正在运行的程序，有它自身的 产生、存在、消亡。</h5></li><li><h5 id="2-线程"><a href="#2-线程" class="headerlink" title="2) 线程:"></a>2) 线程:</h5><ul><li><h5 id="单线程：在同一时刻，只允许执行-一个线程。"><a href="#单线程：在同一时刻，只允许执行-一个线程。" class="headerlink" title="单线程：在同一时刻，只允许执行 一个线程。"></a>单线程：在同一时刻，只允许执行 一个线程。</h5></li><li><h5 id="双线程：在同一时刻，可以执行多个线程。"><a href="#双线程：在同一时刻，可以执行多个线程。" class="headerlink" title="双线程：在同一时刻，可以执行多个线程。"></a>双线程：在同一时刻，可以执行多个线程。</h5></li></ul></li><li><h5 id="3-并发：在同一时刻，多个任务-交替执行-，造成一种-同时进行的假象。简单的说，就是-单核CPU-实现的多任务-并发。"><a href="#3-并发：在同一时刻，多个任务-交替执行-，造成一种-同时进行的假象。简单的说，就是-单核CPU-实现的多任务-并发。" class="headerlink" title="3) 并发：在同一时刻，多个任务 交替执行  ，造成一种 同时进行的假象。简单的说，就是 单核CPU 实现的多任务 并发。"></a>3) 并发：在同一时刻，多个任务 <em>交替执行</em>  ，造成一种 同时进行的假象。简单的说，就是 单核CPU 实现的多任务 并发。</h5></li><li><h5 id="4-并行：在同一时刻，多个任务-同时执行-既-多核CPU-可以实现并行。"><a href="#4-并行：在同一时刻，多个任务-同时执行-既-多核CPU-可以实现并行。" class="headerlink" title="4) 并行：在同一时刻，多个任务 同时执行  , 既 多核CPU 可以实现并行。"></a>4) 并行：在同一时刻，多个任务 <em>同时执行</em>  , 既 多核CPU 可以实现并行。</h5></li></ul></li><li><h4 id="2-线程基本使用"><a href="#2-线程基本使用" class="headerlink" title="(2) 线程基本使用"></a>(2) 线程基本使用</h4><ul><li><h5 id="1-继承-Thread-创建线程"><a href="#1-继承-Thread-创建线程" class="headerlink" title="1) 继承 Thread 创建线程"></a>1) 继承 Thread 创建线程</h5><ul><li><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Cat cat=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">//开启进程 会自动执行 cat中的 run方法。</span></span><br><span class="line">        cat.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Thread类 ，可把该类当成进程使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> times=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//run方法主要处理 线程的逻辑处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(times&lt;<span class="number">8</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;喵喵&quot;</span>+(++times));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="多线程的机制"><a href="#多线程的机制" class="headerlink" title="多线程的机制"></a>多线程的机制</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E6%A1%88%E4%BE%8B%E8%BF%9B%E8%A1%8C%E5%9B%BE01.png"></p><h5 id="在本案例中，当运行时，就产生了一个进程。main（）方法-就是进程中的-一个线程，而在main（）方法中，又执行了Thread-0-的线程。并且，两线程之间是互不打扰执行的。-既main（）方法的-线程-结束，不会干扰-Thread-0线程。两线程是-同时进行的。"><a href="#在本案例中，当运行时，就产生了一个进程。main（）方法-就是进程中的-一个线程，而在main（）方法中，又执行了Thread-0-的线程。并且，两线程之间是互不打扰执行的。-既main（）方法的-线程-结束，不会干扰-Thread-0线程。两线程是-同时进行的。" class="headerlink" title="在本案例中，当运行时，就产生了一个进程。main（）方法 就是进程中的 一个线程，而在main（）方法中，又执行了Thread-0 的线程。并且，两线程之间是互不打扰执行的。 既main（）方法的 线程 结束，不会干扰 Thread-0线程。两线程是 同时进行的。"></a>在本案例中，当运行时，就产生了一个进程。main（）方法 就是进程中的 一个线程，而在main（）方法中，又执行了Thread-0 的线程。并且，两线程之间是互不打扰执行的。 既main（）方法的 线程 结束，不会干扰 Thread-0线程。两线程是 同时进行的。</h5></li><li><h5 id="start（）方法-详解"><a href="#start（）方法-详解" class="headerlink" title="start（）方法 详解"></a>start（）方法 详解</h5><h5 id="分析-源码可知，start（）底层-主要实现-线程开启功能的是-start0-方法。-而-start0（）-方法是由-JVM-调用的。当start（）方法-调用了-start0（）方法后-，-该线程并不会立刻执行，只是将-线程变成-一种-可运行的状态。-具体什么时候运行，取决于-CPU。"><a href="#分析-源码可知，start（）底层-主要实现-线程开启功能的是-start0-方法。-而-start0（）-方法是由-JVM-调用的。当start（）方法-调用了-start0（）方法后-，-该线程并不会立刻执行，只是将-线程变成-一种-可运行的状态。-具体什么时候运行，取决于-CPU。" class="headerlink" title="分析 源码可知，start（）底层 主要实现 线程开启功能的是 start0() 方法。 而 start0（） 方法是由 JVM 调用的。当start（）方法 调用了 start0（）方法后 ， 该线程并不会立刻执行，只是将 线程变成 一种 可运行的状态。 具体什么时候运行，取决于 CPU。"></a>分析 源码可知，start（）底层 主要实现 线程开启功能的是 start0() 方法。 而 start0（） 方法是由 JVM 调用的。当start（）方法 调用了 start0（）方法后 ， 该线程并不会立刻执行，只是将 线程变成 一种 可运行的状态。 具体什么时候运行，取决于 CPU。</h5></li></ul></li><li><h5 id="2-实现Runnable-实现线程"><a href="#2-实现Runnable-实现线程" class="headerlink" title="2) 实现Runnable 实现线程"></a>2) 实现Runnable 实现线程</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableExercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hi hi=<span class="keyword">new</span> <span class="title class_">Hi</span>();</span><br><span class="line">        <span class="comment">//需要用到 Thread 对象来接受 Runnable 的线程，以此来实现 线程方法</span></span><br><span class="line">        Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(hi);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 实现 Runnable接口 进行线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hi</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> account=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello,World！&quot;</span>+(++account));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="3-Runnable-与-Thread-实现线程的区别"><a href="#3-Runnable-与-Thread-实现线程的区别" class="headerlink" title="3) Runnable 与 Thread 实现线程的区别"></a>3) Runnable 与 Thread 实现线程的区别</h5><ul><li><h5 id="两者本质上-是没有区别的。-但实际上，推荐用-实现Runnable接口的方式-进行线程操作。因为-，这有利于线程类可以继承其它的类，也有利于-适合多线程共享一个资源的情况。"><a href="#两者本质上-是没有区别的。-但实际上，推荐用-实现Runnable接口的方式-进行线程操作。因为-，这有利于线程类可以继承其它的类，也有利于-适合多线程共享一个资源的情况。" class="headerlink" title="两者本质上 是没有区别的。 但实际上，推荐用 实现Runnable接口的方式 进行线程操作。因为 ，这有利于线程类可以继承其它的类，也有利于 适合多线程共享一个资源的情况。"></a>两者本质上 是没有区别的。 但实际上，推荐用 实现Runnable接口的方式 进行线程操作。因为 ，这有利于线程类可以继承其它的类，也有利于 适合多线程共享一个资源的情况。</h5></li></ul></li></ul></li><li><h4 id="3-线程的控制"><a href="#3-线程的控制" class="headerlink" title="(3) 线程的控制"></a>(3) 线程的控制</h4><ul><li><h5 id="1-线程中止"><a href="#1-线程中止" class="headerlink" title="1) 线程中止"></a>1) 线程中止</h5><ul><li><h5 id="1-线程-在执行完-run方法后，会自动的中止"><a href="#1-线程-在执行完-run方法后，会自动的中止" class="headerlink" title="1. 线程 在执行完 run方法后，会自动的中止"></a>1. 线程 在执行完 run方法后，会自动的中止</h5></li><li><h5 id="2-可以通过控制变量的方法-来让-线程随时的停止"><a href="#2-可以通过控制变量的方法-来让-线程随时的停止" class="headerlink" title="2. 可以通过控制变量的方法 来让 线程随时的停止."></a>2. 可以通过控制变量的方法 来让 线程随时的停止.</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        HI hi=<span class="keyword">new</span> <span class="title class_">HI</span>();</span><br><span class="line">        hi.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">7</span>)&#123;</span><br><span class="line">                <span class="comment">//当 i==3 时，中止 HI 线程</span></span><br><span class="line">                hi.setLoop(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello &quot;</span>+(i));</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HI</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//设置 控制变量 让另一个线程 可以随时控制 该线程的中止</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> loop=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//通过loop 来控制 HI线程的 中止</span></span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;HI&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="2-线程方法"><a href="#2-线程方法" class="headerlink" title="2) 线程方法"></a>2) 线程方法</h5><ul><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%951.png"></p></li><li><h5 id="线程中断实例"><a href="#线程中断实例" class="headerlink" title="线程中断实例"></a>线程中断实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        EAT eat=<span class="keyword">new</span> <span class="title class_">EAT</span>();</span><br><span class="line">        eat.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大哥 吃包子 &quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//当i=5时，打断eat线程</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                eat.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EAT</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小弟 吃包子&quot;</span>+(++count));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//InterruptedException 是该线程 被打断时 会进入的异常处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;小弟被打断了!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//设置 小弟被打断时间 为4s</span></span><br><span class="line">                    Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException interruptedException) &#123;</span><br><span class="line">                    interruptedException.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="3-线程插队"><a href="#3-线程插队" class="headerlink" title="3) 线程插队"></a>3) 线程插队</h5><ul><li><h5 id="线程礼让-yield-：当内存资源-不够时，线程会礼让其它的线程，让重要的线程先执行，随后再执行自己。-充满随机性，若是内存资源充足，则不会出现礼让行为。"><a href="#线程礼让-yield-：当内存资源-不够时，线程会礼让其它的线程，让重要的线程先执行，随后再执行自己。-充满随机性，若是内存资源充足，则不会出现礼让行为。" class="headerlink" title="线程礼让(yield)：当内存资源 不够时，线程会礼让其它的线程，让重要的线程先执行，随后再执行自己。 充满随机性，若是内存资源充足，则不会出现礼让行为。"></a>线程礼让(yield)：<em>当内存资源 不够时</em>，线程会礼让其它的线程，让重要的线程先执行，随后再执行自己。 充满随机性，<em>若是内存资源充足</em>，则不会出现礼让行为。</h5></li><li><h5 id="线程插队-join-：会直接先执行-插队线程，其它的线程会在-插队线程执行完毕后，再执行。"><a href="#线程插队-join-：会直接先执行-插队线程，其它的线程会在-插队线程执行完毕后，再执行。" class="headerlink" title="线程插队(join)：会直接先执行 插队线程，其它的线程会在 插队线程执行完毕后，再执行。"></a>线程插队(join)：会直接先执行 插队线程，其它的线程会在 插队线程执行完毕后，再执行。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        EAT eat=<span class="keyword">new</span> <span class="title class_">EAT</span>();</span><br><span class="line">        eat.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小弟 吃包子 &quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//当 i=5时，大哥插队</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                eat.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EAT</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大哥 吃包子&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="4-守护线程"><a href="#4-守护线程" class="headerlink" title="4) 守护线程"></a>4) 守护线程</h5><ul><li><h5 id="用户线程：一个线程-当任务执行完毕-或者-通知方式结束-就会中止线程-就叫用户线程"><a href="#用户线程：一个线程-当任务执行完毕-或者-通知方式结束-就会中止线程-就叫用户线程" class="headerlink" title="用户线程：一个线程 当任务执行完毕 或者 通知方式结束 就会中止线程 就叫用户线程"></a>用户线程：一个线程 当任务执行完毕 或者 通知方式结束 就会中止线程 就叫用户线程</h5></li><li><h5 id="守护线程：一般是为用户线程服务的，既当用户线程全部中止后，守护线程自动中止的线程。"><a href="#守护线程：一般是为用户线程服务的，既当用户线程全部中止后，守护线程自动中止的线程。" class="headerlink" title="守护线程：一般是为用户线程服务的，既当用户线程全部中止后，守护线程自动中止的线程。"></a>守护线程：一般是为用户线程服务的，既当用户线程全部中止后，守护线程自动中止的线程。</h5></li><li><h5 id="使用-xxx-setDaemon-true-既可设置为-守护线程"><a href="#使用-xxx-setDaemon-true-既可设置为-守护线程" class="headerlink" title="使用 xxx.setDaemon(true);   既可设置为 守护线程"></a>使用 <code>xxx.setDaemon(true); </code>  既可设置为 守护线程</h5></li></ul></li></ul></li><li><h4 id="4-线程7大状态"><a href="#4-线程7大状态" class="headerlink" title="(4) 线程7大状态"></a>(4) 线程7大状态</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE1.png"></p><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%812.png"></p></li><li><h4 id="5-线程同步机制"><a href="#5-线程同步机制" class="headerlink" title="(5) 线程同步机制"></a>(5) 线程同步机制</h4><ul><li><h5 id="1-线程同步：指-当同一时刻-几个线程同时访问到-同一个资源的时候，只允许其中一个线程访问该资源。"><a href="#1-线程同步：指-当同一时刻-几个线程同时访问到-同一个资源的时候，只允许其中一个线程访问该资源。" class="headerlink" title="1) 线程同步：指 当同一时刻 几个线程同时访问到 同一个资源的时候，只允许其中一个线程访问该资源。"></a>1) 线程同步：指 当同一时刻 几个线程同时访问到 同一个资源的时候，只允许其中一个线程访问该资源。</h5></li><li><h5 id="2-实现线程同步的方法："><a href="#2-实现线程同步的方法：" class="headerlink" title="2) 实现线程同步的方法："></a>2) 实现线程同步的方法：</h5><ul><li><h5 id="通过-同步代码块实现"><a href="#通过-同步代码块实现" class="headerlink" title="通过 同步代码块实现"></a>通过 同步代码块实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;  <span class="comment">//得到对象的锁 ，才能操作同步代码</span></span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="通过-把synchronized-放在方法声明中，使方法变成-同步方法"><a href="#通过-把synchronized-放在方法声明中，使方法变成-同步方法" class="headerlink" title="通过 把synchronized 放在方法声明中，使方法变成 同步方法"></a>通过 把synchronized 放在方法声明中，使方法变成 同步方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> m&#123;  <span class="comment">//变成 同步方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="6-锁的概念"><a href="#6-锁的概念" class="headerlink" title="(6) 锁的概念"></a>(6) 锁的概念</h4><ul><li><h5 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1) 互斥锁"></a>1) 互斥锁</h5><ul><li><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li><p>互斥锁 既 每一个对象都会对应一个 可称为 互斥锁的标记，该标记用来保证同一时刻，只能有一个线程来访问该对象。</p></li><li><h5 id="用关键字-synchronized-来与对象的互斥锁联系，当某个对象用-synchronized修饰时，表明该对象-任何时刻，只能有一个线程访问。"><a href="#用关键字-synchronized-来与对象的互斥锁联系，当某个对象用-synchronized修饰时，表明该对象-任何时刻，只能有一个线程访问。" class="headerlink" title="用关键字 synchronized 来与对象的互斥锁联系，当某个对象用 synchronized修饰时，表明该对象 任何时刻，只能有一个线程访问。"></a>用关键字 synchronized 来与对象的互斥锁联系，当某个对象用 synchronized修饰时，表明该对象 任何时刻，只能有一个线程访问。</h5></li><li><h5 id="同步方法-非静态-的锁可以是-this，也可以是其它对象（必须注意：要求必须是同一个对象）"><a href="#同步方法-非静态-的锁可以是-this，也可以是其它对象（必须注意：要求必须是同一个对象）" class="headerlink" title="同步方法(非静态) 的锁可以是 this，也可以是其它对象（必须注意：要求必须是同一个对象）"></a>同步方法(非静态) 的锁可以是 this，也可以是其它对象（必须注意：要求必须是同一个对象）</h5></li><li><h5 id="同步方法（静态）的锁-为-当前类本省。"><a href="#同步方法（静态）的锁-为-当前类本省。" class="headerlink" title="同步方法（静态）的锁 为 当前类本省。"></a>同步方法（静态）的锁 为 当前类本省。</h5></li></ul></li><li><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><h5 id="通常使用-同步代码块进行-同步加锁"><a href="#通常使用-同步代码块进行-同步加锁" class="headerlink" title="通常使用 同步代码块进行 同步加锁"></a>通常使用 同步代码块进行 同步加锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    <span class="comment">//同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="2-线程死锁"><a href="#2-线程死锁" class="headerlink" title="2) 线程死锁"></a>2) 线程死锁</h5><ul><li><h5 id="既-当A线程-访问o1，而B线程访问了o2-。而A线程-需要访问o2，B线程要访问-o1-就会产生死锁现象。"><a href="#既-当A线程-访问o1，而B线程访问了o2-。而A线程-需要访问o2，B线程要访问-o1-就会产生死锁现象。" class="headerlink" title="既 当A线程 访问o1，而B线程访问了o2 。而A线程 需要访问o2，B线程要访问 o1 就会产生死锁现象。"></a>既 当A线程 访问o1，而B线程访问了o2 。而A线程 需要访问o2，B线程要访问 o1 就会产生死锁现象。</h5></li><li><pre><code class="java">//线程A 访问 o1 o2synchronized(o1)&#123;    System.out.println(&quot;xxx&quot;);    synchronized(02)&#123;        System.out.println(&quot;xxx&quot;);    &#125;&#125;//线程B 访问 o2 o1 synchronized(o2)&#123;    System.out.println(&quot;xxx&quot;);    synchronized(o1)&#123;        System.out.println(&quot;xxx&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">  - ##### 3) 释放锁（既什么情况下，会释放锁）</span><br><span class="line"></span><br><span class="line">    - ##### 什么情况下，会释放锁</span><br><span class="line"></span><br><span class="line">      - ##### 当前线程的同步方法已经完成，或者同步代码块的代码已经执行完毕</span><br><span class="line"></span><br><span class="line">      - ##### 当前线程在同步代码块或同步方法中，遇到了return或break。</span><br><span class="line"></span><br><span class="line">      - ##### 遇到了未处理的 Exception、Error，导致异常而结束</span><br><span class="line"></span><br><span class="line">      - ##### 当前线程在 执行了线程对象的 wait（）对象，使线程暂停，从而释放锁。</span><br><span class="line"></span><br><span class="line">    - ##### 什么情况下，不会释放锁</span><br><span class="line"></span><br><span class="line">      - ##### 当前线程 调用了sleep()  或者 yiele() 方法 不会释放锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4. Java文件处理</span><br><span class="line"></span><br><span class="line">- #### (1) 含义</span><br><span class="line"></span><br><span class="line">  - ##### 文件流：文件在程序中 是以 流 的形式来操作的</span><br><span class="line"></span><br><span class="line">    ![](/Java复习/文件流01.png)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### (2)  常用的文件操作</span><br><span class="line"></span><br><span class="line">  - ##### 创建 文件对象的构造方法</span><br><span class="line"></span><br><span class="line">    ![](Java复习/文件对象创造方法.png)</span><br><span class="line"></span><br><span class="line">  - ##### 获取文件信息的方法</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    //获取文件名</span><br><span class="line">            System.out.println(&quot;文件名：&quot;+file.getName());</span><br><span class="line">            //获取文件的绝对路径</span><br><span class="line">            System.out.println(&quot;文件的绝对路径：&quot;+file.getAbsolutePath());</span><br><span class="line">            //获取父级目录地址</span><br><span class="line">            System.out.println(&quot;文件的父级目录：&quot;+file.getParent());</span><br><span class="line">            //获取文件的大小</span><br><span class="line">            System.out.println(&quot;文件的大小：&quot;+file.length());</span><br><span class="line">            //文件是否存在</span><br><span class="line">            System.out.println(&quot;文件是否存在：&quot;+file.exists());</span><br><span class="line">            //是不是一个文件</span><br><span class="line">            System.out.println(&quot;是不是文件：&quot;+file.isFile());</span><br><span class="line">            //是不是一个目录</span><br><span class="line">            System.out.println(&quot;是不是目录：&quot;+file.isDirectory());</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><h5 id="目录的创建"><a href="#目录的创建" class="headerlink" title="目录的创建"></a>目录的创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       String path=<span class="string">&quot;d:\\a\\b\\c\\d&quot;</span>;</span><br><span class="line">       <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">       <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;文件已经存在&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//file.mkdirs() 创建多级目录</span></span><br><span class="line">           <span class="comment">//file.mkdir() 创建单级目录</span></span><br><span class="line">           <span class="keyword">if</span>(file.mkdirs())&#123;</span><br><span class="line">               System.out.println(path+<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="3-IO流"><a href="#3-IO流" class="headerlink" title="(3) IO流"></a>(3) IO流</h4><ul><li><h5 id="1）含义"><a href="#1）含义" class="headerlink" title="1）含义"></a>1）含义</h5><ul><li><h5 id="I-O-是-input-output-的缩写，主要用于处理数据的传输。如-读写文件。"><a href="#I-O-是-input-output-的缩写，主要用于处理数据的传输。如-读写文件。" class="headerlink" title="I&#x2F;O 是 input&#x2F;output 的缩写，主要用于处理数据的传输。如 读写文件。"></a>I&#x2F;O 是 input&#x2F;output 的缩写，主要用于处理数据的传输。如 读写文件。</h5></li><li><h5 id="流的分类："><a href="#流的分类：" class="headerlink" title="流的分类："></a>流的分类：</h5><ul><li><h5 id="按-操作数据单位不同：字节流（8-bit-主要读取二进制文件）-和-字符流（按字符-可以读取中文字符）"><a href="#按-操作数据单位不同：字节流（8-bit-主要读取二进制文件）-和-字符流（按字符-可以读取中文字符）" class="headerlink" title="按 操作数据单位不同：字节流（8 bit 主要读取二进制文件） 和 字符流（按字符 可以读取中文字符）"></a>按 操作数据单位不同：字节流（8 bit 主要读取二进制文件） 和 字符流（按字符 可以读取中文字符）</h5></li><li><h5 id="按-数据流的-流向不同：输入流，输出流"><a href="#按-数据流的-流向不同：输入流，输出流" class="headerlink" title="按 数据流的 流向不同：输入流，输出流"></a>按 数据流的 流向不同：输入流，输出流</h5></li><li><h5 id="按-流的角色分：节点流，处理流-包装流"><a href="#按-流的角色分：节点流，处理流-包装流" class="headerlink" title="按 流的角色分：节点流，处理流&#x2F;包装流"></a>按 流的角色分：节点流，处理流&#x2F;包装流</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB.png"></p></li></ul></li></ul></li><li><h5 id="2-FileInputStream-与-FileOutPutStream-字节流-的使用"><a href="#2-FileInputStream-与-FileOutPutStream-字节流-的使用" class="headerlink" title="2) FileInputStream 与 FileOutPutStream(字节流)的使用"></a>2) FileInputStream 与 FileOutPutStream(字节流)的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FileInputStream fileInputStream=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> readData=<span class="number">0</span>; <span class="comment">//用于 接受inputStream 返回的字节</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过FileInputStream 获取 a.txt的 字节流</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\a.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//如果 fileInputStream 读取文件数据结束 就会返回-1</span></span><br><span class="line">            <span class="keyword">while</span>((readData=fileInputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)readData);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭 字节流 避免资源浪费</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\a.txt&quot;</span>;</span><br><span class="line">        FileOutputStream fileOutputStream=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过文件路径 来创建FileOutputStream对象</span></span><br><span class="line">            <span class="comment">//new FileOutPutStream(String path,boolean append);</span></span><br><span class="line">            <span class="comment">//path:路径 append:写入的内容是否添加到末尾 false：则每次写入的内容都覆盖原来的内容</span></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//1.写入单个字节（字符） write(byte b)</span></span><br><span class="line">            <span class="comment">//fileOutputStream.write(&#x27;H&#x27;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.写入字符串 write(byte[] bs)</span></span><br><span class="line">            String str=<span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line"><span class="comment">//            fileOutputStream.write(str.getBytes());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.有条件的写入字符串</span></span><br><span class="line">            <span class="comment">//写入str字符串 从索引0开始 写入3个字符</span></span><br><span class="line">            fileOutputStream.write(str.getBytes(),<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="3-FileReader-与-FileWriter（字符流）的使用"><a href="#3-FileReader-与-FileWriter（字符流）的使用" class="headerlink" title="3) FileReader 与 FileWriter（字符流）的使用"></a>3) FileReader 与 FileWriter（字符流）的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\xxx.txt&quot;</span>;</span><br><span class="line">        FileReader reader=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader=<span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">            <span class="comment">//1.通过每次读取一个字符的方式读取</span></span><br><span class="line"><span class="comment">//            while ((result=reader.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print((char)result);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//2.通过字符数组的方式来获取(效率高)</span></span><br><span class="line">            <span class="type">char</span>[] ch=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">while</span> ((result=reader.read(ch))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//要使用这个new String(ch,0,result) 方式来进行输出</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,result));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FileWriter fileWriter=<span class="literal">null</span>;</span><br><span class="line">        String path=<span class="string">&quot;d:\\ee.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWriter=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path,<span class="literal">true</span>); <span class="comment">//append：是否追加在文件内容后面</span></span><br><span class="line">            <span class="comment">//1.通过字符串内容来写入文件 write(String str)</span></span><br><span class="line">            String str=<span class="string">&quot;你好，哈哈哈！！xxx&quot;</span>;</span><br><span class="line">            <span class="comment">//fileWriter.write(str);</span></span><br><span class="line">            <span class="comment">//2.通过截取字符串 来输入</span></span><br><span class="line">            fileWriter.write(str,<span class="number">0</span>,<span class="number">3</span>); <span class="comment">//从索引0开始，写入三个字符</span></span><br><span class="line">            System.out.print(<span class="string">&quot;输入成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="4-节点流-与-处理流"><a href="#4-节点流-与-处理流" class="headerlink" title="(4) 节点流 与 处理流"></a>(4) 节点流 与 处理流</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E8%8A%82%E7%82%B9%E6%B5%81%E4%B8%8E%E5%A4%84%E7%90%86%E6%B5%81.png"></p><ul><li><h5 id="1-含义："><a href="#1-含义：" class="headerlink" title="1) 含义："></a>1) 含义：</h5><ul><li><h5 id="节点流-既-可以从一个特定的数据源（例如-文件、数组、字符串等等）-读写数据，如FileInputStream、FileWriter"><a href="#节点流-既-可以从一个特定的数据源（例如-文件、数组、字符串等等）-读写数据，如FileInputStream、FileWriter" class="headerlink" title="节点流 既 可以从一个特定的数据源（例如 文件、数组、字符串等等） 读写数据，如FileInputStream、FileWriter"></a>节点流 既 可以从一个特定的数据源（例如 文件、数组、字符串等等） 读写数据，如FileInputStream、FileWriter</h5></li><li><h5 id="处理流（也称-包装流）是-”连接“-在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能。如BufferedReader、BufferedWriter"><a href="#处理流（也称-包装流）是-”连接“-在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能。如BufferedReader、BufferedWriter" class="headerlink" title="处理流（也称 包装流）是 ”连接“ 在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能。如BufferedReader、BufferedWriter"></a>处理流（也称 包装流）是 ”连接“ 在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能。如BufferedReader、BufferedWriter</h5></li></ul></li><li><h5 id="2）区别-与-联系："><a href="#2）区别-与-联系：" class="headerlink" title="2）区别 与 联系："></a>2）区别 与 联系：</h5><ul><li><h5 id="节点流-是-底层流-低级流-，直接与数据源进行相接"><a href="#节点流-是-底层流-低级流-，直接与数据源进行相接" class="headerlink" title="节点流 是 底层流&#x2F;低级流 ，直接与数据源进行相接"></a>节点流 是 底层流&#x2F;低级流 ，直接与数据源进行相接</h5></li><li><h5 id="处理流，即可以消除不同节点流之间的差异（既-可以通过不同的数据源，使用节点流）-，也可以提供更方便的方法来完成输入输出。"><a href="#处理流，即可以消除不同节点流之间的差异（既-可以通过不同的数据源，使用节点流）-，也可以提供更方便的方法来完成输入输出。" class="headerlink" title="处理流，即可以消除不同节点流之间的差异（既 可以通过不同的数据源，使用节点流） ，也可以提供更方便的方法来完成输入输出。"></a>处理流，即可以消除不同节点流之间的差异（既 可以通过不同的数据源，使用节点流） ，也可以提供更方便的方法来完成输入输出。</h5></li><li><h5 id="处理流-对-节点流进行了-包装，使用了-修饰器模式，不会直接与数据进行相连（而是-特定的节点流进行相连。处理流相当于调用不同的节点流）。"><a href="#处理流-对-节点流进行了-包装，使用了-修饰器模式，不会直接与数据进行相连（而是-特定的节点流进行相连。处理流相当于调用不同的节点流）。" class="headerlink" title="处理流 对 节点流进行了 包装，使用了 修饰器模式，不会直接与数据进行相连（而是 特定的节点流进行相连。处理流相当于调用不同的节点流）。"></a>处理流 对 节点流进行了 包装，使用了 修饰器模式，不会直接与数据进行相连（而是 特定的节点流进行相连。处理流相当于调用不同的节点流）。</h5></li></ul></li><li><h5 id="3-处理流的优势"><a href="#3-处理流的优势" class="headerlink" title="3) 处理流的优势"></a>3) 处理流的优势</h5><ul><li><h5 id="性能的提高：主要以-增加缓冲-的方式来-提高-输入输出的效率。"><a href="#性能的提高：主要以-增加缓冲-的方式来-提高-输入输出的效率。" class="headerlink" title="性能的提高：主要以 增加缓冲 的方式来 提高 输入输出的效率。"></a>性能的提高：主要以 增加缓冲 的方式来 提高 输入输出的效率。</h5></li><li><h5 id="操作的便捷：处理流可能提供了-一系列便捷的方法-来一次输入输出大批量的数据，使用更加灵活。"><a href="#操作的便捷：处理流可能提供了-一系列便捷的方法-来一次输入输出大批量的数据，使用更加灵活。" class="headerlink" title="操作的便捷：处理流可能提供了 一系列便捷的方法 来一次输入输出大批量的数据，使用更加灵活。"></a>操作的便捷：处理流可能提供了 一系列便捷的方法 来一次输入输出大批量的数据，使用更加灵活。</h5></li></ul></li><li><h5 id="4-BufferedReader-与-BufferedWriter-的使用-字符流"><a href="#4-BufferedReader-与-BufferedWriter-的使用-字符流" class="headerlink" title="4) BufferedReader 与 BufferedWriter 的使用(字符流)"></a>4) BufferedReader 与 BufferedWriter 的使用(字符流)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\ok.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1.创建 BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="comment">//2.获取文件内容</span></span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//reader.readLine() 一行一行的读取内容</span></span><br><span class="line">    <span class="comment">//当 文件的内容读取到结尾后，会获取会null</span></span><br><span class="line">        <span class="keyword">while</span> ((str=reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\ok.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path,<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接输入字符串 来 写入编写内容</span></span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;你好 哈哈哈&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;不错不错&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流 其实就是关闭节点流 FileWriter</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="5-字节处理流（BufferedInputStream-与-BufferOutPutStream）"><a href="#5-字节处理流（BufferedInputStream-与-BufferOutPutStream）" class="headerlink" title="5) 字节处理流（BufferedInputStream 与 BufferOutPutStream）"></a>5) 字节处理流（BufferedInputStream 与 BufferOutPutStream）</h5><ul><li><h5 id="BufferedInputStream介绍：是字节流的一种，里面会创建一个内部缓冲数组"><a href="#BufferedInputStream介绍：是字节流的一种，里面会创建一个内部缓冲数组" class="headerlink" title="BufferedInputStream介绍：是字节流的一种，里面会创建一个内部缓冲数组"></a>BufferedInputStream介绍：是字节流的一种，里面会创建一个内部缓冲数组</h5></li><li><h5 id="BufferedOutputStream介绍：实现缓冲的输出流，提供了方法，可以将多个字节-写入底层输出流中，提高效率。"><a href="#BufferedOutputStream介绍：实现缓冲的输出流，提供了方法，可以将多个字节-写入底层输出流中，提高效率。" class="headerlink" title="BufferedOutputStream介绍：实现缓冲的输出流，提供了方法，可以将多个字节 写入底层输出流中，提高效率。"></a>BufferedOutputStream介绍：实现缓冲的输出流，提供了方法，可以将多个字节 写入底层输出流中，提高效率。</h5></li><li><h5 id="使用介绍："><a href="#使用介绍：" class="headerlink" title="使用介绍："></a>使用介绍：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对音乐文件 进行拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取 需要拷贝的地址</span></span><br><span class="line">        String path=<span class="string">&quot;d:\\111.wav&quot;</span>;</span><br><span class="line">        <span class="comment">//创建字节流</span></span><br><span class="line">        BufferedInputStream bufferedInputStream=<span class="literal">null</span>;</span><br><span class="line">        BufferedOutputStream bufferedOutputStream=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//拷贝文件的 地址</span></span><br><span class="line">        String desPath=<span class="string">&quot;d:\\222.wav&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了提升效率 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufferedInputStream=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line">            bufferedOutputStream=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(desPath));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//边 读写数据 边写入数据</span></span><br><span class="line">            <span class="keyword">while</span> ((bufferedInputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                bufferedOutputStream.write(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bufferedInputStream!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    bufferedInputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(bufferedOutputStream!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    bufferedOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="6-对象流-ObjectInputStream-与-ObjectOutputStream"><a href="#6-对象流-ObjectInputStream-与-ObjectOutputStream" class="headerlink" title="6) 对象流(ObjectInputStream 与 ObjectOutputStream)"></a>6) 对象流(ObjectInputStream 与 ObjectOutputStream)</h5><ul><li><h5 id="序列化与反序列化-含义：在保存数据时，不仅能够保存数值，还能保存-数据的类型，这就叫-序列化。-读取数据时，不仅能读取数值-还能够识别读取-数值的-数据类型-这就叫反序列化。-而要实现序列表-，则该类必须实现-Serializable接口"><a href="#序列化与反序列化-含义：在保存数据时，不仅能够保存数值，还能保存-数据的类型，这就叫-序列化。-读取数据时，不仅能读取数值-还能够识别读取-数值的-数据类型-这就叫反序列化。-而要实现序列表-，则该类必须实现-Serializable接口" class="headerlink" title="序列化与反序列化 含义：在保存数据时，不仅能够保存数值，还能保存 数据的类型，这就叫 序列化。 读取数据时，不仅能读取数值 还能够识别读取 数值的 数据类型 这就叫反序列化。 而要实现序列表 ，则该类必须实现 Serializable接口"></a>序列化与反序列化 含义：在保存数据时，不仅能够保存数值，还能保存 数据的类型，这就叫 序列化。 读取数据时，不仅能读取数值 还能够识别读取 数值的 数据类型 这就叫反序列化。 而要实现序列表 ，则该类必须实现 Serializable接口</h5></li><li><h5 id="对象流-就是-能够操作-存放或者读取的数据，实现序列化的-流。"><a href="#对象流-就是-能够操作-存放或者读取的数据，实现序列化的-流。" class="headerlink" title="对象流 就是 能够操作 存放或者读取的数据，实现序列化的 流。"></a>对象流 就是 能够操作 存放或者读取的数据，实现序列化的 流。</h5></li><li><h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要想 Cat能够 实现序列化 必须实现 Serializable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       String path=<span class="string">&quot;d:\\ww.txt&quot;</span>;</span><br><span class="line">       <span class="comment">//创建输出对象流</span></span><br><span class="line">       <span class="type">ObjectOutputStream</span> <span class="variable">objectOutPutStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path));</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//写入int 类型的 数值</span></span><br><span class="line">       objectOutPutStream.writeInt(<span class="number">100</span>);</span><br><span class="line">       objectOutPutStream.writeBoolean(<span class="literal">false</span>);</span><br><span class="line">      </span><br><span class="line">       objectOutPutStream.writeObject(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;jj&quot;</span>,<span class="number">18</span>));</span><br><span class="line">      </span><br><span class="line">       objectOutPutStream.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">       String path=<span class="string">&quot;d:\\ww.txt&quot;</span>;</span><br><span class="line">      </span><br><span class="line">       <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//读取的顺序 一定要与 写入的顺序一致</span></span><br><span class="line">       System.out.println(inputStream.readInt());</span><br><span class="line">       System.out.println(inputStream.readBoolean());</span><br><span class="line">       <span class="comment">//System.out.println(inputStream.readObject());</span></span><br><span class="line">      </span><br><span class="line">       <span class="comment">//如果想要 运用获取类型的方法</span></span><br><span class="line">       <span class="comment">//1. 向下转型</span></span><br><span class="line">       Cat cat=(Cat) inputStream.readObject();  <span class="comment">//注意 如果上面获取了Object 则下面就不能再获取</span></span><br><span class="line">       System.out.println(cat);</span><br><span class="line">       <span class="comment">//每当修改了 对象的一些方法 或者内容 需要 重新写入数据才有效</span></span><br><span class="line">       System.out.println(cat.getName());</span><br><span class="line">      </span><br><span class="line">       inputStream.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="使用细节："><a href="#使用细节：" class="headerlink" title="使用细节："></a>使用细节：</h5><ul><li><h5 id="读写的顺序要一致"><a href="#读写的顺序要一致" class="headerlink" title="读写的顺序要一致"></a>读写的顺序要一致</h5></li><li><h5 id="要求实现序列化的对象-必须实现-Serializable"><a href="#要求实现序列化的对象-必须实现-Serializable" class="headerlink" title="要求实现序列化的对象 必须实现 Serializable"></a>要求实现序列化的对象 必须实现 Serializable</h5></li><li><h5 id="序列化对象时，默认会把所有的属性都序列化，除了-static-和-transient-修饰的成员"><a href="#序列化对象时，默认会把所有的属性都序列化，除了-static-和-transient-修饰的成员" class="headerlink" title="序列化对象时，默认会把所有的属性都序列化，除了 static 和 transient 修饰的成员"></a>序列化对象时，默认会把所有的属性都序列化，除了 static 和 transient 修饰的成员</h5></li><li><h5 id="序列化对象时，要求里面的属性-都需要实现序列化接口"><a href="#序列化对象时，要求里面的属性-都需要实现序列化接口" class="headerlink" title="序列化对象时，要求里面的属性 都需要实现序列化接口"></a>序列化对象时，要求里面的属性 都需要实现序列化接口</h5></li><li><h5 id="序列化-具有-继承性，如果父类实现了序列化，则它的子类也会实现序列化。"><a href="#序列化-具有-继承性，如果父类实现了序列化，则它的子类也会实现序列化。" class="headerlink" title="序列化 具有 继承性，如果父类实现了序列化，则它的子类也会实现序列化。"></a>序列化 具有 继承性，如果父类实现了序列化，则它的子类也会实现序列化。</h5></li></ul></li></ul></li></ul></li><li><h4 id="5-标准输入输出流"><a href="#5-标准输入输出流" class="headerlink" title="(5) 标准输入输出流"></a>(5) 标准输入输出流</h4><ul><li><h5 id="1-标准输入：System-in-类型：InputStream-默认设备：键盘"><a href="#1-标准输入：System-in-类型：InputStream-默认设备：键盘" class="headerlink" title="1) 标准输入：System.in 类型：InputStream 默认设备：键盘"></a>1) 标准输入：System.in 类型：InputStream 默认设备：键盘</h5></li><li><h5 id="2-标准输出：System-out-类型：PrintStream-默认设备：显示器"><a href="#2-标准输出：System-out-类型：PrintStream-默认设备：显示器" class="headerlink" title="2) 标准输出：System.out 类型：PrintStream 默认设备：显示器"></a>2) 标准输出：System.out 类型：PrintStream 默认设备：显示器</h5></li><li><h5 id="3-使用"><a href="#3-使用" class="headerlink" title="3) 使用"></a>3) 使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//System.in 的编译类型是 InputStream 而 运行类型是 BufferInputStream</span></span><br><span class="line">       System.out.println(System.in.getClass());</span><br><span class="line">       <span class="comment">//System.out 的编译类型 与 运行类型 都是 PrintStream</span></span><br><span class="line">       System.out.println(System.out.getClass());</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//标准键盘输入</span></span><br><span class="line">       <span class="comment">//scanner 获取 InputStream 来进行 键盘输入</span></span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">       String str=scanner.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;你输入的值为：&quot;</span>+str);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="6-转换流"><a href="#6-转换流" class="headerlink" title="(6) 转换流"></a>(6) 转换流</h4><ul><li><h5 id="1-作用：当读取的数据-不是默认的UTF-8的形式时（例如-ANSI格式等），中文就会出现-乱码的现象。因此，可以用-InputStreamReader-与-OutputStreamWriter（主要对-字节流-进行-转换）来-设置编码进行存储。"><a href="#1-作用：当读取的数据-不是默认的UTF-8的形式时（例如-ANSI格式等），中文就会出现-乱码的现象。因此，可以用-InputStreamReader-与-OutputStreamWriter（主要对-字节流-进行-转换）来-设置编码进行存储。" class="headerlink" title="1) 作用：当读取的数据 不是默认的UTF-8的形式时（例如 ANSI格式等），中文就会出现 乱码的现象。因此，可以用 InputStreamReader 与 OutputStreamWriter（主要对 字节流 进行 转换）来 设置编码进行存储。"></a>1) 作用：当读取的数据 不是默认的UTF-8的形式时（例如 ANSI格式等），中文就会出现 乱码的现象。因此，可以用 InputStreamReader 与 OutputStreamWriter（主要对 字节流 进行 转换）来 设置编码进行存储。</h5></li><li><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2) 使用"></a>2) 使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InputStreamReader 的使用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\xx.txt&quot;</span>;</span><br><span class="line">        FileInputStream fileInputStream=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path); <span class="comment">//正常的 字节流</span></span><br><span class="line">        <span class="comment">//对 字节流 进行转换 成 字符流,并且设置 编码为 gbk 防止格式不同 造成乱码</span></span><br><span class="line">        <span class="comment">//注意：转换的格式 要与 文件的格式一致</span></span><br><span class="line">        InputStreamReader ir=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//把 字符流 转成 效率更高的 包装处理流</span></span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(ir);</span><br><span class="line">        System.out.println(br.readLine());</span><br><span class="line"></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OutputStreamWriter 的 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\xxx.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//把输出字节流 转换成 字符流，并且设置 输出的编码格式为 gbk</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把字符流 装成 包装字符流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line"></span><br><span class="line">        writer.write(<span class="string">&quot;哈哈，赶紧写入数据嘛 嘿嘿嘿嘿&quot;</span>);</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="7-打印流-PrintStream-与-PrintWriter"><a href="#7-打印流-PrintStream-与-PrintWriter" class="headerlink" title="(7) 打印流(PrintStream 与 PrintWriter)"></a>(7) 打印流(PrintStream 与 PrintWriter)</h4><ul><li><h5 id="1-使用"><a href="#1-使用" class="headerlink" title="1) 使用"></a>1) 使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//out 本身就是 printStream</span></span><br><span class="line">        PrintStream printStream=System.out;</span><br><span class="line">        <span class="comment">//通过printStream 来输出信息</span></span><br><span class="line">        printStream.print(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据源码可知，print 的底层用的是 write方法</span></span><br><span class="line">        <span class="comment">// 因此 可以用write来输出信息</span></span><br><span class="line">        printStream.write(<span class="string">&quot;哈哈 离谱&quot;</span>.getBytes());</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以通过构造器去修改文件输出的位置 默认是 显示器</span></span><br><span class="line">        System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;d:\\xx.txt&quot;</span>));</span><br><span class="line">        PrintStream ps=System.out;</span><br><span class="line">        <span class="comment">//这是输出 就是输出到指定文件中</span></span><br><span class="line">        ps.print(<span class="string">&quot;实验实验&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        PrintWriter writer=new PrintWriter(System.out);</span></span><br><span class="line"><span class="comment">//        writer.print(&quot;哈哈哈&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:\\xxx.txt&quot;</span>));</span><br><span class="line">        writer1.print(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        writer1.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="8-Properties类"><a href="#8-Properties类" class="headerlink" title="(8) Properties类"></a>(8) Properties类</h4><ul><li><h5 id="1-用处：用properties-来-存储-一些固定的-信息（以-K-V的形式来存储，），便于获取-和-整体的修改"><a href="#1-用处：用properties-来-存储-一些固定的-信息（以-K-V的形式来存储，），便于获取-和-整体的修改" class="headerlink" title="1) 用处：用properties 来 存储 一些固定的 信息（以 K-V的形式来存储，），便于获取 和 整体的修改"></a>1) 用处：用properties 来 存储 一些固定的 信息（以 K-V的形式来存储，），便于获取 和 整体的修改</h5></li><li><h5 id="2-方法："><a href="#2-方法：" class="headerlink" title="2) 方法："></a>2) 方法：</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/Properties%E6%96%B9%E6%B3%95.png"></p></li><li><h5 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="3) 使用"></a>3) 使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Properties文件</span></span><br><span class="line">        <span class="comment">//  设置 Properties文件 的内容</span></span><br><span class="line">        <span class="comment">//  如果k存在 则会变成 修改该k的 v</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">//如果value是中文，在store方法写入时</span></span><br><span class="line">        <span class="comment">//如果用 字符流 则正常显示中文</span></span><br><span class="line">        <span class="comment">//如果用 字节流 则中文 会编程 unicode码</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;肇庆&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过 store 方法 创建 Properties文件</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src\\info.properties&quot;</span>),<span class="string">&quot;创建properties&quot;</span>);</span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\info2.properties&quot;</span>),<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过list方法 查看Properties文件</span></span><br><span class="line">        properties.list(System.out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.获取特定的键值对</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.print(user);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-Java网络相关知识"><a href="#5-Java网络相关知识" class="headerlink" title="5. Java网络相关知识"></a>5. Java网络相关知识</h3><ul><li><h4 id="1）网络通讯"><a href="#1）网络通讯" class="headerlink" title="1）网络通讯"></a>1）网络通讯</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png"></p><ul><li><h5 id="概念：将数据通过网络-从一台设备-传输到-另一台设备。"><a href="#概念：将数据通过网络-从一台设备-传输到-另一台设备。" class="headerlink" title="概念：将数据通过网络 从一台设备 传输到 另一台设备。"></a>概念：将数据通过网络 从一台设备 传输到 另一台设备。</h5></li><li><h5 id="网络的概念：-两台或者更多的设备-通过一定的物理设备-连接起来构成了网络。根据网络覆盖的范围大小分为：局域网、城域网、广域网。"><a href="#网络的概念：-两台或者更多的设备-通过一定的物理设备-连接起来构成了网络。根据网络覆盖的范围大小分为：局域网、城域网、广域网。" class="headerlink" title="网络的概念： 两台或者更多的设备 通过一定的物理设备 连接起来构成了网络。根据网络覆盖的范围大小分为：局域网、城域网、广域网。"></a>网络的概念： 两台或者更多的设备 通过一定的物理设备 连接起来构成了网络。根据网络覆盖的范围大小分为：局域网、城域网、广域网。</h5></li></ul></li><li><h4 id="2）IP地址"><a href="#2）IP地址" class="headerlink" title="2）IP地址"></a>2）IP地址</h4><ul><li><h5 id="概念：用于-唯一标识网络中的-每台计算机（既相当于-电脑在网络中的标识）。"><a href="#概念：用于-唯一标识网络中的-每台计算机（既相当于-电脑在网络中的标识）。" class="headerlink" title="概念：用于 唯一标识网络中的 每台计算机（既相当于 电脑在网络中的标识）。"></a>概念：用于 唯一标识网络中的 每台计算机（既相当于 电脑在网络中的标识）。</h5></li><li><h5 id="本机查看IP地址的方法：在cmd中-输入命令-ipconfig"><a href="#本机查看IP地址的方法：在cmd中-输入命令-ipconfig" class="headerlink" title="本机查看IP地址的方法：在cmd中 输入命令 ipconfig"></a>本机查看IP地址的方法：在cmd中 输入命令 ipconfig</h5></li><li><h5 id="IP地址的表现形式：点分十进制-xx-xx-xx-xx-每一个十进制数的范围在-0-255。"><a href="#IP地址的表现形式：点分十进制-xx-xx-xx-xx-每一个十进制数的范围在-0-255。" class="headerlink" title="IP地址的表现形式：点分十进制 xx.xx.xx.xx 每一个十进制数的范围在 0~255。"></a>IP地址的表现形式：点分十进制 xx.xx.xx.xx 每一个十进制数的范围在 0~255。</h5></li><li><h5 id="IP地址的组成：网络地址-主机地址。如-192-168-12-69-前三位是网络地址-后一位是主机地址"><a href="#IP地址的组成：网络地址-主机地址。如-192-168-12-69-前三位是网络地址-后一位是主机地址" class="headerlink" title="IP地址的组成：网络地址+主机地址。如 192.168.12.69 前三位是网络地址 后一位是主机地址"></a>IP地址的组成：网络地址+主机地址。如 192.168.12.69 前三位是网络地址 后一位是主机地址</h5></li><li><h5 id="ipv6诞生：由于-IPV4最大的问题是-网络地址有限（既-设备太多，地址不够）因此IPV6的出现解决了问题。其中-IPV6是由-八位的十六进制组成。"><a href="#ipv6诞生：由于-IPV4最大的问题是-网络地址有限（既-设备太多，地址不够）因此IPV6的出现解决了问题。其中-IPV6是由-八位的十六进制组成。" class="headerlink" title="ipv6诞生：由于 IPV4最大的问题是 网络地址有限（既 设备太多，地址不够）因此IPV6的出现解决了问题。其中 IPV6是由 八位的十六进制组成。"></a>ipv6诞生：由于 IPV4最大的问题是 网络地址有限（既 设备太多，地址不够）因此IPV6的出现解决了问题。其中 IPV6是由 八位的十六进制组成。</h5></li><li><h5 id="IPV4的地址分类："><a href="#IPV4的地址分类：" class="headerlink" title="IPV4的地址分类："></a>IPV4的地址分类：</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/IPV4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png"></p></li></ul></li><li><h4 id="3）域名"><a href="#3）域名" class="headerlink" title="3）域名"></a>3）域名</h4><ul><li><h5 id="概念：将ip地址-映射成-域名。可以方便记忆，不需要记ip。"><a href="#概念：将ip地址-映射成-域名。可以方便记忆，不需要记ip。" class="headerlink" title="概念：将ip地址 映射成 域名。可以方便记忆，不需要记ip。"></a>概念：将ip地址 映射成 域名。可以方便记忆，不需要记ip。</h5></li><li><h5 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h5><ul><li><h5 id="概念：用于-标识计算机上-某个特定的网络程序。（既-端口可以标识-ip地址下的-哪一个服务板块）。"><a href="#概念：用于-标识计算机上-某个特定的网络程序。（既-端口可以标识-ip地址下的-哪一个服务板块）。" class="headerlink" title="概念：用于 标识计算机上 某个特定的网络程序。（既 端口可以标识 ip地址下的 哪一个服务板块）。"></a>概念：用于 标识计算机上 某个特定的网络程序。（既 端口可以标识 ip地址下的 哪一个服务板块）。</h5></li><li><h5 id="表示形式：以-整数-的形式表示，范围-0-65535"><a href="#表示形式：以-整数-的形式表示，范围-0-65535" class="headerlink" title="表示形式：以 整数 的形式表示，范围 0~65535"></a>表示形式：以 整数 的形式表示，范围 0~65535</h5></li><li><h5 id="其中0-1024的端口，已被知名的网络程序-占用。"><a href="#其中0-1024的端口，已被知名的网络程序-占用。" class="headerlink" title="其中0~1024的端口，已被知名的网络程序 占用。"></a>其中0~1024的端口，已被知名的网络程序 占用。</h5></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5></li></ul></li><li><h4 id="4）网络通讯协议"><a href="#4）网络通讯协议" class="headerlink" title="4）网络通讯协议"></a>4）网络通讯协议</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><ul><li><h5 id="tcp-ip协议：该协议-是-Internet-最基本的协议，是Internet国际互联网的基础。即是由-网络层面的IP协议-与-传输层的TCP协议组成。"><a href="#tcp-ip协议：该协议-是-Internet-最基本的协议，是Internet国际互联网的基础。即是由-网络层面的IP协议-与-传输层的TCP协议组成。" class="headerlink" title="tcp&#x2F;ip协议：该协议 是 Internet 最基本的协议，是Internet国际互联网的基础。即是由 网络层面的IP协议 与 传输层的TCP协议组成。"></a>tcp&#x2F;ip协议：该协议 是 Internet 最基本的协议，是Internet国际互联网的基础。即是由 网络层面的IP协议 与 传输层的TCP协议组成。</h5></li><li><h5 id="网络通讯协议的模型："><a href="#网络通讯协议的模型：" class="headerlink" title="网络通讯协议的模型："></a>网络通讯协议的模型：</h5><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E5%9E%8B.png"></p></li><li><h5 id="TCP介绍（传输控制协议）："><a href="#TCP介绍（传输控制协议）：" class="headerlink" title="TCP介绍（传输控制协议）："></a>TCP介绍（传输控制协议）：</h5><ul><li><h5 id="使用TCP协议前，须先建立TCP-连接，形成传输数据通道。"><a href="#使用TCP协议前，须先建立TCP-连接，形成传输数据通道。" class="headerlink" title="使用TCP协议前，须先建立TCP 连接，形成传输数据通道。"></a>使用TCP协议前，须先建立TCP 连接，形成传输数据通道。</h5></li><li><h5 id="传输前，采用-“三次握手”方式，-是可靠的。"><a href="#传输前，采用-“三次握手”方式，-是可靠的。" class="headerlink" title="传输前，采用 “三次握手”方式， 是可靠的。"></a>传输前，采用 “三次握手”方式， 是可靠的。</h5></li><li><h5 id="TCP-协议进行通信的两个应用进程：客户端、服务端。"><a href="#TCP-协议进行通信的两个应用进程：客户端、服务端。" class="headerlink" title="TCP 协议进行通信的两个应用进程：客户端、服务端。"></a>TCP 协议进行通信的两个应用进程：客户端、服务端。</h5></li><li><h5 id="在连接中，可进行-大数据量-的传输。"><a href="#在连接中，可进行-大数据量-的传输。" class="headerlink" title="在连接中，可进行 大数据量 的传输。"></a>在连接中，可进行 大数据量 的传输。</h5></li><li><h5 id="传输完毕后，需释放已建立的连接，效率低。"><a href="#传输完毕后，需释放已建立的连接，效率低。" class="headerlink" title="传输完毕后，需释放已建立的连接，效率低。"></a>传输完毕后，需释放已建立的连接，效率低。</h5></li><li><h5 id="三次握手示意图："><a href="#三次握手示意图：" class="headerlink" title="三次握手示意图："></a>三次握手示意图：</h5><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li></ul></li><li><h5 id="UDP协议（用户数据协议）："><a href="#UDP协议（用户数据协议）：" class="headerlink" title="UDP协议（用户数据协议）："></a>UDP协议（用户数据协议）：</h5><ul><li><h5 id="将数据、源、目的-封装成数据包，不需要建立连接"><a href="#将数据、源、目的-封装成数据包，不需要建立连接" class="headerlink" title="将数据、源、目的 封装成数据包，不需要建立连接"></a>将数据、源、目的 封装成数据包，不需要建立连接</h5></li><li><h5 id="每个数据报的大小-限制在-64K内"><a href="#每个数据报的大小-限制在-64K内" class="headerlink" title="每个数据报的大小 限制在 64K内"></a>每个数据报的大小 限制在 64K内</h5></li><li><h5 id="因-无需连接，因此是不可靠的"><a href="#因-无需连接，因此是不可靠的" class="headerlink" title="因 无需连接，因此是不可靠的"></a>因 无需连接，因此是不可靠的</h5></li><li><h5 id="发送数据时-无需释放资源，速度快"><a href="#发送数据时-无需释放资源，速度快" class="headerlink" title="发送数据时 无需释放资源，速度快"></a>发送数据时 无需释放资源，速度快</h5></li></ul></li></ul></li><li><h4 id="5）InetAddress类的使用"><a href="#5）InetAddress类的使用" class="headerlink" title="5）InetAddress类的使用"></a>5）InetAddress类的使用</h4><ul><li><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/InetAddress%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png"></p></li><li><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">//1. 通过getLocalHost 来获取 本机的 机名+ip</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(localHost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.getByName：通过主机名/域名 获取ip地址</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">name</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过InetAddress对象 来获取 域名/主机名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> name.getHostName();</span><br><span class="line">        System.out.println(hostName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 通过InetAddress对象 来获取 ip地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> name.getHostAddress();</span><br><span class="line">        System.out.println(address);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="6-Socket"><a href="#6-Socket" class="headerlink" title="6) Socket"></a>6) Socket</h4><p><img src="/../images/Java%E5%A4%8D%E4%B9%A0/Socket%E7%9A%84%E5%90%AB%E4%B9%89%E7%90%86%E8%A7%A3.png"></p><ul><li><h5 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h5><ul><li><h5 id="Socket（又称-套接字）-开发-网络应用程序-被广泛应用，以至于成为-事实上的标准。"><a href="#Socket（又称-套接字）-开发-网络应用程序-被广泛应用，以至于成为-事实上的标准。" class="headerlink" title="Socket（又称 套接字） 开发 网络应用程序 被广泛应用，以至于成为 事实上的标准。"></a>Socket（又称 套接字） 开发 网络应用程序 被广泛应用，以至于成为 事实上的标准。</h5></li><li><h5 id="通信两端（客户端、服务端）-都要有-Socket，-它是两台机器（通常-客户端-与-服务端-在不同的主机）-间-通信的端点"><a href="#通信两端（客户端、服务端）-都要有-Socket，-它是两台机器（通常-客户端-与-服务端-在不同的主机）-间-通信的端点" class="headerlink" title="通信两端（客户端、服务端） 都要有 Socket， 它是两台机器（通常 客户端 与 服务端 在不同的主机） 间 通信的端点"></a>通信两端（客户端、服务端） 都要有 Socket， 它是两台机器（通常 客户端 与 服务端 在不同的主机） 间 通信的端点</h5></li><li><h5 id="Socket-允许程序把-网络连接-当成一个流，既数据-是在两个Socket间-通过IO传输。"><a href="#Socket-允许程序把-网络连接-当成一个流，既数据-是在两个Socket间-通过IO传输。" class="headerlink" title="Socket 允许程序把 网络连接 当成一个流，既数据 是在两个Socket间 通过IO传输。"></a>Socket 允许程序把 网络连接 当成一个流，既数据 是在两个Socket间 通过IO传输。</h5></li><li><h5 id="一般-发起-连接请求的-是客户端，-接受请求的是-服务端。"><a href="#一般-发起-连接请求的-是客户端，-接受请求的是-服务端。" class="headerlink" title="一般 发起 连接请求的 是客户端， 接受请求的是 服务端。"></a>一般 发起 连接请求的 是客户端， 接受请求的是 服务端。</h5></li></ul></li><li><h5 id="TCP通信编程"><a href="#TCP通信编程" class="headerlink" title="TCP通信编程:"></a>TCP通信编程:</h5><ul><li><h5 id="介绍：-是基于-客户端-服务端的网络通信，-底层使用-TCP-IP协议。-是基于-Socket的TCP编程。"><a href="#介绍：-是基于-客户端-服务端的网络通信，-底层使用-TCP-IP协议。-是基于-Socket的TCP编程。" class="headerlink" title="介绍： 是基于 客户端-服务端的网络通信， 底层使用 TCP-IP协议。 是基于 Socket的TCP编程。"></a>介绍： 是基于 客户端-服务端的网络通信， 底层使用 TCP-IP协议。 是基于 Socket的TCP编程。</h5></li><li><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用:"></a>使用:</h5><ul><li><h5 id="TCP字节流编程"><a href="#TCP字节流编程" class="headerlink" title="TCP字节流编程"></a>TCP字节流编程</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 22:04</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 通过InetAddress.getLocalHost(),端口9999（监听的客户端端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取outputStream 对服务端传输数据</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,server&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput(); <span class="comment">//设置结束标志，不然会让服务端无法识别 什么时候结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 接受 服务端 传回来的信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> readLen=<span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;接受到客户端传回来的数据&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((readLen=inputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 关闭各种流</span></span><br><span class="line">        socket.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 22:04</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.通过 端口9999 创建serverSocket 监听服务</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端 开始 监听....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过 accept()：如果监听到 客户端传来的连接，则可以创建Socket对象 来实现各种操作</span></span><br><span class="line">        <span class="comment">//                 如果 没有监听到，则会阻塞在这里 ，下面的程序不会执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建 InputStream对象 接受 客户端 传送过来的数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> readLen=<span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;服务端接受到的数据：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((readLen=inputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建 outputStream来 回应给 客户端</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,client&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();<span class="comment">//设置结束标志，不让会让 服务端无法识别什么时候结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 关闭各种流</span></span><br><span class="line">        serverSocket.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="TCP-字符流编程"><a href="#TCP-字符流编程" class="headerlink" title="TCP 字符流编程"></a>TCP 字符流编程</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 22:04</span></span><br><span class="line"><span class="comment"> * 客户端(字符流传输)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 通过InetAddress.getLocalHost()(监听本机),端口9999（监听的客户端端口）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 使用 字符流的方式 传输数据给 服务端</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//使用转换流 把 outputStream字节流 转换为 字符流</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);</span><br><span class="line">        <span class="comment">//用BufferedWriter 来写入数据</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);</span><br><span class="line">        writer1.write(<span class="string">&quot;hello,server&quot;</span>);</span><br><span class="line">        writer1.newLine(); <span class="comment">//相当于结束标志，但要求是 服务端接受数据 必须用 readLine（） 才能识别</span></span><br><span class="line">        writer1.flush(); <span class="comment">//必须调用该方法 才能写入数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 接受 服务端 传回来的信息 使用字符流接受数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="comment">//转换成 字符处理流 方便读取信息 和 提高效率</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">        System.out.println(<span class="string">&quot;接受到服务端传回的数据:&quot;</span>+reader1.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 关闭各种流 尽量 后打开的先关闭</span></span><br><span class="line">        reader1.close();</span><br><span class="line">        writer1.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/7 22:04</span></span><br><span class="line"><span class="comment"> * 服务端（字符流传输）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.通过 端口9999 创建serverSocket 监听服务</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端 开始 监听....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过 accept()：如果监听到 客户端传来的连接，则可以创建Socket对象 来实现各种操作</span></span><br><span class="line">        <span class="comment">//                 如果 没有监听到，则会阻塞在这里 ，下面的程序不会执行</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建 InputStream对象 接受 客户端 传送过来的数据(字符流)</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">        System.out.print(<span class="string">&quot;服务端接受到的数据：&quot;</span>+reader1.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建 outputStream来 回应给 客户端(使用字符流)</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);</span><br><span class="line">        writer1.write(<span class="string">&quot;hello,client&quot;</span>);</span><br><span class="line">        writer1.newLine();</span><br><span class="line">        writer1.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 关闭各种流</span></span><br><span class="line">        writer1.close();</span><br><span class="line">        reader1.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><h4 id="netstat指令"><a href="#netstat指令" class="headerlink" title="netstat指令"></a>netstat指令</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/netstat%E6%8C%87%E4%BB%A4.png"></p><h5 id="当-客户端-连接-服务端后，客户端也会被分配一个端口-来与-服务端进行连接，而这个端口-是由TCP-IP-默认分配的。"><a href="#当-客户端-连接-服务端后，客户端也会被分配一个端口-来与-服务端进行连接，而这个端口-是由TCP-IP-默认分配的。" class="headerlink" title="当 客户端 连接 服务端后，客户端也会被分配一个端口 来与 服务端进行连接，而这个端口 是由TCP&#x2F;IP  默认分配的。"></a>当 客户端 连接 服务端后，客户端也会被分配一个端口 来与 服务端进行连接，而这个端口 是由TCP&#x2F;IP  默认分配的。</h5></li><li><h4 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/UDP%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86.png"></p><ul><li><h5 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li><h5 id="DatagramSocket-与-DatagramPacket-类-实现了-基于UDP的协议编程"><a href="#DatagramSocket-与-DatagramPacket-类-实现了-基于UDP的协议编程" class="headerlink" title="DatagramSocket 与 DatagramPacket 类 实现了 基于UDP的协议编程"></a>DatagramSocket 与 DatagramPacket 类 实现了 基于UDP的协议编程</h5></li><li><h5 id="UDP数据-根据-DatagramSocket-发送和接收，但系统不保证-数据是否能安全到达，或者什么时候到达。"><a href="#UDP数据-根据-DatagramSocket-发送和接收，但系统不保证-数据是否能安全到达，或者什么时候到达。" class="headerlink" title="UDP数据 根据 DatagramSocket 发送和接收，但系统不保证 数据是否能安全到达，或者什么时候到达。"></a>UDP数据 根据 DatagramSocket 发送和接收，但系统不保证 数据是否能安全到达，或者什么时候到达。</h5></li><li><h5 id="DatagramPacket对象-封装了-UDP的数据信息，里面还包含了-发送端的-IP地址和端口号，以及-发送端的-IP地址和-端口号。"><a href="#DatagramPacket对象-封装了-UDP的数据信息，里面还包含了-发送端的-IP地址和端口号，以及-发送端的-IP地址和-端口号。" class="headerlink" title="DatagramPacket对象 封装了 UDP的数据信息，里面还包含了 发送端的 IP地址和端口号，以及 发送端的 IP地址和 端口号。"></a>DatagramPacket对象 封装了 UDP的数据信息，里面还包含了 发送端的 IP地址和端口号，以及 发送端的 IP地址和 端口号。</h5></li><li><h5 id="UDP协议中，每个数据报都存有完整的地址信息，因此不需要建立-发送端和接受端的连接。因而，没有客户端和服务端的说法。"><a href="#UDP协议中，每个数据报都存有完整的地址信息，因此不需要建立-发送端和接受端的连接。因而，没有客户端和服务端的说法。" class="headerlink" title="UDP协议中，每个数据报都存有完整的地址信息，因此不需要建立 发送端和接受端的连接。因而，没有客户端和服务端的说法。"></a>UDP协议中，每个数据报都存有完整的地址信息，因此不需要建立 发送端和接受端的连接。因而，没有客户端和服务端的说法。</h5></li></ul></li><li><h5 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/9 12:36</span></span><br><span class="line"><span class="comment"> * 端口A 等待接受 端口B 传来的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 创建DatagramSocket 对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建DatagramPacket对象，实现对接受数据的封装</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 等待接受数据，若没有接受，则回阻塞</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.对数据 进行解封 并输出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength(); <span class="comment">//获取长度，因为未必获取的长度就是1024字节</span></span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.对端口B 回应信息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1=<span class="string">&quot;收到&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes1, bytes1.length, InetAddress.getByName(<span class="string">&quot;192.168.239.1&quot;</span>), <span class="number">9998</span>);</span><br><span class="line">        socket.send(datagramPacket);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 关闭流</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/9 12:36</span></span><br><span class="line"><span class="comment"> * 端口B 实现对 端口A 发送数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="string">&quot;hello,明天吃火锅&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//获取 DatagramPacket对像</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(<span class="string">&quot;192.168.239.1&quot;</span>), <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//发送信息</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接受 端口A 传来的回应信息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes1, bytes1.length);</span><br><span class="line">        socket.receive(datagramPacket);</span><br><span class="line">        <span class="type">byte</span>[] data = datagramPacket.getData();</span><br><span class="line">        <span class="type">int</span> length=datagramPacket.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-java-反射机制"><a href="#6-java-反射机制" class="headerlink" title="6. java 反射机制"></a>6. java 反射机制</h3><ul><li><h4 id="（1）含义：在加载完类后，在堆中就会产生一个-Class类型的对象（一个类只能有一个对象），这个对象包含了类的所有信息。这个对象-就像是类的-镜子，所以将这一机制称为-反射。"><a href="#（1）含义：在加载完类后，在堆中就会产生一个-Class类型的对象（一个类只能有一个对象），这个对象包含了类的所有信息。这个对象-就像是类的-镜子，所以将这一机制称为-反射。" class="headerlink" title="（1）含义：在加载完类后，在堆中就会产生一个 Class类型的对象（一个类只能有一个对象），这个对象包含了类的所有信息。这个对象 就像是类的 镜子，所以将这一机制称为 反射。"></a>（1）含义：在加载完类后，在堆中就会产生一个 Class类型的对象（一个类只能有一个对象），这个对象包含了类的所有信息。这个对象 就像是类的 镜子，所以将这一机制称为 反射。</h4></li><li><h4 id="（2）反射原理图"><a href="#（2）反射原理图" class="headerlink" title="（2）反射原理图"></a>（2）反射原理图</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p></li><li><h4 id="（3）反射相关的主要类"><a href="#（3）反射相关的主要类" class="headerlink" title="（3）反射相关的主要类"></a>（3）反射相关的主要类</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%B1%BB.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">    <span class="comment">//不修改源码，通过配置文件来获取类信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取properties文件 里面的配置属性</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\cat.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">pathName</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;pathName&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 创建 class对象</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(pathName); <span class="comment">//加载类，获取Class类型对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance(); <span class="comment">// 这一步，才是获取Cat的实例</span></span><br><span class="line">    System.out.println(o.getClass()); <span class="comment">//getClass() 获取运行类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 调用 Cat里面的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">    <span class="comment">//为了提高 反射调用类方法的 效率</span></span><br><span class="line">    <span class="comment">//可以通过关闭 安全检查来提高效率</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>); <span class="comment">//关闭安全检查</span></span><br><span class="line">    method.invoke(o); <span class="comment">//正常：类.对象 而反射中，是方法.invoke(对象)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 调用构造方法</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();<span class="comment">//无参构造</span></span><br><span class="line">    System.out.println(<span class="string">&quot;\n无参构造：&quot;</span>+constructor);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> cls.getConstructor(String.class); <span class="comment">//有参构造，传入有参的类型来识别是哪个有参构造</span></span><br><span class="line">    System.out.println(<span class="string">&quot;有参构造：&quot;</span>+constructor1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 调用成员变量(注意：不能获取 私有的成员变量)</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;name&quot;</span>); <span class="comment">//获取变量名</span></span><br><span class="line">    System.out.println(nameField.get(o)); <span class="comment">//反射：变量名.get（类）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ss</p></li></ul><h3 id="7-Class-类"><a href="#7-Class-类" class="headerlink" title="7. Class 类"></a>7. Class 类</h3><ul><li><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="(1) 基本介绍"></a>(1) 基本介绍</h4><ul><li><h5 id="1-Class-类-也是类-因此也会继承-Object类"><a href="#1-Class-类-也是类-因此也会继承-Object类" class="headerlink" title="1. Class 类 也是类 因此也会继承 Object类"></a>1. Class 类 也是类 因此也会继承 Object类</h5></li><li><h5 id="2-Class-类，不是-new出来的，而是系统创建的。"><a href="#2-Class-类，不是-new出来的，而是系统创建的。" class="headerlink" title="2. Class 类，不是 new出来的，而是系统创建的。"></a>2. Class 类，不是 new出来的，而是系统创建的。</h5></li><li><h5 id="3-对于某个类的Class对象，在内存中-只会有一份，因为类只加载一次。"><a href="#3-对于某个类的Class对象，在内存中-只会有一份，因为类只加载一次。" class="headerlink" title="3. 对于某个类的Class对象，在内存中 只会有一份，因为类只加载一次。"></a>3. 对于某个类的Class对象，在内存中 只会有一份，因为类只加载一次。</h5></li><li><h5 id="4-每个类的实例-都会记得自己是由-哪个Class实例所生成"><a href="#4-每个类的实例-都会记得自己是由-哪个Class实例所生成" class="headerlink" title="4. 每个类的实例 都会记得自己是由 哪个Class实例所生成"></a>4. 每个类的实例 都会记得自己是由 哪个Class实例所生成</h5></li><li><h5 id="5-Class对象-是存放在-堆的。"><a href="#5-Class对象-是存放在-堆的。" class="headerlink" title="5. Class对象 是存放在 堆的。"></a>5. Class对象 是存放在 堆的。</h5></li></ul></li><li><h4 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="(2) 常用方法"></a>(2) 常用方法</h4><p>![](&#x2F;Java复习&#x2F;Class类的 常用方法.png)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">       <span class="comment">//1. 获取类对象</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.exam.reflectExam.Cat&quot;</span>);</span><br><span class="line">       <span class="comment">//2. 输入cls</span></span><br><span class="line">       System.out.println(cls); <span class="comment">//输出是哪个 对象的class 类</span></span><br><span class="line">       System.out.println(cls.getClass()); <span class="comment">//输出 运行类型 java.lang.Class</span></span><br><span class="line">       <span class="comment">//3. 得到包名</span></span><br><span class="line">       <span class="type">Package</span> <span class="variable">packageName</span> <span class="operator">=</span> cls.getPackage();</span><br><span class="line">       System.out.println(<span class="string">&quot;包名：&quot;</span>+packageName);</span><br><span class="line">       <span class="comment">//4. 得到全类名</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">clsName</span> <span class="operator">=</span> cls.getName();</span><br><span class="line">       System.out.println(<span class="string">&quot;全类名：&quot;</span>+clsName);</span><br><span class="line">       <span class="comment">//5. 通过cls 创建实例对象</span></span><br><span class="line">       <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)cls.newInstance();</span><br><span class="line">       System.out.println(cat);</span><br><span class="line">       <span class="comment">//6. 通过反射 获取 属性</span></span><br><span class="line">       <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       System.out.println(name.get(cat));</span><br><span class="line">       <span class="comment">//7. 通过反射 对属性 进行赋值</span></span><br><span class="line">       name.set(cat,<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">       System.out.println(name.get(cat));</span><br><span class="line">       <span class="comment">//8. 获取所有的属性字段</span></span><br><span class="line">       Field[] fields = cls.getFields();</span><br><span class="line">       <span class="keyword">for</span>(Field f:fields)&#123;</span><br><span class="line">           System.out.println(f.get(cat));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="3-获取Class类对象"><a href="#3-获取Class类对象" class="headerlink" title="(3) 获取Class类对象"></a>(3) 获取Class类对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String classPath=<span class="string">&quot;com.exam.reflectExam.Cat&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. Class.forName</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classPath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 类名的Class，应用场景：用于参数传递</span></span><br><span class="line">            Class&lt;Cat&gt; cls2 = Cat.class;</span><br><span class="line">            System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 对象.getClass(),应用场景：有对象实例的情况下</span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Cat</span>&gt; cls3 = cat.getClass();</span><br><span class="line">            System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 通过类加载器 来获取到 类的Class 对象</span></span><br><span class="line">            <span class="comment">//(1) 先得到类加载器</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> cat.getClass().getClassLoader();</span><br><span class="line">            <span class="comment">//(2) 通过类加载器得到Class对象</span></span><br><span class="line">            Class&lt;?&gt; cls4 = classLoader.loadClass(classPath);</span><br><span class="line">            System.out.println(cls4);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.基本数据类型 与 对用的包装类 获取Class对象</span></span><br><span class="line">            Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">            Class&lt;Integer&gt; type = Integer.TYPE;</span><br><span class="line">            System.out.println(integerClass);</span><br><span class="line">            System.out.println(type);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="4-类加载"><a href="#4-类加载" class="headerlink" title="(4)  类加载"></a>(4)  类加载</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%9B%BE.png"></p><ul><li><h5 id="1-基本说明："><a href="#1-基本说明：" class="headerlink" title="1. 基本说明："></a>1. 基本说明：</h5><ul><li><h5 id="静态加载：编译时就-加载相关的类，如果没有该类-就会报错，依赖性很强。"><a href="#静态加载：编译时就-加载相关的类，如果没有该类-就会报错，依赖性很强。" class="headerlink" title="静态加载：编译时就 加载相关的类，如果没有该类 就会报错，依赖性很强。"></a>静态加载：编译时就 加载相关的类，如果没有该类 就会报错，依赖性很强。</h5></li><li><h5 id="动态加载：运行时-才加载需要的类，如果不运行到该类，则不会报错。降低了依赖性。"><a href="#动态加载：运行时-才加载需要的类，如果不运行到该类，则不会报错。降低了依赖性。" class="headerlink" title="动态加载：运行时 才加载需要的类，如果不运行到该类，则不会报错。降低了依赖性。"></a>动态加载：运行时 才加载需要的类，如果不运行到该类，则不会报错。降低了依赖性。</h5></li></ul></li><li><h5 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2. 类加载的时机"></a>2. 类加载的时机</h5><ul><li><h5 id="当-创建对象时（new）（静态加载）"><a href="#当-创建对象时（new）（静态加载）" class="headerlink" title="当 创建对象时（new）（静态加载）"></a>当 创建对象时（new）（静态加载）</h5></li><li><h5 id="当子类被加载时，-父类也会被加载-（静态加载）"><a href="#当子类被加载时，-父类也会被加载-（静态加载）" class="headerlink" title="当子类被加载时， 父类也会被加载 （静态加载）"></a>当子类被加载时， 父类也会被加载 （静态加载）</h5></li><li><h5 id="调用类中的-静态成员时（静态加载）"><a href="#调用类中的-静态成员时（静态加载）" class="headerlink" title="调用类中的 静态成员时（静态加载）"></a>调用类中的 静态成员时（静态加载）</h5></li><li><h5 id="通过-反射机制（动态加载）"><a href="#通过-反射机制（动态加载）" class="headerlink" title="通过 反射机制（动态加载）"></a>通过 反射机制（动态加载）</h5></li></ul></li><li><h5 id="3-类加载-各阶段完成的任务图"><a href="#3-类加载-各阶段完成的任务图" class="headerlink" title="3. 类加载 各阶段完成的任务图"></a>3. 类加载 各阶段完成的任务图</h5><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%90%84%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1.png"></p></li><li><h5 id="4-类加载-各阶段介绍"><a href="#4-类加载-各阶段介绍" class="headerlink" title="4. 类加载 各阶段介绍"></a>4. 类加载 各阶段介绍</h5><ul><li><h5 id="加载阶段：JVM-在该阶段的主要目的是-将字节码从不同的数据源（可能是-class文件、jar包等）转化为-二进制字节流-加载到内存中，并生成一个代表该类的-java-lang-class-类。"><a href="#加载阶段：JVM-在该阶段的主要目的是-将字节码从不同的数据源（可能是-class文件、jar包等）转化为-二进制字节流-加载到内存中，并生成一个代表该类的-java-lang-class-类。" class="headerlink" title="加载阶段：JVM 在该阶段的主要目的是 将字节码从不同的数据源（可能是 class文件、jar包等）转化为 二进制字节流 加载到内存中，并生成一个代表该类的 java.lang.class 类。"></a>加载阶段：JVM 在该阶段的主要目的是 将字节码从不同的数据源（可能是 class文件、jar包等）转化为 二进制字节流 加载到内存中，并生成一个代表该类的 java.lang.class 类。</h5></li><li><h5 id="连接阶段："><a href="#连接阶段：" class="headerlink" title="连接阶段："></a>连接阶段：</h5><ul><li><h5 id="验证过程："><a href="#验证过程：" class="headerlink" title="验证过程："></a>验证过程：</h5><ul><li><h5 id="目的是为了-确保Class-文件的字节流-中包含的信息-符合当前的虚拟机要求，并且不会危害到虚拟机自身的安全。"><a href="#目的是为了-确保Class-文件的字节流-中包含的信息-符合当前的虚拟机要求，并且不会危害到虚拟机自身的安全。" class="headerlink" title="目的是为了 确保Class 文件的字节流 中包含的信息 符合当前的虚拟机要求，并且不会危害到虚拟机自身的安全。"></a>目的是为了 确保Class 文件的字节流 中包含的信息 符合当前的虚拟机要求，并且不会危害到虚拟机自身的安全。</h5></li><li><h5 id="验证包括-文件格式验证（是否已-魔数-oxcafebabe开头）、元数据验证、字节码验证-和-符号引用验证"><a href="#验证包括-文件格式验证（是否已-魔数-oxcafebabe开头）、元数据验证、字节码验证-和-符号引用验证" class="headerlink" title="验证包括 文件格式验证（是否已 魔数 oxcafebabe开头）、元数据验证、字节码验证 和 符号引用验证"></a>验证包括 文件格式验证（是否已 魔数 oxcafebabe开头）、元数据验证、字节码验证 和 符号引用验证</h5></li><li><h5 id="由于-验证会耗一定的加载时间，因此可以通过-Xverify-none-参数-来关闭大部分的类验证措施，缩短加载时间。"><a href="#由于-验证会耗一定的加载时间，因此可以通过-Xverify-none-参数-来关闭大部分的类验证措施，缩短加载时间。" class="headerlink" title="由于 验证会耗一定的加载时间，因此可以通过 -Xverify:none 参数 来关闭大部分的类验证措施，缩短加载时间。"></a>由于 验证会耗一定的加载时间，因此可以通过 -Xverify:none 参数 来关闭大部分的类验证措施，缩短加载时间。</h5></li></ul></li><li><h5 id="准备过程：JVM-在该阶段-会对静态变量-分配内存并默认初始化（既-对静态变量属性-初始化值-如static-int-0，static-boolean-false-等）-这些变量-所使用的内存-都将在-方法区中进行分配。"><a href="#准备过程：JVM-在该阶段-会对静态变量-分配内存并默认初始化（既-对静态变量属性-初始化值-如static-int-0，static-boolean-false-等）-这些变量-所使用的内存-都将在-方法区中进行分配。" class="headerlink" title="准备过程：JVM 在该阶段 会对静态变量 分配内存并默认初始化（既 对静态变量属性 初始化值 如static int&#x3D;0，static boolean&#x3D;false 等）.这些变量 所使用的内存 都将在 方法区中进行分配。"></a>准备过程：JVM 在该阶段 会对静态变量 分配内存并默认初始化（既 对静态变量属性 初始化值 如static int&#x3D;0，static boolean&#x3D;false 等）.这些变量 所使用的内存 都将在 方法区中进行分配。</h5></li><li><h5 id="解析过程：虚拟机-将-常量池内的符号引用-替换为-直接引用的过程。"><a href="#解析过程：虚拟机-将-常量池内的符号引用-替换为-直接引用的过程。" class="headerlink" title="解析过程：虚拟机 将 常量池内的符号引用 替换为 直接引用的过程。"></a>解析过程：虚拟机 将 常量池内的符号引用 替换为 直接引用的过程。</h5></li></ul></li><li><h5 id="初始化阶段："><a href="#初始化阶段：" class="headerlink" title="初始化阶段："></a>初始化阶段：</h5><ul><li><h5 id="到该阶段-才是真正的开始执行类中-定义的-java程序代码，此阶段是-执行-clinit-方法的过程。"><a href="#到该阶段-才是真正的开始执行类中-定义的-java程序代码，此阶段是-执行-clinit-方法的过程。" class="headerlink" title="到该阶段 才是真正的开始执行类中 定义的 java程序代码，此阶段是 执行&lt; clinit &gt;() 方法的过程。"></a>到该阶段 才是真正的开始执行类中 定义的 java程序代码，此阶段是 执行&lt; clinit &gt;() 方法的过程。</h5></li><li><h5 id="clinit-方法-是由编译器-按-语句-在源文件中出现的顺序，依次自动收集类中的-所有静态变量-的赋值动作-和-静态代码块中的语句，并进行合并。"><a href="#clinit-方法-是由编译器-按-语句-在源文件中出现的顺序，依次自动收集类中的-所有静态变量-的赋值动作-和-静态代码块中的语句，并进行合并。" class="headerlink" title="&lt; clinit &gt;() 方法 是由编译器 按 语句 在源文件中出现的顺序，依次自动收集类中的 所有静态变量 的赋值动作 和 静态代码块中的语句，并进行合并。"></a>&lt; clinit &gt;() 方法 是由编译器 按 语句 在源文件中出现的顺序，依次自动收集类中的 所有静态变量 的赋值动作 和 静态代码块中的语句，并进行合并。</h5></li><li><h5 id="虚拟机-会保证一个类的-clinit-方法在多线程的环境中-被正确地-加锁、同步，如果-多个线程同时去-初始化同一个类，那么只会-有一个线程去执行-这个类的-clinit-方法-，其它线程就会进入-阻塞状态，-直到活动线程-clinit-方法执行完毕"><a href="#虚拟机-会保证一个类的-clinit-方法在多线程的环境中-被正确地-加锁、同步，如果-多个线程同时去-初始化同一个类，那么只会-有一个线程去执行-这个类的-clinit-方法-，其它线程就会进入-阻塞状态，-直到活动线程-clinit-方法执行完毕" class="headerlink" title="虚拟机 会保证一个类的 &lt; clinit &gt;() 方法在多线程的环境中 被正确地 加锁、同步，如果 多个线程同时去 初始化同一个类，那么只会 有一个线程去执行 这个类的 &lt; clinit &gt;() 方法 ，其它线程就会进入 阻塞状态， 直到活动线程 &lt; clinit &gt;() 方法执行完毕"></a>虚拟机 会保证一个类的 &lt; clinit &gt;() 方法在多线程的环境中 被正确地 加锁、同步，如果 多个线程同时去 初始化同一个类，那么只会 有一个线程去执行 这个类的 &lt; clinit &gt;() 方法 ，其它线程就会进入 阻塞状态， 直到活动线程 &lt; clinit &gt;() 方法执行完毕</h5></li></ul></li></ul></li></ul></li><li><h4 id="5-通过-反射-获取类结构信息-的各种方法"><a href="#5-通过-反射-获取类结构信息-的各种方法" class="headerlink" title="(5) 通过 反射 获取类结构信息 的各种方法"></a>(5) 通过 反射 获取类结构信息 的各种方法</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%BB%93%E6%9E%8401.png"></p><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%BB%93%E6%9E%8402.png"></p></li></ul><p>​<img src="/Java%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%BB%93%E6%9E%8403.png"></p><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%BB%93%E6%9E%8404.png"></p><ul><li><h4 id="6-反射爆破机制"><a href="#6-反射爆破机制" class="headerlink" title="(6) 反射爆破机制"></a>(6) 反射爆破机制</h4><ul><li><h5 id="含义：-当使用-反射来获取类的结构时（如-属性、方法、构造器-等），自然会遇到有-private修饰的-类结构，这样就需要用-爆破的方法来获取-使用-private修饰的-类结构了。"><a href="#含义：-当使用-反射来获取类的结构时（如-属性、方法、构造器-等），自然会遇到有-private修饰的-类结构，这样就需要用-爆破的方法来获取-使用-private修饰的-类结构了。" class="headerlink" title="含义： 当使用 反射来获取类的结构时（如 属性、方法、构造器 等），自然会遇到有 private修饰的 类结构，这样就需要用 爆破的方法来获取 使用 private修饰的 类结构了。"></a>含义： 当使用 反射来获取类的结构时（如 属性、方法、构造器 等），自然会遇到有 private修饰的 类结构，这样就需要用 爆破的方法来获取 使用 private修饰的 类结构了。</h5></li><li><h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 获取 Student 的class 对象</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;com.exam.reflectExam.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 通过 class 对象 获取 实例对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">student</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 演示 获取属性</span></span><br><span class="line">        <span class="comment">//3.1 通过 getField() 方法 可获得 public 修饰的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.set(student,<span class="string">&quot;jack&quot;</span>); <span class="comment">//给属性赋值</span></span><br><span class="line">        System.out.println(name.get(student));</span><br><span class="line">        <span class="comment">//3.2 通过 getDeclaredField() 可获取 所有的属性(public、private 等)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;age&quot;</span>);  <span class="comment">//其它的类结构方法类似 都是getDeclaredxxxx</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//爆破私有属性</span></span><br><span class="line">        age.setAccessible(<span class="literal">true</span>); <span class="comment">//爆破处理，因为 age是private修饰的 ，需要爆破处理</span></span><br><span class="line">    </span><br><span class="line">        age.set(student,<span class="number">23</span>);</span><br><span class="line">        <span class="comment">//System.out.println(age.get(student));</span></span><br><span class="line">        <span class="comment">//这里的参数可以为 null，因为 age 是静态资源。</span></span><br><span class="line">        System.out.println(age.get(<span class="literal">null</span>));</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Java绘图&quot;&gt;&lt;a href=&quot;#1-Java绘图&quot; class=&quot;headerlink&quot; title=&quot;1. Java绘图&quot;&gt;&lt;/a&gt;1. Java绘图&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1-绘图坐标体系&quot;&gt;&lt;a href=&quot;#1-绘图坐标体系&quot; </summary>
      
    
    
    
    
    <category term="-Java -复习" scheme="http://example.com/tags/Java-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java复习-5</title>
    <link href="http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-5/"/>
    <id>http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0-5/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-09-21T04:27:32.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、JDBC"><a href="#一、JDBC" class="headerlink" title="一、JDBC"></a>一、JDBC</h3><ul><li><h4 id="1-介绍：JDBC为-访问不同的数据库接口-提供了同一的接口，为使用者-屏蔽了细节问题。-程序员可以通过使用JDBC-，可以连接-任何提供了JDBC驱动程序的数据库系统。-实现用-java-操作-数据库的-功能。"><a href="#1-介绍：JDBC为-访问不同的数据库接口-提供了同一的接口，为使用者-屏蔽了细节问题。-程序员可以通过使用JDBC-，可以连接-任何提供了JDBC驱动程序的数据库系统。-实现用-java-操作-数据库的-功能。" class="headerlink" title="(1) 介绍：JDBC为 访问不同的数据库接口 提供了同一的接口，为使用者 屏蔽了细节问题。 程序员可以通过使用JDBC ，可以连接 任何提供了JDBC驱动程序的数据库系统。 实现用 java 操作 数据库的 功能。"></a>(1) 介绍：JDBC为 访问不同的数据库接口 提供了同一的接口，为使用者 屏蔽了细节问题。 程序员可以通过使用JDBC ，可以连接 任何提供了JDBC驱动程序的数据库系统。 实现用 java 操作 数据库的 功能。</h4></li><li><h4 id="2-原理："><a href="#2-原理：" class="headerlink" title="(2) 原理："></a>(2) 原理：</h4><ul><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/JDBC%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><h4 id="概括来说，jdbc-为了实现-java能够操作-各不同公司的-数据库，提供了-一套共用共识的-接口规范。通过-该接口规范-来实现对-各不相同的-数据库系统-进行-数据库操作。"><a href="#概括来说，jdbc-为了实现-java能够操作-各不同公司的-数据库，提供了-一套共用共识的-接口规范。通过-该接口规范-来实现对-各不相同的-数据库系统-进行-数据库操作。" class="headerlink" title="概括来说，jdbc 为了实现 java能够操作 各不同公司的 数据库，提供了 一套共用共识的 接口规范。通过 该接口规范 来实现对 各不相同的 数据库系统 进行 数据库操作。"></a>概括来说，jdbc 为了实现 java能够操作 各不同公司的 数据库，提供了 一套共用共识的 接口规范。通过 该接口规范 来实现对 各不相同的 数据库系统 进行 数据库操作。</h4></li></ul></li><li><h4 id="3-简单入门-jdbc-编写"><a href="#3-简单入门-jdbc-编写" class="headerlink" title="(3) 简单入门 jdbc 编写"></a>(3) 简单入门 jdbc 编写</h4><ul><li><pre><code class="java">public static void main(String[] args) throws SQLException &#123;        //1. 拿到 drive 可以用来建立连接(需要引入 mysql-connector-java-8.0.18.jar)        Driver driver = new Driver();        //2.配置连接的信息        //serverTimezone=GMT%2d8 : 进行时区设置        String url=&quot;jdbc:mysql://localhost:3306/exam_02?serverTimezone=GMT%2d8&quot;; //连接地址        Properties properties = new Properties();        properties.setProperty(&quot;user&quot;,&quot;root&quot;);        properties.setProperty(&quot;password&quot;,&quot;root&quot;);        //3.开启连接 并得到Statement对象 用于执行sql语句 和 接受返回的结果        Connection connect = driver.connect(url, properties);        Statement statement = connect.createStatement();        //4. 编写dml语句 并执行        String sql=&quot;insert into actor values(null,&#39;jack&#39;,&#39;男&#39;,&#39;1999.10.14&#39;,&#39;15218423290&#39;)&quot;;        int i = statement.executeUpdate(sql);        System.out.println(i&gt;0?&quot;成功&quot;:&quot;失败&quot;);    &#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  - #### 注意两点：1. jar包 要与 mysql数据库的版本对应 不然会报错。2. 6.0以上的版本jar包 会存在 时区矫正的设置 需要设置serverTimezone=GMT%2d8 来 矫正时区。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### (4) ResultSet 的使用</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    //2. 执行dml语句</span><br><span class="line">            Statement statement = connection.createStatement();</span><br><span class="line">            String sql=&quot;select *from actor&quot;;</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">      </span><br><span class="line">            //3. 循环读取resultSet</span><br><span class="line">            while (resultSet.next())&#123;</span><br><span class="line">                //根据 resultSet.next 来指向 下一行 </span><br><span class="line">                int id =resultSet.getInt(1);</span><br><span class="line">                String name=resultSet.getString(2);</span><br><span class="line">                String sex=resultSet.getString(3);</span><br><span class="line">                Date date=resultSet.getDate(4);</span><br><span class="line">                String phone=resultSet.getString(5);</span><br><span class="line">      </span><br><span class="line">                System.out.println(&quot;id:&quot;+id+&quot;\tname:&quot;+name+&quot;\tsex&quot;+sex+&quot;\tdate:&quot;+date+&quot;\tphone&quot;+phone);</span><br><span class="line">      </span><br><span class="line">            &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></code></pre></li><li><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>![](&#x2F;Java复习&#x2F;resultSet 分析.png)</p></li></ul></li><li><h4 id="5-Statement"><a href="#5-Statement" class="headerlink" title="(5) Statement"></a>(5) Statement</h4><ul><li><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li><h4 id="1-statement-主要用于-执行sql语句-并-返回执行结果。"><a href="#1-statement-主要用于-执行sql语句-并-返回执行结果。" class="headerlink" title="1. statement 主要用于 执行sql语句 并 返回执行结果。"></a>1. statement 主要用于 执行sql语句 并 返回执行结果。</h4></li><li><h4 id="2-statement接口的-实现类型有三个：-Statement、PreparedStatement、CallableStatement"><a href="#2-statement接口的-实现类型有三个：-Statement、PreparedStatement、CallableStatement" class="headerlink" title="2. statement接口的 实现类型有三个： Statement、PreparedStatement、CallableStatement"></a>2. statement接口的 实现类型有三个： Statement、PreparedStatement、CallableStatement</h4></li><li><h4 id="3-使用-statement对象-来执行-sql-会存在-Sql-注入问题。-而-PreparedStatement-可以有效预防这种问题，因此-大多都使用-PreparedStatement-来-执行sql语句"><a href="#3-使用-statement对象-来执行-sql-会存在-Sql-注入问题。-而-PreparedStatement-可以有效预防这种问题，因此-大多都使用-PreparedStatement-来-执行sql语句" class="headerlink" title="3. 使用 statement对象 来执行 sql 会存在 Sql 注入问题。 而 PreparedStatement 可以有效预防这种问题，因此 大多都使用 PreparedStatement 来 执行sql语句"></a>3. 使用 statement对象 来执行 sql 会存在 Sql 注入问题。 而 PreparedStatement 可以有效预防这种问题，因此 大多都使用 PreparedStatement 来 执行sql语句</h4></li></ul></li><li><h4 id="什么是Sql注入：当使用sql-进行查询数据时，可能会利用-sql-拼接的方式-来进行-不合法的获取数据。"><a href="#什么是Sql注入：当使用sql-进行查询数据时，可能会利用-sql-拼接的方式-来进行-不合法的获取数据。" class="headerlink" title="什么是Sql注入：当使用sql 进行查询数据时，可能会利用 sql 拼接的方式 来进行 不合法的获取数据。"></a>什么是Sql注入：当使用sql 进行查询数据时，可能会利用 sql 拼接的方式 来进行 不合法的获取数据。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name : 1&#x27; or</span></span><br><span class="line">      <span class="comment">// pwd  ： or &#x27;1&#x27;=&#x27;1 </span></span><br><span class="line"><span class="comment">//这样就成功 用 ’ 去与 sql语句中的 ‘ 匹配 利用 or 来形成正确的查询</span></span><br><span class="line">      String sql=<span class="string">&quot;select *from admin where name=&#x27;1&#x27; or &#x27; and pwd=&#x27; or &#x27;1&#x27;=&#x27;1&#x27; &quot;</span>;</span><br></pre></td></tr></table></figure></li><li><h4 id="PreparedStatement-的使用"><a href="#PreparedStatement-的使用" class="headerlink" title="PreparedStatement 的使用"></a>PreparedStatement 的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, SQLException &#123;</span><br><span class="line">       Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">       String name=scanner.nextLine();</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">       String pwd=scanner.nextLine();</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//1. 创建数据库连接</span></span><br><span class="line">       Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">       <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">       properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\jdbc.properties&quot;</span>));</span><br><span class="line">       <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">       <span class="comment">//2. 获取PreparedStatement</span></span><br><span class="line">       <span class="comment">//使用获取PreparedStatement执行sql sql可用? 来做占位符</span></span><br><span class="line">       String sql=<span class="string">&quot;select * from admin where name=? and pwd=?&quot;</span>;</span><br><span class="line">       <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//3. 为 sql语句赋值</span></span><br><span class="line">       <span class="comment">//preparedStatement.setString(1,name)： 1代表第一个占位符 name 代表参数</span></span><br><span class="line">       preparedStatement.setString(<span class="number">1</span>,name);</span><br><span class="line">       preparedStatement.setString(<span class="number">2</span>,pwd);</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//4. 执行sql 并接受返回结果</span></span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">       <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//5. 使用preparedStatement 来执行 dml语句 其它也一样</span></span><br><span class="line">       String sql2=<span class="string">&quot;insert into admin values(?,?)&quot;</span>;</span><br><span class="line">       <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql2);</span><br><span class="line">       statement.setString(<span class="number">1</span>,name);</span><br><span class="line">       statement.setString(<span class="number">2</span>,pwd);</span><br><span class="line">    </span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate();</span><br><span class="line">       System.out.println(i&gt;<span class="number">0</span>?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    </span><br><span class="line">       resultSet.close();</span><br><span class="line">       preparedStatement.close();</span><br><span class="line">       connection.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="6-JDBC-事务处理"><a href="#6-JDBC-事务处理" class="headerlink" title="(6)  JDBC 事务处理"></a>(6)  JDBC 事务处理</h4><ul><li><h4 id="基本介绍：-1"><a href="#基本介绍：-1" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li><h4 id="JDBC-程序中，获取到连接类Connection对象后，默认时自动提交事务的。既不能够进行回滚操作。"><a href="#JDBC-程序中，获取到连接类Connection对象后，默认时自动提交事务的。既不能够进行回滚操作。" class="headerlink" title="JDBC 程序中，获取到连接类Connection对象后，默认时自动提交事务的。既不能够进行回滚操作。"></a>JDBC 程序中，获取到连接类Connection对象后，默认时自动提交事务的。既不能够进行回滚操作。</h4></li><li><h4 id="若想-取消自动提交事务。则可以调用-Connection-的-setAutoCommit-flase-取消自动提交事务。"><a href="#若想-取消自动提交事务。则可以调用-Connection-的-setAutoCommit-flase-取消自动提交事务。" class="headerlink" title="若想 取消自动提交事务。则可以调用 Connection 的 setAutoCommit(flase) 取消自动提交事务。"></a>若想 取消自动提交事务。则可以调用 Connection 的 setAutoCommit(flase) 取消自动提交事务。</h4></li><li><h4 id="当所有sql-语句执行完毕之后，调用-commit-方法-提交事务"><a href="#当所有sql-语句执行完毕之后，调用-commit-方法-提交事务" class="headerlink" title="当所有sql 语句执行完毕之后，调用 commit() 方法 提交事务"></a>当所有sql 语句执行完毕之后，调用 commit() 方法 提交事务</h4></li><li><h4 id="若需要进行-回滚操作，-调用-roolbacn-方法-回滚事务"><a href="#若需要进行-回滚操作，-调用-roolbacn-方法-回滚事务" class="headerlink" title="若需要进行 回滚操作， 调用 roolbacn(); 方法 回滚事务"></a>若需要进行 回滚操作， 调用 roolbacn(); 方法 回滚事务</h4></li></ul></li><li><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">       PreparedStatement preparedStatement=<span class="literal">null</span>;</span><br><span class="line">       PreparedStatement statement=<span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           connection.setAutoCommit(<span class="literal">false</span>); <span class="comment">//取消自动提交事务</span></span><br><span class="line">    </span><br><span class="line">           String sql=<span class="string">&quot;update acount set money=money-100 where name=&#x27;zs&#x27;&quot;</span>;</span><br><span class="line">           preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">           preparedStatement.executeUpdate();</span><br><span class="line">    </span><br><span class="line">           String sql2=<span class="string">&quot;update acount set money=money+100 where name=&#x27;jack&#x27;&quot;</span>;</span><br><span class="line">           statement = connection.prepareStatement(sql2);</span><br><span class="line">           statement.executeUpdate();</span><br><span class="line">    </span><br><span class="line">           <span class="comment">//顺利执行后 提交事务</span></span><br><span class="line">           connection.commit();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">           throwables.printStackTrace();</span><br><span class="line">           <span class="comment">//如果遇到异常 就进行回滚操作</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               connection.rollback();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//关闭类</span></span><br><span class="line">           JdbcUtils.close(<span class="literal">null</span>,preparedStatement,connection);</span><br><span class="line">           JdbcUtils.close(<span class="literal">null</span>,statement,<span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="7-JDBC-批处理机制"><a href="#7-JDBC-批处理机制" class="headerlink" title="(7)  JDBC 批处理机制"></a>(7)  JDBC 批处理机制</h4><ul><li><h4 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h4><ul><li><h4 id="preparedStatement-addBatch-：讲sql语句封装成batch-并加入底层封装的-arrayList数组"><a href="#preparedStatement-addBatch-：讲sql语句封装成batch-并加入底层封装的-arrayList数组" class="headerlink" title="preparedStatement.addBatch() ：讲sql语句封装成batch 并加入底层封装的 arrayList数组"></a>preparedStatement.addBatch() ：讲sql语句封装成batch 并加入底层封装的 arrayList数组</h4></li><li><h4 id="preparedStatement-executeBatch-执行-批处理容器中的-sql语句"><a href="#preparedStatement-executeBatch-执行-批处理容器中的-sql语句" class="headerlink" title="preparedStatement.executeBatch():  执行 批处理容器中的 sql语句"></a>preparedStatement.executeBatch():  执行 批处理容器中的 sql语句</h4></li><li><h4 id="preparedStatement-clearBatch-清除容器中的sql语句"><a href="#preparedStatement-clearBatch-清除容器中的sql语句" class="headerlink" title="preparedStatement.clearBatch(): 清除容器中的sql语句"></a>preparedStatement.clearBatch(): 清除容器中的sql语句</h4></li><li><pre><code class="java">public static void main(String[] args) throws SQLException &#123;        Connection connection = JdbcUtils.getConnection();        long start=System.currentTimeMillis(); //记录开始时间        String sql=&quot;insert into admin values(?,?)&quot;;        PreparedStatement preparedStatement = connection.prepareStatement(sql);        for(Integer i=0;i&lt;=5000;i++)&#123;            String s = Integer.toString(i);            preparedStatement.setString(1,s);            preparedStatement.setString(2,&quot;666&quot;);            //加进batch的批处理容器中            preparedStatement.addBatch();  //把本条sql语句 加进容器            //每一千条数据 执行以此批处理            if(i%1000==0)&#123;                preparedStatement.executeBatch(); //执行批处理                preparedStatement.clearBatch(); //清除容器中的sql语句            &#125;        &#125;        long end=System.currentTimeMillis();// 记录结束时间        System.out.println(&quot;执行时间为：&quot;+(end-start));        //关闭资源        JdbcUtils.close(null,preparedStatement,connection);    &#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">  - #### addBath() 源码分析:  底层源码中， 维护着一个名为 batchedArgs的ArrayList数组 用于存放 bach。 而 bach里面包含有 你写入的sql语句中 代替? 占位符的 byte[]数组形式的 值。扩容自然是按照 ArrayList 的扩容机制进行扩容。 </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 二、数据库连接池</span><br><span class="line"></span><br><span class="line">- #### (1) 含义：数据库连接池，顾名思义既 存在一个DataSource接口,里面配置了 多个与数据库的连接 既Connection。程序需要数据库连接 可以直接从 连接池中获取 Connection，断开连接后，连接会继续放在 连接池中，而不是像 jdbc，直接断开与数据库的连接。当 连接超过了 最大的连接数时，就会让改请求 加入到等待队列中。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- #### (2) 为什么需要连接池：</span><br><span class="line"></span><br><span class="line">  ![](/Java复习/数据库连接池.png)</span><br><span class="line"></span><br><span class="line">  - #### 传统的JDBC数据库 是使用 DriverManager 来获取连接的，每次建立连接都需要将 Connection 加载到内存中，再验证ip地址、用户名、密码等。 每需要一个连接，就向数据库进行一次访问，会浪费许多的 系统资源，容易造成 服务器崩溃。</span><br><span class="line"></span><br><span class="line">  - #### 每一次数据库连接，使用完都需要断开，如果程序出现异常 没能断开连接，将会导致数据库 内存泄漏，导致重启数据库。</span><br><span class="line"></span><br><span class="line">  - #### 传统的数据库连接，不能控制创建的数量，如果连接过多，就会存在 内存泄漏、Mysql 奔溃等。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### (3)  数据库连接池总类（主要是C3P0 、Druid）</span><br><span class="line"></span><br><span class="line">  ![](/Java复习/数据库连接池总类.png)</span><br><span class="line"></span><br><span class="line">- #### (4) 连接池操作方法</span><br><span class="line"></span><br><span class="line">  - #### c3p0</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">     //方式一:通过拿到连接池 来一一赋值参数进去</span><br><span class="line">        @Test</span><br><span class="line">        public void Test01() throws IOException, PropertyVetoException, SQLException &#123;</span><br><span class="line">    </span><br><span class="line">            //1. 引进 c3p0-0.9.1.2.jar</span><br><span class="line">            //2. 从jdbc.properties文件中获取连接数据库要用的数据</span><br><span class="line">            Properties properties = new Properties();</span><br><span class="line">            properties.load(new FileInputStream(&quot;src\\jdbc.properties&quot;));</span><br><span class="line">            String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">            String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">            String driver = properties.getProperty(&quot;driver&quot;);</span><br><span class="line">            String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">    </span><br><span class="line">            //3.创建实现DataSource接口的 comboPooledDataSource对象</span><br><span class="line">            ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();</span><br><span class="line">            //4.在连接池中 设置数据</span><br><span class="line">            comboPooledDataSource.setUser(user);</span><br><span class="line">            comboPooledDataSource.setPassword(password);</span><br><span class="line">            comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">            comboPooledDataSource.setDriverClass(driver);</span><br><span class="line">    </span><br><span class="line">            //5.设置初始化连接数 既默认就有几个连接</span><br><span class="line">            comboPooledDataSource.setInitialPoolSize(10);</span><br><span class="line">            //6.设置 最大连接数</span><br><span class="line">            comboPooledDataSource.setMaxPoolSize(50);</span><br><span class="line">            //7.获取连接</span><br><span class="line">            Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">            System.out.println(connection);</span><br><span class="line">    </span><br><span class="line">            //注意 这里的close方法 不是关掉与数据库的连接 而是 仅仅是吧 该连接放回去 连接池中</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        //方式二：使用c3p0-config.xml 来配置参数 就可以直接不用一个个设置了</span><br><span class="line">        @Test</span><br><span class="line">        public void Test02() throws SQLException &#123;</span><br><span class="line">            ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;c3p0_link&quot;);</span><br><span class="line">    </span><br><span class="line">            Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">    </span><br><span class="line">            System.out.println(connection);</span><br><span class="line">    </span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><h4 id="Durid操作"><a href="#Durid操作" class="headerlink" title="Durid操作"></a>Durid操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.引入druid-1.1.10.jar</span></span><br><span class="line">        <span class="comment">//2.配置 druid.properties，里面设置了 连接池的参数</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//3.通过DruidDataSourceFactory.createDataSource(properties) 来获取 druid连接池</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="三、DBUtils"><a href="#三、DBUtils" class="headerlink" title="三、DBUtils"></a>三、DBUtils</h3><ul><li><h4 id="1-含义：common-dbutils-是-Apache-组织一个开源的JDBC工具类库，对JDBC进行封装，可以极大的简化jdbc编码的工作量。"><a href="#1-含义：common-dbutils-是-Apache-组织一个开源的JDBC工具类库，对JDBC进行封装，可以极大的简化jdbc编码的工作量。" class="headerlink" title="(1) 含义：common-dbutils 是 Apache 组织一个开源的JDBC工具类库，对JDBC进行封装，可以极大的简化jdbc编码的工作量。"></a>(1) 含义：common-dbutils 是 Apache 组织一个开源的JDBC工具类库，对JDBC进行封装，可以极大的简化jdbc编码的工作量。</h4></li><li><h4 id="2-查询方法"><a href="#2-查询方法" class="headerlink" title="(2) 查询方法"></a>(2) 查询方法</h4><p><img src="/Java%E5%A4%8D%E4%B9%A0/DBUtils%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95.png"></p></li><li><h4 id="3-操作方法"><a href="#3-操作方法" class="headerlink" title="(3) 操作方法"></a>(3) 操作方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现查询功能</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DruidUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        String sql=<span class="string">&quot;select *from  actor where id&gt;?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//QueryRunner类 用于执行sql语句的类对象</span></span><br><span class="line">        QueryRunner queryRunner=<span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//BeanListHandler类 返回list对象集合的查询</span></span><br><span class="line">        List&lt;Actor&gt; list = queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(Actor actor:list)&#123;</span><br><span class="line">            System.out.println(actor);</span><br><span class="line">        &#125;</span><br><span class="line">        DruidUtils.close(<span class="literal">null</span>,<span class="literal">null</span>,connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现dml操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DruidUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        String sql=<span class="string">&quot;update actor set name=? where id=?&quot;</span>;</span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> queryRunner.update(connection, sql, <span class="string">&quot;zs&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(update&gt;<span class="number">0</span>?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、BasicDao（Dao-data-access-object）"><a href="#四、BasicDao（Dao-data-access-object）" class="headerlink" title="四、BasicDao（Dao: data access object）"></a>四、BasicDao（Dao: data access object）</h3><ul><li><h4 id="1-用处：正常的-apache-utils-Druid-虽然简化了JDBC的开发-但是-仍然存在不足。如SQL-语句是固定的-，？参数不能通过传参进行赋值。-而且，如果需要操作许多的表，就会变得非常的不灵活。"><a href="#1-用处：正常的-apache-utils-Druid-虽然简化了JDBC的开发-但是-仍然存在不足。如SQL-语句是固定的-，？参数不能通过传参进行赋值。-而且，如果需要操作许多的表，就会变得非常的不灵活。" class="headerlink" title="(1) 用处：正常的 apache-utils+Druid 虽然简化了JDBC的开发 但是 仍然存在不足。如SQL 语句是固定的 ，？参数不能通过传参进行赋值。 而且，如果需要操作许多的表，就会变得非常的不灵活。"></a>(1) 用处：正常的 apache-utils+Druid 虽然简化了JDBC的开发 但是 仍然存在不足。如SQL 语句是固定的 ，？参数不能通过传参进行赋值。 而且，如果需要操作许多的表，就会变得非常的不灵活。</h4></li><li><h4 id="2-含义：Dao类-专门用于与数据库进行交互的，既完成对数据库的CRUD操作。一张表-对应一个-DAO类。"><a href="#2-含义：Dao类-专门用于与数据库进行交互的，既完成对数据库的CRUD操作。一张表-对应一个-DAO类。" class="headerlink" title="(2) 含义：Dao类 专门用于与数据库进行交互的，既完成对数据库的CRUD操作。一张表 对应一个 DAO类。"></a>(2) 含义：Dao类 专门用于与数据库进行交互的，既完成对数据库的CRUD操作。一张表 对应一个 DAO类。</h4></li></ul><h3 id="五、正则表达式-regular-expression-Regexp"><a href="#五、正则表达式-regular-expression-Regexp" class="headerlink" title="五、正则表达式(regular expression &#x3D;&gt; Regexp)"></a>五、正则表达式(regular expression &#x3D;&gt; Regexp)</h3><ul><li><h4 id="1-含义：正则表达式-是对-字符串执行模式匹配的技术。"><a href="#1-含义：正则表达式-是对-字符串执行模式匹配的技术。" class="headerlink" title="(1) 含义：正则表达式 是对 字符串执行模式匹配的技术。"></a>(1) 含义：正则表达式 是对 字符串执行模式匹配的技术。</h4></li><li><h4 id="2-用处：用于对-一大串的文本-通过正则表达式来-匹配特定的字符。"><a href="#2-用处：用于对-一大串的文本-通过正则表达式来-匹配特定的字符。" class="headerlink" title="(2) 用处：用于对 一大串的文本 通过正则表达式来 匹配特定的字符。"></a>(2) 用处：用于对 一大串的文本 通过正则表达式来 匹配特定的字符。</h4></li><li><h4 id="3-基本用法："><a href="#3-基本用法：" class="headerlink" title="(3) 基本用法："></a>(3) 基本用法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String content=<span class="string">&quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了\&quot; +\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型\&quot; +\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的\&quot; +\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应\&quot; +\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个\&quot; +\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;里程碑，标志着Java的应用开始普及9889&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 规定正则表达式匹配规则 \\d 匹配任意一个数字</span></span><br><span class="line">        String rep=<span class="string">&quot;\\d\\d\\d\\d&quot;</span>;</span><br><span class="line">        <span class="comment">//2. 创建正则表达式 用Pattern.compile() 方法来 创建Parent对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(rep);</span><br><span class="line">        <span class="comment">//3. 通过compile.matcher() 来对文本进行匹配</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> compile.matcher(content);</span><br><span class="line">        <span class="comment">//4. 循环匹配文本 matcher.find()来匹配</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到：&quot;</span>+matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="4-matcher-find-与-matcher-group-方法的源码分析"><a href="#4-matcher-find-与-matcher-group-方法的源码分析" class="headerlink" title="(4) matcher.find() 与 matcher.group()方法的源码分析"></a>(4) matcher.find() 与 matcher.group()方法的源码分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       * (1): matcher.find()方法 底层操作分析  分组分析</span></span><br><span class="line"><span class="comment">       *   1. 根本指定的规则，来匹配到满足柜子的字符串(1998)</span></span><br><span class="line"><span class="comment">       *   2. matcher类 维护了int[] groups 数，用于记录 匹配到的字符串的 索引</span></span><br><span class="line"><span class="comment">       *       groups[0]: 用来匹配 字符串的第一个字符索引下标</span></span><br><span class="line"><span class="comment">       *       groups[1]: 用来匹配 字符串的最后一个字符的索引+1</span></span><br><span class="line"><span class="comment">       *               如果正则表达式存在分组()</span></span><br><span class="line"><span class="comment">       *       groups[2]: 用来记录 分组1 的字符串的第一个字符的下标</span></span><br><span class="line"><span class="comment">       *       groups[3]: 用来记录 分组1 的字符串的最后字符的下标+1</span></span><br><span class="line"><span class="comment">       *       groups[4]: 用来记录 分组2 的字符串的第一个字符的下标</span></span><br><span class="line"><span class="comment">        *      groups[5]: 用来记录 分组2 的字符串的最后字符的下标+1</span></span><br><span class="line"><span class="comment">        *      以此类推.....</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">       *       既 第一次匹配后，groups[0]=0 groups[1]=4</span></span><br><span class="line"><span class="comment">       *                     groups[2]=0 groups[3]=2</span></span><br><span class="line"><span class="comment">       *                     groups[3]=2 groups[4]=4</span></span><br><span class="line"><span class="comment">       *   3.每一次执行find方法 都会重新刷新groups 的值</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *   4. 同时会维护一个oldLast的值，用于记录 每一次的groups[1]的值，</span></span><br><span class="line"><span class="comment">       *       这样就可以在 下一次直接从 oldLast来 继续匹配文本字符串</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        * (2) 分析 matcher.group() 方法的源码</span></span><br><span class="line"><span class="comment">                *   public String group(int group) &#123;</span></span><br><span class="line"><span class="comment">                if (first &lt; 0)</span></span><br><span class="line"><span class="comment">                    throw new IllegalStateException(&quot;No match found&quot;);</span></span><br><span class="line"><span class="comment">                if (group &lt; 0 || group &gt; groupCount())</span></span><br><span class="line"><span class="comment">                    throw new IndexOutOfBoundsException(&quot;No group &quot; + group);</span></span><br><span class="line"><span class="comment">                if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span></span><br><span class="line"><span class="comment">                    return null;</span></span><br><span class="line"><span class="comment">                return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    *      1. 上面的源码 主要分析 返回语句</span></span><br><span class="line"><span class="comment">    *           getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">    *      2. 根据 字符串的getSubSequence方法，来对 文本进行截取，从而获取 匹配的字符串</span></span><br><span class="line"><span class="comment">    *      3. groups(0) : 用于获取 匹配到的字符串</span></span><br><span class="line"><span class="comment">    *         groups(1) : 获取 分组1 匹配到的字符</span></span><br><span class="line"><span class="comment">    *         groups(2) : 获取 分组2 匹配到的字符</span></span><br><span class="line"><span class="comment">    *         以此类推.......</span></span><br><span class="line"><span class="comment">        * */</span></span><br></pre></td></tr></table></figure></li><li><h4 id="5-正则表达式语法"><a href="#5-正则表达式语法" class="headerlink" title="(5) 正则表达式语法"></a>(5) 正则表达式语法</h4><ul><li><h4 id="1-元字符-转义号"><a href="#1-元字符-转义号" class="headerlink" title="1. 元字符-转义号 \\"></a>1. 元字符-转义号 \\</h4><ul><li><h5 id="用处：当我们需要匹配-一些特殊的字符的时候，会因为-正则表达式-的语法限制，而不能去匹配-某些特殊字符-如-等-这时就可以使用-转移号"><a href="#用处：当我们需要匹配-一些特殊的字符的时候，会因为-正则表达式-的语法限制，而不能去匹配-某些特殊字符-如-等-这时就可以使用-转移号" class="headerlink" title="用处：当我们需要匹配 一些特殊的字符的时候，会因为 正则表达式 的语法限制，而不能去匹配 某些特殊字符 如 . ? * $ 等 这时就可以使用 转移号"></a>用处：当我们需要匹配 一些特殊的字符的时候，会因为 正则表达式 的语法限制，而不能去匹配 某些特殊字符 如 . ? * $ 等 这时就可以使用 转移号</h5></li><li><h5 id="用法：-如需匹配-则-可以用-来实现-匹配-如要匹配-则在java中-用-来表示匹配"><a href="#用法：-如需匹配-则-可以用-来实现-匹配-如要匹配-则在java中-用-来表示匹配" class="headerlink" title="用法： 如需匹配 $ 则 可以用 \\$ 来实现 匹配$ , 如要匹配\ 则在java中 用 \\ 来表示匹配\"></a>用法： 如需匹配 $ 则 可以用 \\$ 来实现 匹配$ , 如要匹配\ 则在java中 用 \\ 来表示匹配\</h5></li></ul></li><li><h4 id="2-元字符-字符匹配符"><a href="#2-元字符-字符匹配符" class="headerlink" title="2.  元字符-字符匹配符"></a>2.  元字符-字符匹配符</h4><ul><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AC%A6.png"></p></li><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AC%A62.png"></p></li><li><h5 id="对于字母的-字符匹配中，默认是-区分大小写的，如何做到-不区分大小写呢？"><a href="#对于字母的-字符匹配中，默认是-区分大小写的，如何做到-不区分大小写呢？" class="headerlink" title="对于字母的 字符匹配中，默认是 区分大小写的，如何做到 不区分大小写呢？"></a>对于字母的 字符匹配中，默认是 区分大小写的，如何做到 不区分大小写呢？</h5><ul><li><h5 id="使用-i-语法：-i-abc-表示-abc都不区分大小写，a-i-bc-表示bc不区分大小写"><a href="#使用-i-语法：-i-abc-表示-abc都不区分大小写，a-i-bc-表示bc不区分大小写" class="headerlink" title="使用(?i) 语法：(?i)abc 表示 abc都不区分大小写，a(?i)bc 表示bc不区分大小写"></a>使用(?i) 语法：(?i)abc 表示 abc都不区分大小写，a(?i)bc 表示bc不区分大小写</h5></li><li><h5 id="设置-Pattern参数：Pattern-pat-Pattern-compile-regEx-Pattern-CASE-INSENSITIVE-通过设置-Pattern-CASE-INSENSITIVE-参数来-不区分大小写"><a href="#设置-Pattern参数：Pattern-pat-Pattern-compile-regEx-Pattern-CASE-INSENSITIVE-通过设置-Pattern-CASE-INSENSITIVE-参数来-不区分大小写" class="headerlink" title="设置 Pattern参数：Pattern pat=Pattern.compile(regEx,Pattern.CASE_INSENSITIVE); 通过设置 Pattern.CASE_INSENSITIVE 参数来 不区分大小写"></a>设置 Pattern参数：<code>Pattern pat=Pattern.compile(regEx,Pattern.CASE_INSENSITIVE);</code> 通过设置 Pattern.CASE_INSENSITIVE 参数来 不区分大小写</h5></li></ul></li></ul></li><li><h5 id="a-z-表示可以一个az-中的字符，-a-z-表示可以匹配-一个-不是az中的字符"><a href="#a-z-表示可以一个az-中的字符，-a-z-表示可以匹配-一个-不是az中的字符" class="headerlink" title="[a-z]: 表示可以一个az 中的字符，[ ^a-z]: 表示可以匹配 一个 不是az中的字符"></a>[a-z]: 表示可以一个a<del>z 中的字符，[ ^a-z]: 表示可以匹配 一个 不是a</del>z中的字符</h5></li><li><h5 id="s-匹配-空白符-即-空格-或者-制表符-S-匹配-非空白符"><a href="#s-匹配-空白符-即-空格-或者-制表符-S-匹配-非空白符" class="headerlink" title="\\s: 匹配 空白符(即 空格 或者 制表符) , \\S: 匹配 非空白符"></a>\\s: 匹配 空白符(即 空格 或者 制表符) , \\S: 匹配 非空白符</h5></li><li><h5 id="对于-匹配符-里面的特殊字符-就是-匹配特殊字符本身-既-匹配本身"><a href="#对于-匹配符-里面的特殊字符-就是-匹配特殊字符本身-既-匹配本身" class="headerlink" title="对于 匹配符[] , 里面的特殊字符 就是 匹配特殊字符本身 [.+&#x3D;?] 既 匹配本身"></a>对于 匹配符[] , 里面的特殊字符 就是 匹配特殊字符本身 [.+&#x3D;?] 既 匹配本身</h5></li></ul></li><li><h4 id="3-元字符-选择匹配符"><a href="#3-元字符-选择匹配符" class="headerlink" title="3.  元字符-选择匹配符"></a>3.  元字符-选择匹配符</h4><ul><li><h5 id="用处：当需要匹配某个字符串中，即可以匹配这个，也可以匹配那个-就可以使用-选择匹配符"><a href="#用处：当需要匹配某个字符串中，即可以匹配这个，也可以匹配那个-就可以使用-选择匹配符" class="headerlink" title="用处：当需要匹配某个字符串中，即可以匹配这个，也可以匹配那个 就可以使用 选择匹配符 |"></a>用处：当需要匹配某个字符串中，即可以匹配这个，也可以匹配那个 就可以使用 选择匹配符 |</h5></li><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E9%80%89%E6%8B%A9%E5%8C%B9%E9%85%8D%E7%AC%A6.png"></p></li></ul></li><li><h4 id="4-元字符-限定符"><a href="#4-元字符-限定符" class="headerlink" title="4. 元字符-限定符"></a>4. 元字符-限定符</h4><ul><li><h5 id="用处：当需要匹配某个字符组合-连续多次出现时，就可以使用-限定符"><a href="#用处：当需要匹配某个字符组合-连续多次出现时，就可以使用-限定符" class="headerlink" title="用处：当需要匹配某个字符组合 连续多次出现时，就可以使用 限定符"></a>用处：当需要匹配某个字符组合 连续多次出现时，就可以使用 限定符</h5></li><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E9%99%90%E5%AE%9A%E7%AC%A61.png"></p></li><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E9%99%90%E5%AE%9A%E7%AC%A62.png"></p></li><li><h5 id="细节：限定符的匹配-默认采用-贪婪匹配-即-尽可能得匹配多个-。"><a href="#细节：限定符的匹配-默认采用-贪婪匹配-即-尽可能得匹配多个-。" class="headerlink" title="细节：限定符的匹配 默认采用 贪婪匹配(即 尽可能得匹配多个)。"></a>细节：限定符的匹配 默认采用 贪婪匹配(即 尽可能得匹配多个)。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content=<span class="string">&quot;aaaa111&quot;</span>;</span><br><span class="line">String reg=<span class="string">&quot;a&#123;2,4&#125;&quot;</span>;</span><br><span class="line"><span class="comment">//这样子 就会尽可能的匹配4个 则匹配结果为 aaaa 而并非 aa、aa</span></span><br></pre></td></tr></table></figure></li><li><h5 id="若不想让限定符采用默认的贪婪匹配，则可以在限定符后加上？即可取消贪婪匹配，就会变成-尽可能少的匹配字符"><a href="#若不想让限定符采用默认的贪婪匹配，则可以在限定符后加上？即可取消贪婪匹配，就会变成-尽可能少的匹配字符" class="headerlink" title="若不想让限定符采用默认的贪婪匹配，则可以在限定符后加上？即可取消贪婪匹配，就会变成 尽可能少的匹配字符"></a>若不想让限定符采用默认的贪婪匹配，则可以在限定符后加上？即可取消贪婪匹配，就会变成 尽可能少的匹配字符</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content=<span class="string">&quot;aaaa111&quot;</span>;</span><br><span class="line">String reg=<span class="string">&quot;a&#123;2,4&#125;?&quot;</span>;</span><br><span class="line"><span class="comment">//这样子 就会尽可能少的匹配 则匹配结果为 aa、aa</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="5-元字符-定位符"><a href="#5-元字符-定位符" class="headerlink" title="5. 元字符-定位符"></a>5. 元字符-定位符</h4><ul><li><h5 id="用处：当需要规定-字符的出现位置时，如开始的字符-或是-结束的字符-，就可以使用定位符。"><a href="#用处：当需要规定-字符的出现位置时，如开始的字符-或是-结束的字符-，就可以使用定位符。" class="headerlink" title="用处：当需要规定 字符的出现位置时，如开始的字符 或是 结束的字符 ，就可以使用定位符。"></a>用处：当需要规定 字符的出现位置时，如开始的字符 或是 结束的字符 ，就可以使用定位符。</h5></li><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%AE%9A%E4%BD%8D%E7%AC%A6.png"></p></li></ul></li><li><h4 id="6-分组"><a href="#6-分组" class="headerlink" title="6. 分组"></a>6. 分组</h4><ul><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%88%86%E7%BB%841.png"></p></li><li><h5 id="以上是可捕获分组，即可以通过-matcher-group-方法-来获取-每组匹配到的字符串。"><a href="#以上是可捕获分组，即可以通过-matcher-group-方法-来获取-每组匹配到的字符串。" class="headerlink" title="以上是可捕获分组，即可以通过 matcher.group()方法 来获取 每组匹配到的字符串。"></a>以上是可捕获分组，即可以通过 matcher.group()方法 来获取 每组匹配到的字符串。</h5></li><li><h5 id="以下是非捕获分组，即-不能通过-macher-group-方法里获取分组匹配的字符串"><a href="#以下是非捕获分组，即-不能通过-macher-group-方法里获取分组匹配的字符串" class="headerlink" title="以下是非捕获分组，即 不能通过 macher.group() 方法里获取分组匹配的字符串"></a>以下是非捕获分组，即 不能通过 macher.group() 方法里获取分组匹配的字符串</h5></li><li><p><img src="/Java%E5%A4%8D%E4%B9%A0/%E5%88%86%E7%BB%842.png"></p></li><li><pre><code class="java">String content=&quot;jackp jacky jacko&quot;;String reg=&quot;jack?:p|o&quot;; //这样子 就会匹配到 jackp 与 jacko 而不会匹配到 jackyString content=&quot;jackp jacky jacko&quot;;String reg=&quot;jack?=p|y&quot;;//会匹配到 jackp 中的 jack 和 jacky中的 jackString content=&quot;jackp jacky jacko&quot;;String reg=&quot;jack?!p|y&quot;;//匹配到 jacko 中的jack 即和 ?=是相反的效果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### (6) 正则表达式的常用类</span><br><span class="line"></span><br><span class="line">  - #### Pattern类：是一个正则表达式对象，没有公共的构造方法，主要是使用 其静态方法。</span><br><span class="line"></span><br><span class="line">  - #### Matcher类：是对 输入字符串进行 解释与匹配的引擎。也是主要调用静态方法。</span><br><span class="line"></span><br><span class="line">    ![](/Java复习/matcher方法.png)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- #### (7) 反向引用</span><br><span class="line"></span><br><span class="line">  - ##### 含义：当圆括号中的内容 被捕获之后，如果我们想要 再次去使用该内容，则可以使用 反向引用 来表示括号中 的内容。\\\\1 内部引用 既在正则表达式中引用 $1 表示外部引用</span><br><span class="line"></span><br><span class="line">  - ##### 使用</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            String content=&quot;asvsad 1331 2442&quot;;</span><br><span class="line">            // \\1 表示引用第1组 既 1, \\2 引用第2组内容 既3  </span><br><span class="line">            String reg=&quot;(\\d)(\\d)\\2\\1&quot;;</span><br><span class="line">            Pattern pattern = Pattern.compile(reg);</span><br><span class="line">            Matcher matcher = pattern.matcher(content);</span><br><span class="line">            while (matcher.find())&#123;</span><br><span class="line">                System.out.println(matcher.group(0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    //演示结巴程序</span><br><span class="line">        @Test</span><br><span class="line">        public void testo1()&#123;</span><br><span class="line">            String content=&quot;我....我要....学学学学学....编程java&quot;;</span><br><span class="line">            //去除.....</span><br><span class="line">            String reg=&quot;\\.+&quot;;</span><br><span class="line">            Pattern compile = Pattern.compile(reg);</span><br><span class="line">            Matcher matcher = compile.matcher(content);</span><br><span class="line">            content = matcher.replaceAll(&quot;&quot;);</span><br><span class="line">    </span><br><span class="line">            //去除重复字符</span><br><span class="line">            content=Pattern.compile(&quot;(.)\\1+&quot;).matcher(content).replaceAll(&quot;$1&quot;);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><h4 id="8-String-类中-使用正则表达式"><a href="#8-String-类中-使用正则表达式" class="headerlink" title="(8) String 类中 使用正则表达式"></a>(8) String 类中 使用正则表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用正则表达式方式，将 JDK1.3 和 JDK1.4 替换成JDK</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tert01</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其&quot;</span> +</span><br><span class="line">               <span class="string">&quot;获得了Apple公司Mac OS X的工业标准的支持。2001年9月24日，J2EE1.3发&quot;</span> +</span><br><span class="line">               <span class="string">&quot;布。&quot;</span> +</span><br><span class="line">               <span class="string">&quot;2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升&quot;</span>;</span><br><span class="line">  </span><br><span class="line">       content = content.replaceAll(<span class="string">&quot;JDK1\\.3|JDK1\\.4&quot;</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">       System.out.println(content);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//要求 验证一个 手机号， 要求必须是以138 139 开头的</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tert02</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;13812345675&quot;</span>;</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">if</span>(content.matches(<span class="string">&quot;1(38|39)\\d&#123;8&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//要求按照 # 或者 - 或者 ~ 或者 数字 来分割</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tert03</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello#abc-jack12smith~北京&quot;</span>;</span><br><span class="line">  </span><br><span class="line">       String[] split = content.split(<span class="string">&quot;#|-|~|\\d+&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span>(String s:split)&#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、JDBC&quot;&gt;&lt;a href=&quot;#一、JDBC&quot; class=&quot;headerlink&quot; title=&quot;一、JDBC&quot;&gt;&lt;/a&gt;一、JDBC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1-介绍：JDBC为-访问不同的数据库接口-提供了同一的接口，为使用者-屏蔽了细</summary>
      
    
    
    
    
    <category term="-Java -复习" scheme="http://example.com/tags/Java-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql复习</title>
    <link href="http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/mysql%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2021/09/21/Java%E5%A4%8D%E4%B9%A0/mysql%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、mysql-基本启动命令"><a href="#一、mysql-基本启动命令" class="headerlink" title="一、mysql 基本启动命令"></a>一、mysql 基本启动命令</h3><ul><li><h4 id="1-mysql-服务启动命令：net-start-mysql-开启mysql服务、net-stop-mysql-停止mysql服务"><a href="#1-mysql-服务启动命令：net-start-mysql-开启mysql服务、net-stop-mysql-停止mysql服务" class="headerlink" title="1. mysql 服务启动命令：net start mysql 开启mysql服务、net stop mysql 停止mysql服务"></a>1. mysql 服务启动命令：net start mysql 开启mysql服务、net stop mysql 停止mysql服务</h4></li><li><h4 id="2-连接mysql-命令：mysql-h-主机名-ip号-默认为127-0-0-1-既本机-P-端口号-默认-3306-u-用户名-p密码"><a href="#2-连接mysql-命令：mysql-h-主机名-ip号-默认为127-0-0-1-既本机-P-端口号-默认-3306-u-用户名-p密码" class="headerlink" title="2. 连接mysql 命令：mysql -h 主机名(ip号 默认为127.0.0.1 既本机) -P 端口号(默认 3306) -u 用户名 -p密码"></a>2. 连接mysql 命令：mysql -h 主机名(ip号 默认为127.0.0.1 既本机) -P 端口号(默认 3306) -u 用户名 -p密码</h4></li><li><h4 id="3-查看-mysql版本（需要进入-mysql-安装目录下的-bin-目录-才能使用-mysql命令）：-mysql-–version"><a href="#3-查看-mysql版本（需要进入-mysql-安装目录下的-bin-目录-才能使用-mysql命令）：-mysql-–version" class="headerlink" title="3. 查看 mysql版本（需要进入 mysql 安装目录下的 bin 目录 才能使用 mysql命令）： mysql –version"></a>3. 查看 mysql版本（需要进入 mysql 安装目录下的 bin 目录 才能使用 mysql命令）： mysql –version</h4></li></ul><h3 id="二、mysql-三层结构解析"><a href="#二、mysql-三层结构解析" class="headerlink" title="二、mysql 三层结构解析"></a>二、mysql 三层结构解析</h3><p><img src="/mysql%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><ul><li><h4 id="1-说明：当-开启mysql-服务时，mysql-通过tcp网络的-mysql端口-默认-3306-进行监听。-当客户端-输入mysql命令后，3306端口就会接受到-请求，分析命令，处理操作，最后-返回结果给-客户端。"><a href="#1-说明：当-开启mysql-服务时，mysql-通过tcp网络的-mysql端口-默认-3306-进行监听。-当客户端-输入mysql命令后，3306端口就会接受到-请求，分析命令，处理操作，最后-返回结果给-客户端。" class="headerlink" title="1. 说明：当 开启mysql 服务时，mysql 通过tcp网络的 mysql端口( 默认 3306)  进行监听。 当客户端 输入mysql命令后，3306端口就会接受到 请求，分析命令，处理操作，最后 返回结果给 客户端。"></a>1. 说明：当 开启mysql 服务时，mysql 通过tcp网络的 mysql端口( 默认 3306)  进行监听。 当客户端 输入mysql命令后，3306端口就会接受到 请求，分析命令，处理操作，最后 返回结果给 客户端。</h4></li><li><h4 id="2-SQL-语句分类"><a href="#2-SQL-语句分类" class="headerlink" title="2. SQL 语句分类"></a>2. SQL 语句分类</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/sql%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB.png"></h4></li></ul><h3 id="三、操作数据库的命令"><a href="#三、操作数据库的命令" class="headerlink" title="三、操作数据库的命令"></a>三、操作数据库的命令</h3><ul><li><h4 id="1-创建数据库："><a href="#1-创建数据库：" class="headerlink" title="1. 创建数据库："></a>1. 创建数据库：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># if <span class="keyword">not</span> exist: 表示没有数据库名为exam_01的情况下</span><br><span class="line"># <span class="type">character</span> <span class="keyword">set</span>： 设置 数据库编码</span><br><span class="line"># <span class="keyword">collate</span>：设置 校对规则</span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> exam_01 <span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_bin;</span><br></pre></td></tr></table></figure><ul><li><h4 id="character-set-指定数据库采用的-字符集。-默认时-utf8"><a href="#character-set-指定数据库采用的-字符集。-默认时-utf8" class="headerlink" title="character set : 指定数据库采用的 字符集。 默认时 utf8"></a>character set : 指定数据库采用的 字符集。 默认时 utf8</h4></li><li><h4 id="collate：指定-数据库字符集-的-校对规则。（常用-utf8-bin-区分大小写-、utf8-general-ci-不区分大小写-）"><a href="#collate：指定-数据库字符集-的-校对规则。（常用-utf8-bin-区分大小写-、utf8-general-ci-不区分大小写-）" class="headerlink" title="collate：指定 数据库字符集 的 校对规则。（常用 utf8_bin(区分大小写) 、utf8_general_ci(不区分大小写)）"></a>collate：指定 数据库字符集 的 校对规则。（常用 utf8_bin(区分大小写) 、utf8_general_ci(不区分大小写)）</h4></li></ul></li><li><h4 id="2-查看、删除数据库"><a href="#2-查看、删除数据库" class="headerlink" title="2. 查看、删除数据库"></a>2. 查看、删除数据库</h4><ul><li><h4 id="查看数据库：show-database"><a href="#查看数据库：show-database" class="headerlink" title="查看数据库：show database"></a>查看数据库：show database</h4></li><li><h4 id="显示数据库创建语句：show-create-databse-数据库名"><a href="#显示数据库创建语句：show-create-databse-数据库名" class="headerlink" title="显示数据库创建语句：show create databse 数据库名"></a>显示数据库创建语句：show create databse 数据库名</h4></li><li><h4 id="删除数据库：drop-database-数据库名"><a href="#删除数据库：drop-database-数据库名" class="headerlink" title="删除数据库：drop database 数据库名"></a>删除数据库：drop database 数据库名</h4></li><li><h4 id="小知识点：用-起来数据库名，用于避免与关键字矛盾。-如数据库名为create-则可以用-起来"><a href="#小知识点：用-起来数据库名，用于避免与关键字矛盾。-如数据库名为create-则可以用-起来" class="headerlink" title="小知识点：用 \`&#96;\ 起来数据库名，用于避免与关键字矛盾。 如数据库名为create 则可以用 \`&#96;\ 起来"></a>小知识点：用 \`&#96;\ 起来数据库名，用于避免与关键字矛盾。 如数据库名为create 则可以用 \`&#96;\ 起来</h4></li></ul></li><li><h4 id="3-备份恢复数据库"><a href="#3-备份恢复数据库" class="headerlink" title="3. 备份恢复数据库"></a>3. 备份恢复数据库</h4><ul><li><h4 id="备份数据库（需要在-DOS-执行-既-命令提示符）：mysqldump-u-用户名-p-B-db1、db2-文件名-sql"><a href="#备份数据库（需要在-DOS-执行-既-命令提示符）：mysqldump-u-用户名-p-B-db1、db2-文件名-sql" class="headerlink" title="备份数据库（需要在 DOS 执行 既 命令提示符）：mysqldump -u 用户名 -p -B db1、db2  &gt; 文件名.sql"></a>备份数据库（需要在 DOS 执行 既 命令提示符）：mysqldump -u 用户名 -p -B db1、db2  &gt; 文件名.sql</h4></li><li><h4 id="备份-部分数据库表：mysqldump-u-用户名-p-数据库名-表1-表2-文件名-sql"><a href="#备份-部分数据库表：mysqldump-u-用户名-p-数据库名-表1-表2-文件名-sql" class="headerlink" title="备份 部分数据库表：mysqldump -u 用户名 -p 数据库名 表1 表2 &gt; 文件名.sql"></a>备份 部分数据库表：mysqldump -u 用户名 -p 数据库名 表1 表2 &gt; 文件名.sql</h4></li><li><h4 id="恢复数据库（需要在-mysql中运行）：source-文件名-d-xx-sql-sql"><a href="#恢复数据库（需要在-mysql中运行）：source-文件名-d-xx-sql-sql" class="headerlink" title="恢复数据库（需要在 mysql中运行）：source 文件名(d:\\ xx.sql).sql"></a>恢复数据库（需要在 mysql中运行）：source 文件名(d:\\ xx.sql).sql</h4></li></ul></li></ul><h3 id="四、创建表"><a href="#四、创建表" class="headerlink" title="四、创建表"></a>四、创建表</h3><ul><li><h4 id="1-命令：create-table-表名（field1-dataType-field2-dataTytpe-field3-dataType）character-set-字符集-collate-校对规则-engine-存储引擎-。"><a href="#1-命令：create-table-表名（field1-dataType-field2-dataTytpe-field3-dataType）character-set-字符集-collate-校对规则-engine-存储引擎-。" class="headerlink" title="1. 命令：create table 表名（field1 dataType, field2 dataTytpe,field3 dataType）character set 字符集 collate 校对规则 engine 存储引擎 。"></a>1. 命令：create table 表名（field1 dataType, field2 dataTytpe,field3 dataType）character set 字符集 collate 校对规则 engine 存储引擎 。</h4></li><li><h4 id="2-快速创建表：当创建的表与-另一个表的结构相似时，可以使用-like来进行创建"><a href="#2-快速创建表：当创建的表与-另一个表的结构相似时，可以使用-like来进行创建" class="headerlink" title="2. 快速创建表：当创建的表与 另一个表的结构相似时，可以使用 like来进行创建"></a>2. 快速创建表：当创建的表与 另一个表的结构相似时，可以使用 like来进行创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_01 <span class="keyword">like</span> emp;</span><br></pre></td></tr></table></figure></li></ul><h3 id="五、mysql常用的数据类型"><a href="#五、mysql常用的数据类型" class="headerlink" title="五、mysql常用的数据类型"></a>五、mysql常用的数据类型</h3><p> <img src="/mysql%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><ul><li><h4 id="1-数值型（整数）的使用"><a href="#1-数值型（整数）的使用" class="headerlink" title="1. 数值型（整数）的使用"></a>1. 数值型（整数）的使用</h4><ul><li><h4 id="数据类型包含：bit、tinyint、smallint、int、bigint"><a href="#数据类型包含：bit、tinyint、smallint、int、bigint" class="headerlink" title="数据类型包含：bit、tinyint、smallint、int、bigint"></a>数据类型包含：bit、tinyint、smallint、int、bigint</h4></li><li><h4 id="使用规范：在能够满足需求的情况下，尽量选择占用空间小的类型"><a href="#使用规范：在能够满足需求的情况下，尽量选择占用空间小的类型" class="headerlink" title="使用规范：在能够满足需求的情况下，尽量选择占用空间小的类型"></a>使用规范：在能够满足需求的情况下，尽量选择占用空间小的类型</h4></li><li><h4 id="数值型-有符号-与-无符号区别。默认是-有符号，-如果需指定无符号-可以使用-unsigned-来指定。"><a href="#数值型-有符号-与-无符号区别。默认是-有符号，-如果需指定无符号-可以使用-unsigned-来指定。" class="headerlink" title="数值型 有符号 与 无符号区别。默认是 有符号， 如果需指定无符号 可以使用 unsigned 来指定。"></a>数值型 有符号 与 无符号区别。默认是 有符号， 如果需指定无符号 可以使用 unsigned 来指定。</h4></li><li><h4 id="数值型-bit（位）类型的使用："><a href="#数值型-bit（位）类型的使用：" class="headerlink" title="数值型 bit（位）类型的使用："></a>数值型 bit（位）类型的使用：</h4><ul><li><h4 id="bit-字段-是按照-位的方式显示的。-如-bit-5-的大小-等于-二进制的-11111-31"><a href="#bit-字段-是按照-位的方式显示的。-如-bit-5-的大小-等于-二进制的-11111-31" class="headerlink" title="bit 字段 是按照 位的方式显示的。(如 bit(5)  的大小 等于 二进制的 11111 &#x3D; 31)"></a>bit 字段 是按照 位的方式显示的。(如 bit(5)  的大小 等于 二进制的 11111 &#x3D; 31)</h4></li><li><h4 id="如果-一个值-只有-0，1-，可以考虑使用-bit-1-，可以节省空间"><a href="#如果-一个值-只有-0，1-，可以考虑使用-bit-1-，可以节省空间" class="headerlink" title="如果 一个值 只有 0，1 ，可以考虑使用 bit(1) ，可以节省空间"></a>如果 一个值 只有 0，1 ，可以考虑使用 bit(1) ，可以节省空间</h4></li><li><h4 id="bit-M-M-指定位数-范围-1-64"><a href="#bit-M-M-指定位数-范围-1-64" class="headerlink" title="bit(M) M 指定位数 范围 1~64"></a>bit(M) M 指定位数 范围 1~64</h4></li></ul></li></ul></li><li><h4 id="2-数值型（小数）的使用"><a href="#2-数值型（小数）的使用" class="headerlink" title="2. 数值型（小数）的使用"></a>2. 数值型（小数）的使用</h4><ul><li><h4 id="数据类型包含：float、double、decimal-M-D"><a href="#数据类型包含：float、double、decimal-M-D" class="headerlink" title="数据类型包含：float、double、decimal[M,D]"></a>数据类型包含：float、double、decimal[M,D]</h4></li><li><h4 id="详解-decimal-M-D-："><a href="#详解-decimal-M-D-：" class="headerlink" title="详解 decimal[M,D]："></a>详解 decimal[M,D]：</h4><ul><li><h4 id="可以支持-更加精确的小数位。M是小数位数的总数-既-小数点前的位数-，D是小数点后面的位数。"><a href="#可以支持-更加精确的小数位。M是小数位数的总数-既-小数点前的位数-，D是小数点后面的位数。" class="headerlink" title="可以支持 更加精确的小数位。M是小数位数的总数( 既 小数点前的位数 )，D是小数点后面的位数。"></a>可以支持 更加精确的小数位。M是小数位数的总数( 既 小数点前的位数 )，D是小数点后面的位数。</h4></li><li><h4 id="如果D是0，则值-就没有小数位，就变成了整数。"><a href="#如果D是0，则值-就没有小数位，就变成了整数。" class="headerlink" title="如果D是0，则值 就没有小数位，就变成了整数。"></a>如果D是0，则值 就没有小数位，就变成了整数。</h4></li><li><h4 id="M-最大65，D最大-30。-如果-M被省略-则默认为-10，D被省略-则默认为-0。"><a href="#M-最大65，D最大-30。-如果-M被省略-则默认为-10，D被省略-则默认为-0。" class="headerlink" title="M 最大65，D最大 30。 如果 M被省略 则默认为 10，D被省略 则默认为 0。"></a>M 最大65，D最大 30。 如果 M被省略 则默认为 10，D被省略 则默认为 0。</h4></li></ul></li></ul></li><li><h4 id="3-字符串类型的使用"><a href="#3-字符串类型的使用" class="headerlink" title="3. 字符串类型的使用"></a>3. 字符串类型的使用</h4><ul><li><h4 id="数据类型包含：char（固定长度字符串-最大-255字符）、varchar（可变长度字符串-最大-65532-字节）"><a href="#数据类型包含：char（固定长度字符串-最大-255字符）、varchar（可变长度字符串-最大-65532-字节）" class="headerlink" title="数据类型包含：char（固定长度字符串 最大 255字符）、varchar（可变长度字符串 最大 65532 字节）"></a>数据类型包含：char（固定长度字符串 最大 255字符）、varchar（可变长度字符串 最大 65532 字节）</h4></li><li><h4 id="使用细节："><a href="#使用细节：" class="headerlink" title="使用细节："></a>使用细节：</h4><ul><li><h4 id="char（4）-表示的是字符数-既-位数-，不是字节数-不管中文、字母-都是可以放4个。并且-这是固定长度，即便插入的‘aa’-但还是会占用-4字符的-内存空间。因此可用于-固定长度格式的-类型（如-电话号码、邮箱、身份证号码-等）。"><a href="#char（4）-表示的是字符数-既-位数-，不是字节数-不管中文、字母-都是可以放4个。并且-这是固定长度，即便插入的‘aa’-但还是会占用-4字符的-内存空间。因此可用于-固定长度格式的-类型（如-电话号码、邮箱、身份证号码-等）。" class="headerlink" title="char（4） 表示的是字符数(既 位数 )，不是字节数,不管中文、字母 都是可以放4个。并且 这是固定长度，即便插入的‘aa’ 但还是会占用 4字符的 内存空间。因此可用于 固定长度格式的 类型（如 电话号码、邮箱、身份证号码 等）。"></a>char（4） 表示的是字符数(既 位数 )，不是字节数,不管中文、字母 都是可以放4个。并且 这是固定长度，即便插入的‘aa’ 但还是会占用 4字符的 内存空间。因此可用于 固定长度格式的 类型（如 电话号码、邮箱、身份证号码 等）。</h4></li><li><h4 id="varchar-4-也表示字符数，根据表的编码-来-存放数据。按照-实际占用空间来分配。可用于-不确定长度的类型。"><a href="#varchar-4-也表示字符数，根据表的编码-来-存放数据。按照-实际占用空间来分配。可用于-不确定长度的类型。" class="headerlink" title="varchar(4) 也表示字符数，根据表的编码 来 存放数据。按照 实际占用空间来分配。可用于 不确定长度的类型。"></a>varchar(4) 也表示字符数，根据表的编码 来 存放数据。按照 实际占用空间来分配。可用于 不确定长度的类型。</h4></li><li><h4 id="查询速度-：-char-varchar"><a href="#查询速度-：-char-varchar" class="headerlink" title="查询速度 ： char &gt; varchar"></a>查询速度 ： char &gt; varchar</h4></li><li><h4 id="若是存放-文本，可以使用-text类型。"><a href="#若是存放-文本，可以使用-text类型。" class="headerlink" title="若是存放 文本，可以使用 text类型。"></a>若是存放 文本，可以使用 text类型。</h4></li></ul></li></ul></li><li><h4 id="4-日期类型的使用"><a href="#4-日期类型的使用" class="headerlink" title="4. 日期类型的使用"></a>4. 日期类型的使用</h4><ul><li><h4 id="数据类型包含：date-年-月-日-、datetime-年-月-日-时-分-秒-、timestamp-时间戳"><a href="#数据类型包含：date-年-月-日-、datetime-年-月-日-时-分-秒-、timestamp-时间戳" class="headerlink" title="数据类型包含：date(年 月 日)、datetime(年 月 日 时 分 秒)、timestamp(时间戳)"></a>数据类型包含：date(年 月 日)、datetime(年 月 日 时 分 秒)、timestamp(时间戳)</h4></li><li><h4 id="timetamp-详解："><a href="#timetamp-详解：" class="headerlink" title="timetamp 详解："></a>timetamp 详解：</h4><ul><li><h4 id="时间戳：-当-表-修改或者添加时，可以自动的更新-当前时间。"><a href="#时间戳：-当-表-修改或者添加时，可以自动的更新-当前时间。" class="headerlink" title="时间戳： 当 表 修改或者添加时，可以自动的更新 当前时间。"></a>时间戳： 当 表 修改或者添加时，可以自动的更新 当前时间。</h4></li><li><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_3(</span><br><span class="line">t1 <span class="type">date</span>,</span><br><span class="line">    t2 datetime,</span><br><span class="line">    # 定义 <span class="type">time</span>  在 表 更新时 修改时间</span><br><span class="line">`<span class="type">time</span>` <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="built_in">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">current_timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="六、修改表"><a href="#六、修改表" class="headerlink" title="六、修改表"></a>六、修改表</h3><ul><li><h4 id="1-添加列：alter-table-表名-add-列表-列类型-after-列名-用作-新建列-放在-哪个列的后面"><a href="#1-添加列：alter-table-表名-add-列表-列类型-after-列名-用作-新建列-放在-哪个列的后面" class="headerlink" title="1. 添加列：alter table 表名 add 列表 列类型 (after 列名 用作 新建列 放在 哪个列的后面)"></a>1. 添加列：alter table 表名 add 列表 列类型 (after 列名 用作 新建列 放在 哪个列的后面)</h4></li><li><h4 id="2-修改列：alter-table-表名-modify-列名-列属性"><a href="#2-修改列：alter-table-表名-modify-列名-列属性" class="headerlink" title="2. 修改列：alter table 表名 modify 列名 列属性"></a>2. 修改列：alter table 表名 modify 列名 列属性</h4></li><li><h4 id="3-删除列：alter-table-表名-drop-列名"><a href="#3-删除列：alter-table-表名-drop-列名" class="headerlink" title="3. 删除列：alter table 表名 drop 列名"></a>3. 删除列：alter table 表名 drop 列名</h4></li><li><h4 id="4-修改表名：rename-table-表名-to-新表名"><a href="#4-修改表名：rename-table-表名-to-新表名" class="headerlink" title="4. 修改表名：rename table 表名 to 新表名"></a>4. 修改表名：rename table 表名 to 新表名</h4></li><li><h4 id="5-修改表字符集：alter-table-表名-character-set-字符集"><a href="#5-修改表字符集：alter-table-表名-character-set-字符集" class="headerlink" title="5. 修改表字符集：alter table 表名 character set 字符集"></a>5. 修改表字符集：alter table 表名 character set 字符集</h4></li><li><h4 id="6-查看表结构：desc-表名"><a href="#6-查看表结构：desc-表名" class="headerlink" title="6. 查看表结构：desc 表名"></a>6. 查看表结构：desc 表名</h4></li><li><p><strong>7. 修改列名：alter table 表名 change  列名 新列名 数据类型</strong></p></li><li><p><strong>8. 添加外键约束：alter table 从表(即你要添加外键字段的表) add constraint 外键名 foreign key 从表的(外键字段) references 主表(主键字段);</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table after_sales add constraint `afterAndOrder` foreign key (order_id) references `order`(order_id);</span><br></pre></td></tr></table></figure></li><li><p><strong>9. 查看表创建语句（也可以查看外键约束）：SHOW CREATE TABLE &lt;数据表名&gt;;</strong></p></li><li><p><strong>10. 修改外键约束：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table saler drop foreign key 外键名</span><br></pre></td></tr></table></figure></li><li></li></ul><h3 id="七、CRUD-操作表"><a href="#七、CRUD-操作表" class="headerlink" title="七、CRUD 操作表"></a>七、CRUD 操作表</h3><ul><li><h4 id="1-insert语句："><a href="#1-insert语句：" class="headerlink" title="1. insert语句："></a>1. insert语句：</h4><ul><li><h4 id="使用：insert-into-表名-需要添加数据的列-默认是全列添加-values-输入列的值"><a href="#使用：insert-into-表名-需要添加数据的列-默认是全列添加-values-输入列的值" class="headerlink" title="使用：insert into 表名(需要添加数据的列 默认是全列添加) values(输入列的值)"></a>使用：insert into 表名(需要添加数据的列 默认是全列添加) values(输入列的值)</h4></li><li><h4 id="细节：insert-into-表名-列名-values-可以同时添加多条数据"><a href="#细节：insert-into-表名-列名-values-可以同时添加多条数据" class="headerlink" title="细节：insert into 表名(列名) values (),(),() 可以同时添加多条数据"></a>细节：insert into 表名(列名) values (),(),() 可以同时添加多条数据</h4></li></ul></li><li><h4 id="2-update语句"><a href="#2-update语句" class="headerlink" title="2. update语句"></a>2. update语句</h4><ul><li><h4 id="使用：update-student-set-name-’jack’-age-15-where-id-1"><a href="#使用：update-student-set-name-’jack’-age-15-where-id-1" class="headerlink" title="使用：update student set name&#x3D;’jack’,age&#x3D;15 where id&#x3D;1"></a>使用：update student set name&#x3D;’jack’,age&#x3D;15 where id&#x3D;1</h4></li></ul></li><li><h4 id="3-delete语句"><a href="#3-delete语句" class="headerlink" title="3. delete语句"></a>3. delete语句</h4><ul><li><h4 id="使用：delete-from-student-where-id-1-删除-id-1-的-student表数据-没有where条件-则删除student表全部数据"><a href="#使用：delete-from-student-where-id-1-删除-id-1-的-student表数据-没有where条件-则删除student表全部数据" class="headerlink" title="使用：delete from student where id&#x3D;1;(删除 id&#x3D;1 的 student表数据 没有where条件 则删除student表全部数据)"></a>使用：delete from student where id&#x3D;1;(删除 id&#x3D;1 的 student表数据 没有where条件 则删除student表全部数据)</h4></li><li><h4 id="当碰到You-are-using-safe-update-mode-and-you-tried-to-update-a-table-without-a-WHERE-that-uses-a-KEY-column-错误时，可通过-set-sql-safe-updates-0-来修改安全权限"><a href="#当碰到You-are-using-safe-update-mode-and-you-tried-to-update-a-table-without-a-WHERE-that-uses-a-KEY-column-错误时，可通过-set-sql-safe-updates-0-来修改安全权限" class="headerlink" title="当碰到You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.  错误时，可通过 set sql_safe_updates&#x3D;0; 来修改安全权限"></a>当碰到You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.  错误时，可通过 set sql_safe_updates&#x3D;0; 来修改安全权限</h4></li></ul></li><li><h4 id="4-select-语句"><a href="#4-select-语句" class="headerlink" title="4. select 语句"></a>4. select 语句</h4><ul><li><h4 id="1-使用："><a href="#1-使用：" class="headerlink" title="(1). 使用："></a>(1). 使用：</h4><ul><li><h4 id="select-distinct-from-student-（查询student表-不重复的全部数据-distinct表示为-不重复的）"><a href="#select-distinct-from-student-（查询student表-不重复的全部数据-distinct表示为-不重复的）" class="headerlink" title="select distinct * from student; （查询student表 不重复的全部数据 distinct表示为 不重复的）"></a>select distinct * from student; （查询student表 不重复的全部数据 distinct表示为 不重复的）</h4></li><li><h4 id="select-age-name-from-student-where-id-1-（仅查询-student表中id为1的-age-name-字段的属性）"><a href="#select-age-name-from-student-where-id-1-（仅查询-student表中id为1的-age-name-字段的属性）" class="headerlink" title="select age,name from student where id&#x3D;1; （仅查询 student表中id为1的 age,name 字段的属性）"></a>select age,name from student where id&#x3D;1; （仅查询 student表中id为1的 age,name 字段的属性）</h4></li></ul></li><li><h4 id="2-使用技巧："><a href="#2-使用技巧：" class="headerlink" title="(2). 使用技巧："></a>(2). 使用技巧：</h4><ul><li><h4 id="使用-表达式-对查询的列-进行运算-并且-可以通过-as-关键字-对字段进行-命名"><a href="#使用-表达式-对查询的列-进行运算-并且-可以通过-as-关键字-对字段进行-命名" class="headerlink" title="使用 表达式 对查询的列 进行运算, 并且 可以通过 as 关键字 对字段进行 命名"></a>使用 表达式 对查询的列 进行运算, 并且 可以通过 as 关键字 对字段进行 命名</h4><h4 id="例：select-english-math-as-score-from-student-where-id-1"><a href="#例：select-english-math-as-score-from-student-where-id-1" class="headerlink" title="例：select (english+math) as score from student where id&#x3D;1;"></a>例：select (english+math) as score from student where id&#x3D;1;</h4></li><li><h4 id="经常使用的运算符"><a href="#经常使用的运算符" class="headerlink" title="经常使用的运算符"></a>经常使用的运算符</h4><p>![](&#x2F;select 语句经常使用的 运算符.png)</p></li><li><h4 id="order-by-语句-对查询结果进行排序"><a href="#order-by-语句-对查询结果进行排序" class="headerlink" title="order by 语句 对查询结果进行排序"></a>order by 语句 对查询结果进行排序</h4><h4 id="select-from-student-order-by-math-asc-默认-升序-desc-降序"><a href="#select-from-student-order-by-math-asc-默认-升序-desc-降序" class="headerlink" title="select * from student order by math asc(默认 升序) &#x2F; desc(降序)"></a>select * from student order by math asc(默认 升序) &#x2F; desc(降序)</h4></li><li><h4 id="like-语句查询-表示任意字符"><a href="#like-语句查询-表示任意字符" class="headerlink" title="like 语句查询(_:表示任意字符)"></a>like 语句查询(_:表示任意字符)</h4><h4 id="select-from-emp-where-user-name-like-‘-梁-’-查询-名字-第三个字符是-梁的-员工表"><a href="#select-from-emp-where-user-name-like-‘-梁-’-查询-名字-第三个字符是-梁的-员工表" class="headerlink" title="select *from emp where user_name like ‘__梁%’; &#x2F;&#x2F;查询 名字 第三个字符是 梁的 员工表"></a>select *from emp where user_name like ‘__梁%’; &#x2F;&#x2F;查询 名字 第三个字符是 梁的 员工表</h4></li><li><h4 id="limit-语句查询"><a href="#limit-语句查询" class="headerlink" title="limit 语句查询"></a>limit 语句查询</h4><h4 id="select-from-student-where-id-limit-5-offset-5-拿到前五个id-从5个开始拿"><a href="#select-from-student-where-id-limit-5-offset-5-拿到前五个id-从5个开始拿" class="headerlink" title="select *from student where id limit 5 offset 5; &#x2F;&#x2F;拿到前五个id 从5个开始拿"></a>select *from student where id limit 5 offset 5; &#x2F;&#x2F;拿到前五个id 从5个开始拿</h4></li></ul></li></ul></li></ul><h3 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h3><ul><li><h4 id="1-统计函数"><a href="#1-统计函数" class="headerlink" title="(1). 统计函数"></a>(1). 统计函数</h4><ul><li><h4 id="1-count（统计、合计）函数：select-count-from-student-where-math-80-查询数学成绩高于80的-学生总数"><a href="#1-count（统计、合计）函数：select-count-from-student-where-math-80-查询数学成绩高于80的-学生总数" class="headerlink" title="1. count（统计、合计）函数：select count(*) from student where math&gt;80  &#x2F;&#x2F; 查询数学成绩高于80的 学生总数"></a>1. count（统计、合计）函数：select count(*) from student where math&gt;80  &#x2F;&#x2F; 查询数学成绩高于80的 学生总数</h4></li><li><h4 id="2-sum-合计-主要用于-数值类型-的统计-函数：-select-sum-math-from-student-查询所有学生的-数学总分"><a href="#2-sum-合计-主要用于-数值类型-的统计-函数：-select-sum-math-from-student-查询所有学生的-数学总分" class="headerlink" title="2. sum(合计 主要用于 数值类型 的统计)函数： select sum(math) from student; &#x2F;&#x2F;查询所有学生的 数学总分"></a>2. sum(合计 主要用于 数值类型 的统计)函数： select sum(math) from student; &#x2F;&#x2F;查询所有学生的 数学总分</h4></li><li><h4 id="3-avg-统计-平均分-用于数值类型-函数：-select-avg-math-from-student-查询-所有学生数学成绩的-平均分"><a href="#3-avg-统计-平均分-用于数值类型-函数：-select-avg-math-from-student-查询-所有学生数学成绩的-平均分" class="headerlink" title="3. avg(统计 平均分 用于数值类型)函数： select avg(math) from student;  &#x2F;&#x2F;查询 所有学生数学成绩的 平均分"></a>3. avg(统计 平均分 用于数值类型)函数： select avg(math) from student;  &#x2F;&#x2F;查询 所有学生数学成绩的 平均分</h4></li><li><h4 id="4-max-得到-最大值，数值类型-函数、min-得到最小值-函数：select-max-math-min-math-from-student-查询学生表的-最大数学成绩-与-最小数学成绩。"><a href="#4-max-得到-最大值，数值类型-函数、min-得到最小值-函数：select-max-math-min-math-from-student-查询学生表的-最大数学成绩-与-最小数学成绩。" class="headerlink" title="4. max(得到 最大值，数值类型) 函数、min(得到最小值)函数：select max(math),min(math) from student; &#x2F;&#x2F;查询学生表的 最大数学成绩 与 最小数学成绩。"></a>4. max(得到 最大值，数值类型) 函数、min(得到最小值)函数：select max(math),min(math) from student; &#x2F;&#x2F;查询学生表的 最大数学成绩 与 最小数学成绩。</h4></li></ul></li><li><h4 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="(2). 字符串函数"></a>(2). 字符串函数</h4><p><img src="/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0.png"></p></li><li><h4 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="(3). 日期函数"></a>(3). 日期函数</h4><p><img src="/%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0.png"></p><h4 id="last-day（）：返回该日期-所在月份的最后一天的日期-如-last-day-‘2022-10-5’-2022-10-31-。"><a href="#last-day（）：返回该日期-所在月份的最后一天的日期-如-last-day-‘2022-10-5’-2022-10-31-。" class="headerlink" title="last_day（）：返回该日期 所在月份的最后一天的日期 如 last_day(‘2022.10.5’) &#x3D; 2022.10.31 。"></a>last_day（）：返回该日期 所在月份的最后一天的日期 如 last_day(‘2022.10.5’) &#x3D; 2022.10.31 。</h4></li><li><h4 id="4-数学相关函数"><a href="#4-数学相关函数" class="headerlink" title="(4). 数学相关函数"></a>(4). 数学相关函数</h4><p><img src="/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.png"></p></li><li><h4 id="5-加密与系统函数"><a href="#5-加密与系统函数" class="headerlink" title="(5).  加密与系统函数"></a>(5).  加密与系统函数</h4><p><img src="/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0.png"></p></li><li><h4 id="6-流程控制函数"><a href="#6-流程控制函数" class="headerlink" title="(6). 流程控制函数"></a>(6). 流程控制函数</h4><p><img src="/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0.png"></p></li></ul><h3 id="九、mysql-表查询加强"><a href="#九、mysql-表查询加强" class="headerlink" title="九、mysql 表查询加强"></a>九、mysql 表查询加强</h3><ul><li><h4 id="1-分页查询：select-from-emp-limit-每页显示记录数-第几页-1-每页显示记录数"><a href="#1-分页查询：select-from-emp-limit-每页显示记录数-第几页-1-每页显示记录数" class="headerlink" title="(1). 分页查询：select * from emp limit 每页显示记录数 * (第几页-1),每页显示记录数"></a>(1). 分页查询：select * from emp limit 每页显示记录数 * (第几页-1),每页显示记录数</h4><h4 id="select-from-emp-limit-3-2-3-显示-第3页的-三条数据"><a href="#select-from-emp-limit-3-2-3-显示-第3页的-三条数据" class="headerlink" title="select * from emp limit 3 * 2,3  &#x2F;&#x2F; 显示 第3页的 三条数据"></a>select * from emp limit 3 * 2,3  &#x2F;&#x2F; 显示 第3页的 三条数据</h4></li><li><h4 id="2-多子句查询：需要注意-各子句条件的顺序-依次为-group-by-having-order-by-limit"><a href="#2-多子句查询：需要注意-各子句条件的顺序-依次为-group-by-having-order-by-limit" class="headerlink" title="(2). 多子句查询：需要注意 各子句条件的顺序 依次为 group by-&gt; having-&gt; order by-&gt; limit"></a>(2). 多子句查询：需要注意 各子句条件的顺序 依次为 group by-&gt; having-&gt; order by-&gt; limit</h4><h4 id="select-avg-sal-as-avgfrom-emp-group-by-deptno-havingavg-1000-order-by-avg-desc-limit-0-2"><a href="#select-avg-sal-as-avgfrom-emp-group-by-deptno-havingavg-1000-order-by-avg-desc-limit-0-2" class="headerlink" title="select avg(sal) as avgfrom emp group by deptno  havingavg&gt;1000  order by avg desc limit 0,2;"></a><code>select avg(sal) as </code>avg<code>from emp group by deptno  having</code>avg<code>&gt;1000  order by </code>avg<code> desc limit 0,2;</code></h4></li><li><h4 id="3-多表查询"><a href="#3-多表查询" class="headerlink" title="(3). 多表查询"></a>(3). 多表查询</h4><ul><li><h5 id="笛卡尔集：当进行多表查询（起码查询2个或以上的表）时，如果没有添加条件语句下，mysql会自动以-第一个表中，取出一行-去与-第二张表中的每一行进行组合。这样查询出来的结果-就叫-笛卡尔集。如-1表有3行数据-2表有4行数据-，笛卡尔查询后-有-12条数据。"><a href="#笛卡尔集：当进行多表查询（起码查询2个或以上的表）时，如果没有添加条件语句下，mysql会自动以-第一个表中，取出一行-去与-第二张表中的每一行进行组合。这样查询出来的结果-就叫-笛卡尔集。如-1表有3行数据-2表有4行数据-，笛卡尔查询后-有-12条数据。" class="headerlink" title="笛卡尔集：当进行多表查询（起码查询2个或以上的表）时，如果没有添加条件语句下，mysql会自动以 第一个表中，取出一行 去与 第二张表中的每一行进行组合。这样查询出来的结果 就叫 笛卡尔集。如 1表有3行数据 2表有4行数据 ，笛卡尔查询后 有 12条数据。"></a>笛卡尔集：当进行多表查询（起码查询2个或以上的表）时，如果没有添加条件语句下，mysql会自动以 第一个表中，取出一行 去与 第二张表中的每一行进行组合。这样查询出来的结果 就叫 笛卡尔集。如 1表有3行数据 2表有4行数据 ，笛卡尔查询后 有 12条数据。</h5></li><li><h5 id="多表查询语句：select-ename-sal-dname-from-emp-dept-where-emp-deptno-dept-deptno"><a href="#多表查询语句：select-ename-sal-dname-from-emp-dept-where-emp-deptno-dept-deptno" class="headerlink" title="多表查询语句：select ename,sal,dname from emp,dept where emp.deptno&#x3D;dept.deptno;"></a>多表查询语句：select ename,sal,dname from emp,dept where emp.deptno&#x3D;dept.deptno;</h5></li><li><h5 id="自连接：把一张表-当成两张表使用-通常运用与-行与行之间的联动"><a href="#自连接：把一张表-当成两张表使用-通常运用与-行与行之间的联动" class="headerlink" title="自连接：把一张表 当成两张表使用 通常运用与 行与行之间的联动"></a>自连接：把一张表 当成两张表使用 通常运用与 行与行之间的联动</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>显示公司员工名字和他的上级的名字</span><br><span class="line"><span class="keyword">select</span> worker.ename,manger.ename <span class="keyword">from</span> emp worker,emp  manger <span class="keyword">where</span> worker.mgr<span class="operator">=</span>manger.empno;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="4-子查询"><a href="#4-子查询" class="headerlink" title="(4). 子查询"></a>(4). 子查询</h4><ul><li><h4 id="含义：指-嵌入在其它sql语句中的-select语句。"><a href="#含义：指-嵌入在其它sql语句中的-select语句。" class="headerlink" title="含义：指 嵌入在其它sql语句中的 select语句。"></a>含义：指 嵌入在其它sql语句中的 select语句。</h4></li><li><h4 id="单行子查询：只返回一行数据的子查询语句"><a href="#单行子查询：只返回一行数据的子查询语句" class="headerlink" title="单行子查询：只返回一行数据的子查询语句"></a>单行子查询：只返回一行数据的子查询语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 显示与ALLEN同一部门的所有员工</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span> ename<span class="operator">=</span><span class="string">&#x27;ALLEN&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><h4 id="多行子查询：返回多行数据的子查询，可以使用关键字-in"><a href="#多行子查询：返回多行数据的子查询，可以使用关键字-in" class="headerlink" title="多行子查询：返回多行数据的子查询，可以使用关键字 in"></a>多行子查询：返回多行数据的子查询，可以使用关键字 in</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询和部门<span class="number">10</span>的工作相同的雇员的</span><br><span class="line"><span class="comment">-- 名字、岗位、工资、部门号, 但是不含10号部门自己的雇员.</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename,job,sal,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="keyword">in</span>(<span class="keyword">select</span> job <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">10</span>) <span class="keyword">and</span> deptno <span class="operator">!=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><h4 id="关键字all-指代所有数据-、any-指代-任意一个-的使用"><a href="#关键字all-指代所有数据-、any-指代-任意一个-的使用" class="headerlink" title="关键字all(指代所有数据)、any(指代 任意一个)的使用"></a>关键字all(指代所有数据)、any(指代 任意一个)的使用</h4><h5 id="两个关键字也是针对-多行数据来进行-条件筛选"><a href="#两个关键字也是针对-多行数据来进行-条件筛选" class="headerlink" title="两个关键字也是针对 多行数据来进行 条件筛选"></a>两个关键字也是针对 多行数据来进行 条件筛选</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#关键字 <span class="keyword">all</span>、<span class="keyword">any</span>的使用</span><br><span class="line">#<span class="number">1.</span> 显示工资比部门<span class="number">30</span>的所有员工的工资高的员工的姓名、工资和部门号</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename,sal,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;</span><span class="keyword">all</span>(<span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">30</span>);</span><br><span class="line">#<span class="number">2.</span> 显示工资比部门<span class="number">30</span>的其中一个员工的工资高的员工的姓名、工资和部门号</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename,sal,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;</span><span class="keyword">any</span>(<span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><h4 id="子查询作为临时表"><a href="#子查询作为临时表" class="headerlink" title="子查询作为临时表"></a>子查询作为临时表</h4><h5 id="通常面对复杂的查询时，需要让子查询作为一个临时表来-进行多表查询"><a href="#通常面对复杂的查询时，需要让子查询作为一个临时表来-进行多表查询" class="headerlink" title="通常面对复杂的查询时，需要让子查询作为一个临时表来 进行多表查询"></a>通常面对复杂的查询时，需要让子查询作为一个临时表来 进行多表查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#把子查询作为临时表来使用</span><br><span class="line">#<span class="number">1.</span> 查询ecshop中各个类别中，价格最高的商品</span><br><span class="line">use ecshop;</span><br><span class="line">#先查询 各个类别 价格最高的价格 </span><br><span class="line"><span class="keyword">select</span> cat_id,<span class="built_in">max</span>(shop_price) <span class="keyword">from</span> ecs_goods <span class="keyword">group</span> <span class="keyword">by</span> cat_id;</span><br><span class="line"># 把子查询作为临时表 来 查询</span><br><span class="line"><span class="keyword">select</span> goods_id,temp.cat_id,goods_name,shop_price <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> cat_id,<span class="built_in">max</span>(shop_price) <span class="keyword">as</span> max_price <span class="keyword">from</span> ecs_goods <span class="keyword">group</span> <span class="keyword">by</span> cat_id) <span class="keyword">as</span> temp,ecs_goods</span><br><span class="line">    <span class="keyword">where</span> temp.cat_id<span class="operator">=</span>ecs_goods.cat_id <span class="keyword">and</span> shop_price<span class="operator">=</span>max_price;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="5-合并查询"><a href="#5-合并查询" class="headerlink" title="(5). 合并查询"></a>(5). 合并查询</h4><ul><li><h4 id="含义：当需要将两条查询语句的结果-进行合并时，可以使用关键字-union、unnion-all"><a href="#含义：当需要将两条查询语句的结果-进行合并时，可以使用关键字-union、unnion-all" class="headerlink" title="含义：当需要将两条查询语句的结果 进行合并时，可以使用关键字 union、unnion all"></a>含义：当需要将两条查询语句的结果 进行合并时，可以使用关键字 union、unnion all</h4></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> <span class="keyword">union</span> <span class="keyword">all</span> 连接两条查询语句 （不会去重）</span><br><span class="line"><span class="keyword">select</span> job,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;</span><span class="number">2500</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> job,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">#<span class="number">2.</span> <span class="keyword">union</span> 会去重</span><br><span class="line"><span class="keyword">select</span> job,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;</span><span class="number">2500</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> job,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li></li></ul><h3 id="十、表复制与去重"><a href="#十、表复制与去重" class="headerlink" title="十、表复制与去重"></a>十、表复制与去重</h3><ul><li><h4 id="含义：当需要针对sql语句进行效率测试时，需要有一个大量数据的表进行测试，这是就可以使用表复制。此外，也可以用于一个表-对另一个表的-快速赋值"><a href="#含义：当需要针对sql语句进行效率测试时，需要有一个大量数据的表进行测试，这是就可以使用表复制。此外，也可以用于一个表-对另一个表的-快速赋值" class="headerlink" title="含义：当需要针对sql语句进行效率测试时，需要有一个大量数据的表进行测试，这是就可以使用表复制。此外，也可以用于一个表 对另一个表的 快速赋值"></a>含义：当需要针对sql语句进行效率测试时，需要有一个大量数据的表进行测试，这是就可以使用表复制。此外，也可以用于一个表 对另一个表的 快速赋值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#进行表复制</span><br><span class="line">#直接在表名后 进行<span class="keyword">select</span>语句 即可对表进行复制 </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_01 <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">#自我复制</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_01 <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> tab_01;</span><br></pre></td></tr></table></figure></li><li><h4 id="去重：当表中-存在-大量的重复数据时，可以进行去重处理"><a href="#去重：当表中-存在-大量的重复数据时，可以进行去重处理" class="headerlink" title="去重：当表中 存在 大量的重复数据时，可以进行去重处理"></a>去重：当表中 存在 大量的重复数据时，可以进行去重处理</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#演示去重 既对表中一样的数据进行删除</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_02 <span class="keyword">like</span> tab_01; #<span class="number">1.</span> 创建一个临时表</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_02 <span class="keyword">select</span> <span class="keyword">distinct</span> <span class="operator">*</span><span class="keyword">from</span> tab_01; #<span class="number">2.</span> 对tab_01 进行去重复制</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tab_01; #<span class="number">3.</span> 删除tab_01 原有数据 </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_01 <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> tab_02; #<span class="number">4.</span> 将临时表tab_02中的数据 复制都 tab_01</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tab_02; #<span class="number">5.</span> 删除临时表 </span><br></pre></td></tr></table></figure></li></ul><h3 id="十一、外连接"><a href="#十一、外连接" class="headerlink" title="十一、外连接"></a>十一、外连接</h3><ul><li><h4 id="含义：当进行多表查询时，若需要两表-其中一表-不需要符合-两表匹配条件-也能显示-则可以使用-外连接"><a href="#含义：当进行多表查询时，若需要两表-其中一表-不需要符合-两表匹配条件-也能显示-则可以使用-外连接" class="headerlink" title="含义：当进行多表查询时，若需要两表 其中一表 不需要符合 两表匹配条件 也能显示 则可以使用 外连接"></a>含义：当进行多表查询时，若需要两表 其中一表 不需要符合 两表匹配条件 也能显示 则可以使用 外连接</h4></li><li><h4 id="分类：左连接（左表完全显示）、右连接（右表完全显示）"><a href="#分类：左连接（左表完全显示）、右连接（右表完全显示）" class="headerlink" title="分类：左连接（左表完全显示）、右连接（右表完全显示）"></a>分类：左连接（左表完全显示）、右连接（右表完全显示）</h4></li><li><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 列出部门名称和这些部门的员工名称和工作，</span><br><span class="line"><span class="comment">-- 同时要求 显示出那些没有员工的部门。</span></span><br><span class="line"># 左外连接实现</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename,dname,job <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno;</span><br><span class="line">#右外连接实现 </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename,dname,job <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno<span class="operator">=</span>dept.deptno;</span><br></pre></td></tr></table></figure></li></ul><h3 id="十二、mysql约束"><a href="#十二、mysql约束" class="headerlink" title="十二、mysql约束"></a>十二、mysql约束</h3><ul><li><h4 id="1-primary-key-主键"><a href="#1-primary-key-主键" class="headerlink" title="(1).  primary key 主键"></a>(1).  primary key 主键</h4><ul><li><h4 id="用处：用于唯一表示-表行的数据，当定义主键约束后，该列不能重复。既该列的数据，不能有重复数据。"><a href="#用处：用于唯一表示-表行的数据，当定义主键约束后，该列不能重复。既该列的数据，不能有重复数据。" class="headerlink" title="用处：用于唯一表示 表行的数据，当定义主键约束后，该列不能重复。既该列的数据，不能有重复数据。"></a>用处：用于唯一表示 表行的数据，当定义主键约束后，该列不能重复。既该列的数据，不能有重复数据。</h4></li><li><h4 id="用处细节："><a href="#用处细节：" class="headerlink" title="用处细节："></a>用处细节：</h4><ul><li><h4 id="primary-key-主键-不能重复而且不能为-null"><a href="#primary-key-主键-不能重复而且不能为-null" class="headerlink" title="primary key 主键 不能重复而且不能为 null"></a>primary key 主键 不能重复而且不能为 null</h4></li><li><h4 id="一张表-最多只能有一个主键。但可以存在-复合主键"><a href="#一张表-最多只能有一个主键。但可以存在-复合主键" class="headerlink" title="一张表 最多只能有一个主键。但可以存在 复合主键"></a>一张表 最多只能有一个主键。但可以存在 复合主键</h4></li><li><h4 id="可以使用-desc-来查看表结构，其中就可以查看-主键信息"><a href="#可以使用-desc-来查看表结构，其中就可以查看-主键信息" class="headerlink" title="可以使用 desc 来查看表结构，其中就可以查看 主键信息"></a>可以使用 desc 来查看表结构，其中就可以查看 主键信息</h4></li></ul></li></ul></li><li><h4 id="2-not-null（非空约束）与-unique（唯一约束）"><a href="#2-not-null（非空约束）与-unique（唯一约束）" class="headerlink" title="(2). not null（非空约束）与 unique（唯一约束）"></a>(2). not null（非空约束）与 unique（唯一约束）</h4><ul><li><h4 id="用处：被-not-null-约束的字段，数据不能为-null。-而被-nuique-约束的字段-则-数据不能重复。"><a href="#用处：被-not-null-约束的字段，数据不能为-null。-而被-nuique-约束的字段-则-数据不能重复。" class="headerlink" title="用处：被 not null 约束的字段，数据不能为 null。 而被 nuique 约束的字段 则 数据不能重复。"></a>用处：被 not null 约束的字段，数据不能为 null。 而被 nuique 约束的字段 则 数据不能重复。</h4></li><li><h4 id="使用细节：-1"><a href="#使用细节：-1" class="headerlink" title="使用细节："></a>使用细节：</h4><ul><li><h4 id="如果没有指定-not-null，则-unique-字段-可以有多个-null值-既空值。"><a href="#如果没有指定-not-null，则-unique-字段-可以有多个-null值-既空值。" class="headerlink" title="如果没有指定 not null，则 unique 字段 可以有多个 null值 既空值。"></a>如果没有指定 not null，则 unique 字段 可以有多个 null值 既空值。</h4></li><li><h4 id="一张表-可以有多个-unique-字段。"><a href="#一张表-可以有多个-unique-字段。" class="headerlink" title="一张表 可以有多个 unique 字段。"></a>一张表 可以有多个 unique 字段。</h4></li></ul></li></ul></li><li><h4 id="3-foreign-key（外键）"><a href="#3-foreign-key（外键）" class="headerlink" title="(3). foreign key（外键）"></a>(3). foreign key（外键）</h4><ul><li><h4 id="用处：当-一张表中其中一个字段（从表）-需要与-另一张表的字段（主表）-进行关联-以此来进行-两表之间进行多表查询。"><a href="#用处：当-一张表中其中一个字段（从表）-需要与-另一张表的字段（主表）-进行关联-以此来进行-两表之间进行多表查询。" class="headerlink" title="用处：当 一张表中其中一个字段（从表） 需要与 另一张表的字段（主表） 进行关联 以此来进行 两表之间进行多表查询。"></a>用处：当 一张表中其中一个字段（从表） 需要与 另一张表的字段（主表） 进行关联 以此来进行 两表之间进行多表查询。</h4><h4 id="这样-就需要-用外键来-对从表的-关联字段-进行-与主表的其中一个字段-进行-外键约束。"><a href="#这样-就需要-用外键来-对从表的-关联字段-进行-与主表的其中一个字段-进行-外键约束。" class="headerlink" title="这样 就需要 用外键来 对从表的 关联字段 进行 与主表的其中一个字段 进行 外键约束。"></a>这样 就需要 用外键来 对从表的 关联字段 进行 与主表的其中一个字段 进行 外键约束。</h4></li><li><h4 id="用法：-foreign-key-本字段名-references-主表名"><a href="#用法：-foreign-key-本字段名-references-主表名" class="headerlink" title="用法： foreign key (本字段名) references 主表名"></a>用法： foreign key (本字段名) references 主表名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#主表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> class(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    class_name <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#从表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    class_id <span class="type">int</span>,</span><br><span class="line">    #定义外键约束</span><br><span class="line">    <span class="keyword">foreign</span> key (class_id) <span class="keyword">references</span> class(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><h4 id="使用细节：-2"><a href="#使用细节：-2" class="headerlink" title="使用细节："></a>使用细节：</h4><ul><li><h4 id="外键-指向的表字段-要求必须是-primary-key-或是-unique-字段。既要避免-该字段是-可重复数据的字段"><a href="#外键-指向的表字段-要求必须是-primary-key-或是-unique-字段。既要避免-该字段是-可重复数据的字段" class="headerlink" title="外键 指向的表字段 要求必须是 primary key 或是 unique 字段。既要避免 该字段是 可重复数据的字段"></a>外键 指向的表字段 要求必须是 primary key 或是 unique 字段。既要避免 该字段是 可重复数据的字段</h4></li><li><h4 id="表的类型-是-innodb，这样的表-才能支持-外键"><a href="#表的类型-是-innodb，这样的表-才能支持-外键" class="headerlink" title="表的类型 是 innodb，这样的表 才能支持 外键"></a>表的类型 是 innodb，这样的表 才能支持 外键</h4></li><li><h4 id="外键字段的类型-要与-主键字段的类型-一样。（长度可以是不一样）"><a href="#外键字段的类型-要与-主键字段的类型-一样。（长度可以是不一样）" class="headerlink" title="外键字段的类型 要与 主键字段的类型 一样。（长度可以是不一样）"></a>外键字段的类型 要与 主键字段的类型 一样。（长度可以是不一样）</h4></li><li><h4 id="外键字段的值，必须在主键字段中出现过，或者为null值。"><a href="#外键字段的值，必须在主键字段中出现过，或者为null值。" class="headerlink" title="外键字段的值，必须在主键字段中出现过，或者为null值。"></a>外键字段的值，必须在主键字段中出现过，或者为null值。</h4></li><li><h4 id="一旦建立了主外键联系，主表的该主键属性-就不能随意删除。"><a href="#一旦建立了主外键联系，主表的该主键属性-就不能随意删除。" class="headerlink" title="一旦建立了主外键联系，主表的该主键属性 就不能随意删除。"></a>一旦建立了主外键联系，主表的该主键属性 就不能随意删除。</h4></li></ul></li></ul></li><li><h4 id="4-check-约束"><a href="#4-check-约束" class="headerlink" title="(4). check 约束"></a>(4). check 约束</h4><ul><li><h4 id="用处：可以让-约束字段的数据-需要符合该-check约束的条件才能添加成功。"><a href="#用处：可以让-约束字段的数据-需要符合该-check约束的条件才能添加成功。" class="headerlink" title="用处：可以让 约束字段的数据 需要符合该 check约束的条件才能添加成功。"></a>用处：可以让 约束字段的数据 需要符合该 check约束的条件才能添加成功。</h4></li><li><h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> exma(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    sex <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">check</span> (sex <span class="keyword">in</span>(<span class="string">&#x27;man&#x27;</span>,<span class="string">&#x27;woman&#x27;</span>)), #<span class="keyword">check</span> 对数据进行 筛选</span><br><span class="line">    sal <span class="keyword">double</span> <span class="keyword">check</span> (sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">and</span> sal<span class="operator">&lt;</span><span class="number">2000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><h4 id="注意：mysql5-7-不支持-check语法，但-oracle-与-sqlServer-数据库-支持。"><a href="#注意：mysql5-7-不支持-check语法，但-oracle-与-sqlServer-数据库-支持。" class="headerlink" title="注意：mysql5.7 不支持 check语法，但 oracle 与 sqlServer 数据库 支持。"></a>注意：mysql5.7 不支持 check语法，但 oracle 与 sqlServer 数据库 支持。</h4></li></ul></li><li><h4 id="5-自增长"><a href="#5-自增长" class="headerlink" title="(5). 自增长"></a>(5). 自增长</h4><ul><li><h4 id="用处：当定义一个-id列时，我们希望它能够-在添加数据时，自动增长数值，不需要人为添加。这时就可以-把id-设置为-自增长。"><a href="#用处：当定义一个-id列时，我们希望它能够-在添加数据时，自动增长数值，不需要人为添加。这时就可以-把id-设置为-自增长。" class="headerlink" title="用处：当定义一个 id列时，我们希望它能够 在添加数据时，自动增长数值，不需要人为添加。这时就可以 把id 设置为 自增长。"></a>用处：当定义一个 id列时，我们希望它能够 在添加数据时，自动增长数值，不需要人为添加。这时就可以 把id 设置为 自增长。</h4></li><li><h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment #默认从<span class="number">1</span> 开始增长</span><br></pre></td></tr></table></figure></li><li><h4 id="使用细节：-3"><a href="#使用细节：-3" class="headerlink" title="使用细节："></a>使用细节：</h4><ul><li><h4 id="一般来说，自增长是配合-primary-key-使用的。"><a href="#一般来说，自增长是配合-primary-key-使用的。" class="headerlink" title="一般来说，自增长是配合 primary key 使用的。"></a>一般来说，自增长是配合 primary key 使用的。</h4></li><li><h4 id="如果-想要自增长单独使用，则需要配合-unique-使用。既-避免-自增长字段-数据重复。"><a href="#如果-想要自增长单独使用，则需要配合-unique-使用。既-避免-自增长字段-数据重复。" class="headerlink" title="如果 想要自增长单独使用，则需要配合 unique 使用。既 避免 自增长字段 数据重复。"></a>如果 想要自增长单独使用，则需要配合 unique 使用。既 避免 自增长字段 数据重复。</h4></li><li><h4 id="自增长的-字段-通常为-整数型。"><a href="#自增长的-字段-通常为-整数型。" class="headerlink" title="自增长的 字段 通常为 整数型。"></a>自增长的 字段 通常为 整数型。</h4></li><li><h4 id="自增长-默认从1开始，当然-可以通过-alter-table-表名-auto-increment-xxx-来修改自增长的-起始值"><a href="#自增长-默认从1开始，当然-可以通过-alter-table-表名-auto-increment-xxx-来修改自增长的-起始值" class="headerlink" title="自增长 默认从1开始，当然 可以通过 alter table 表名 auto_increment &#x3D;xxx; 来修改自增长的 起始值"></a>自增长 默认从1开始，当然 可以通过 alter table 表名 auto_increment &#x3D;xxx; 来修改自增长的 起始值</h4></li></ul></li></ul></li></ul><h3 id="十三、索引"><a href="#十三、索引" class="headerlink" title="十三、索引"></a>十三、索引</h3><ul><li><h4 id="1-用处：当面对数据很多的情况下，需要查找其中一条数据-效率是非常慢的。这时候-就可以使用索引-来对-查询条件对应的列来-添加索引（如-where-id-45-给-id添加索引），以此来提升查询效率。"><a href="#1-用处：当面对数据很多的情况下，需要查找其中一条数据-效率是非常慢的。这时候-就可以使用索引-来对-查询条件对应的列来-添加索引（如-where-id-45-给-id添加索引），以此来提升查询效率。" class="headerlink" title="(1) 用处：当面对数据很多的情况下，需要查找其中一条数据 效率是非常慢的。这时候 就可以使用索引 来对 查询条件对应的列来 添加索引（如 where id&#x3D;45,给 id添加索引），以此来提升查询效率。"></a>(1) 用处：当面对数据很多的情况下，需要查找其中一条数据 效率是非常慢的。这时候 就可以使用索引 来对 查询条件对应的列来 添加索引（如 where id&#x3D;45,给 id添加索引），以此来提升查询效率。</h4></li><li><h4 id="2-机制（解决三个问题）"><a href="#2-机制（解决三个问题）" class="headerlink" title="(2)  机制（解决三个问题）"></a>(2)  机制（解决三个问题）</h4><ul><li><h4 id="1-没有索引-为什么会慢？：-正常情况下，如果要查询某条语句，mysql是-全表扫面查询的（既-一条一条的查询）。这样就会效率很慢，即使-被查询的数据-第一条就符合条件-依然会-全表遍历查询。"><a href="#1-没有索引-为什么会慢？：-正常情况下，如果要查询某条语句，mysql是-全表扫面查询的（既-一条一条的查询）。这样就会效率很慢，即使-被查询的数据-第一条就符合条件-依然会-全表遍历查询。" class="headerlink" title="1. 没有索引 为什么会慢？： 正常情况下，如果要查询某条语句，mysql是 全表扫面查询的（既 一条一条的查询）。这样就会效率很慢，即使 被查询的数据 第一条就符合条件 依然会 全表遍历查询。"></a>1. 没有索引 为什么会慢？： 正常情况下，如果要查询某条语句，mysql是 全表扫面查询的（既 一条一条的查询）。这样就会效率很慢，即使 被查询的数据 第一条就符合条件 依然会 全表遍历查询。</h4></li><li><h4 id="2-使用索引-为什么变快？：-在使用索引的情况下，会对-添加索引的列-进行-数据结构化的处理-如-进行-二叉树的索引、B-树等-便于查询-的数据结构。这样-自然会增加查询的效率。"><a href="#2-使用索引-为什么变快？：-在使用索引的情况下，会对-添加索引的列-进行-数据结构化的处理-如-进行-二叉树的索引、B-树等-便于查询-的数据结构。这样-自然会增加查询的效率。" class="headerlink" title="2. 使用索引 为什么变快？： 在使用索引的情况下，会对 添加索引的列 进行 数据结构化的处理 如 进行 二叉树的索引、B+树等 便于查询 的数据结构。这样 自然会增加查询的效率。"></a>2. 使用索引 为什么变快？： 在使用索引的情况下，会对 添加索引的列 进行 数据结构化的处理 如 进行 二叉树的索引、B+树等 便于查询 的数据结构。这样 自然会增加查询的效率。</h4></li><li><h4 id="3-使用索引的代价：-其一，会对表的空间增大，一定程度上加大了磁盘的占用。-其二，会对dml-insert、update、delete-语句-的效率有所影响。因为，每次修改表数据，都需要去维护-索引的数据结构。"><a href="#3-使用索引的代价：-其一，会对表的空间增大，一定程度上加大了磁盘的占用。-其二，会对dml-insert、update、delete-语句-的效率有所影响。因为，每次修改表数据，都需要去维护-索引的数据结构。" class="headerlink" title="3. 使用索引的代价： 其一，会对表的空间增大，一定程度上加大了磁盘的占用。 其二，会对dml(insert、update、delete) 语句 的效率有所影响。因为，每次修改表数据，都需要去维护 索引的数据结构。"></a>3. 使用索引的代价： 其一，会对表的空间增大，一定程度上加大了磁盘的占用。 其二，会对dml(insert、update、delete) 语句 的效率有所影响。因为，每次修改表数据，都需要去维护 索引的数据结构。</h4></li></ul></li><li><h4 id="3-索引的分类"><a href="#3-索引的分类" class="headerlink" title="(3) 索引的分类"></a>(3) 索引的分类</h4><ul><li><h4 id="主键索引-primary-key-：既-把列设置为主键，会自动的定义于-创建了-主索引-primary-key"><a href="#主键索引-primary-key-：既-把列设置为主键，会自动的定义于-创建了-主索引-primary-key" class="headerlink" title="主键索引(primary key)：既 把列设置为主键，会自动的定义于 创建了 主索引(primary key)"></a>主键索引(primary key)：既 把列设置为主键，会自动的定义于 创建了 主索引(primary key)</h4></li><li><h4 id="唯一索引-unique-：添加该索引，则-该列的值-必须是唯一，不能重复"><a href="#唯一索引-unique-：添加该索引，则-该列的值-必须是唯一，不能重复" class="headerlink" title="唯一索引(unique)：添加该索引，则 该列的值 必须是唯一，不能重复"></a>唯一索引(unique)：添加该索引，则 该列的值 必须是唯一，不能重复</h4></li><li><h4 id="普通索引-index-：既正常的-对该列-进行索引。没啥约束条件"><a href="#普通索引-index-：既正常的-对该列-进行索引。没啥约束条件" class="headerlink" title="普通索引(index)：既正常的 对该列 进行索引。没啥约束条件"></a>普通索引(index)：既正常的 对该列 进行索引。没啥约束条件</h4></li><li><h4 id="全文索引-fulltext-：适用于MyIsam-数据库引擎-少用"><a href="#全文索引-fulltext-：适用于MyIsam-数据库引擎-少用" class="headerlink" title="全文索引(fulltext)：适用于MyIsam 数据库引擎(少用)"></a>全文索引(fulltext)：适用于MyIsam 数据库引擎(少用)</h4></li></ul></li><li><h4 id="4-索引的使用"><a href="#4-索引的使用" class="headerlink" title="(4) 索引的使用"></a>(4) 索引的使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#演示索引</span><br><span class="line">use exam_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> exma;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> exam(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#添加索引</span><br><span class="line">#<span class="number">1.</span> 添加唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index id_index <span class="keyword">on</span> exam(id);</span><br><span class="line"><span class="keyword">show</span> indexes <span class="keyword">from</span> exam;</span><br><span class="line">#<span class="number">2.</span> 添加普通索引</span><br><span class="line"><span class="keyword">create</span> index name_index <span class="keyword">on</span> exam(age); #方式<span class="number">1</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> exam_02 <span class="keyword">add</span> index id_index (id); #方式<span class="number">2</span></span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span> 如何选择 是添加 唯一索引 还是 普通索引</span><br><span class="line">#当 该列被要求不能够重复数据出来的 则用 唯一索引，反之亦然</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> exam_02(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line">#<span class="number">4.</span> 添加主键索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> exam_02 <span class="keyword">add</span> <span class="keyword">primary</span> key (`name`);</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> index id_index <span class="keyword">on</span> exam_02;</span><br><span class="line">#删除主键索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> exam_02 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line">#查询索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> exam;</span><br><span class="line"><span class="keyword">show</span> indexes <span class="keyword">from</span> exam;</span><br><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> exam;</span><br><span class="line"><span class="keyword">desc</span> exam; #不推荐 不够详细</span><br></pre></td></tr></table></figure></li><li><h4 id="5-创建索引的规则"><a href="#5-创建索引的规则" class="headerlink" title="(5) 创建索引的规则"></a>(5) 创建索引的规则</h4><ul><li><h4 id="1-较为频繁的作为-查询条件的-列，应该创建索引。如id"><a href="#1-较为频繁的作为-查询条件的-列，应该创建索引。如id" class="headerlink" title="1. 较为频繁的作为 查询条件的 列，应该创建索引。如id"></a>1. 较为频繁的作为 查询条件的 列，应该创建索引。如id</h4></li><li><h4 id="2-唯一性太差的-列-不应该-设置索引。-即使该列-频繁作为查询条件"><a href="#2-唯一性太差的-列-不应该-设置索引。-即使该列-频繁作为查询条件" class="headerlink" title="2. 唯一性太差的 列 不应该 设置索引。 即使该列 频繁作为查询条件"></a>2. 唯一性太差的 列 不应该 设置索引。 即使该列 频繁作为查询条件</h4></li><li><h4 id="3-频繁更新的列-不应该设置为索引"><a href="#3-频繁更新的列-不应该设置为索引" class="headerlink" title="3. 频繁更新的列 不应该设置为索引"></a>3. 频繁更新的列 不应该设置为索引</h4></li><li><h4 id="4-不会作为-查询条件的-列-不设置索引"><a href="#4-不会作为-查询条件的-列-不设置索引" class="headerlink" title="4. 不会作为 查询条件的 列 不设置索引"></a>4. 不会作为 查询条件的 列 不设置索引</h4></li></ul></li></ul><h3 id="十四、事务"><a href="#十四、事务" class="headerlink" title="十四、事务"></a>十四、事务</h3><ul><li><h4 id="1-含义：事务用于保证-数据的一致性，它由一组的dml语句组成，改组的dml语句-要么全部成功，要么全部失败。"><a href="#1-含义：事务用于保证-数据的一致性，它由一组的dml语句组成，改组的dml语句-要么全部成功，要么全部失败。" class="headerlink" title="(1) 含义：事务用于保证 数据的一致性，它由一组的dml语句组成，改组的dml语句 要么全部成功，要么全部失败。"></a>(1) 含义：事务用于保证 数据的一致性，它由一组的dml语句组成，改组的dml语句 要么全部成功，要么全部失败。</h4></li><li><h4 id="2-锁的含义：-当多个用户操作同一张表时，锁可以防止其它用户修改表的数据，既只能让一个用户操作一张表。"><a href="#2-锁的含义：-当多个用户操作同一张表时，锁可以防止其它用户修改表的数据，既只能让一个用户操作一张表。" class="headerlink" title="(2) 锁的含义： 当多个用户操作同一张表时，锁可以防止其它用户修改表的数据，既只能让一个用户操作一张表。"></a>(2) 锁的含义： 当多个用户操作同一张表时，锁可以防止其它用户修改表的数据，既只能让一个用户操作一张表。</h4></li><li><h4 id="3-事务的操作"><a href="#3-事务的操作" class="headerlink" title="(3) 事务的操作"></a>(3) 事务的操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction; #开启事务 # 设置一个 保存点 可用于 回滚</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> exam <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> exam <span class="keyword">values</span>(<span class="number">21</span>,<span class="number">34</span>);</span><br><span class="line"><span class="keyword">savepoint</span> b; #设置一个 保存点 b 可用于回滚 </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> exam <span class="keyword">values</span>(<span class="number">45</span>,<span class="number">56</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> exam;</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> b; #回滚事务 到 a结点 </span><br><span class="line"><span class="keyword">rollback</span>; #可以直接回滚到 事务刚开始的状态。</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; #提交事务 提交完之后 就叫不能回滚</span><br></pre></td></tr></table></figure></li><li><h4 id="4-事务操作细节"><a href="#4-事务操作细节" class="headerlink" title="(4) 事务操作细节"></a>(4) 事务操作细节</h4><ul><li><h5 id="如果没有-开始事务，默认情况下，dml操作是-自动提交的，不能回滚。"><a href="#如果没有-开始事务，默认情况下，dml操作是-自动提交的，不能回滚。" class="headerlink" title="如果没有 开始事务，默认情况下，dml操作是 自动提交的，不能回滚。"></a>如果没有 开始事务，默认情况下，dml操作是 自动提交的，不能回滚。</h5></li><li><h5 id="mysql-的事务机制-需要-innodb的存储引擎才可以使用-，而-myisam-引擎不好使。"><a href="#mysql-的事务机制-需要-innodb的存储引擎才可以使用-，而-myisam-引擎不好使。" class="headerlink" title="mysql 的事务机制 需要 innodb的存储引擎才可以使用 ，而 myisam 引擎不好使。"></a>mysql 的事务机制 需要 innodb的存储引擎才可以使用 ，而 myisam 引擎不好使。</h5></li><li><h5 id="开始事务的语句有两个-1-start-transaction-2-set-autocommit-off"><a href="#开始事务的语句有两个-1-start-transaction-2-set-autocommit-off" class="headerlink" title="开始事务的语句有两个 1. start transaction 2. set autocommit&#x3D;off"></a>开始事务的语句有两个 1. start transaction 2. set autocommit&#x3D;off</h5></li></ul></li><li><h4 id="5-事务隔离级别"><a href="#5-事务隔离级别" class="headerlink" title="(5) 事务隔离级别"></a>(5) 事务隔离级别</h4><ul><li><h4 id="介绍：当多个连接-开启各自的事务操作-数据库中的数据时，数据库系统-需要负责-隔离操作，保证各个连接在获取数据时的准确性。"><a href="#介绍：当多个连接-开启各自的事务操作-数据库中的数据时，数据库系统-需要负责-隔离操作，保证各个连接在获取数据时的准确性。" class="headerlink" title="介绍：当多个连接 开启各自的事务操作 数据库中的数据时，数据库系统 需要负责 隔离操作，保证各个连接在获取数据时的准确性。"></a>介绍：当多个连接 开启各自的事务操作 数据库中的数据时，数据库系统 需要负责 隔离操作，保证各个连接在获取数据时的准确性。</h4></li><li><h4 id="不考虑隔离性可能会出现的问题："><a href="#不考虑隔离性可能会出现的问题：" class="headerlink" title="不考虑隔离性可能会出现的问题："></a>不考虑隔离性可能会出现的问题：</h4><ul><li><h5 id="1-脏读-dirty-read-：当一个事务-读取到了-另一个事务尚未提交的修改时，就为脏读"><a href="#1-脏读-dirty-read-：当一个事务-读取到了-另一个事务尚未提交的修改时，就为脏读" class="headerlink" title="1. 脏读(dirty read)：当一个事务 读取到了 另一个事务尚未提交的修改时，就为脏读"></a>1. 脏读(dirty read)：当一个事务 读取到了 另一个事务尚未提交的修改时，就为脏读</h5></li><li><h5 id="2-不可重复读-nonrepeatable-read-由于-其中一个事务-提交了-对数据进行的-修改或者删除-操作，而另一个事务-多次查询了该数据，返回了多次不一样的结果，这就为-不可重复读。"><a href="#2-不可重复读-nonrepeatable-read-由于-其中一个事务-提交了-对数据进行的-修改或者删除-操作，而另一个事务-多次查询了该数据，返回了多次不一样的结果，这就为-不可重复读。" class="headerlink" title="2. 不可重复读(nonrepeatable read): 由于 其中一个事务 提交了 对数据进行的 修改或者删除 操作，而另一个事务 多次查询了该数据，返回了多次不一样的结果，这就为 不可重复读。"></a>2. 不可重复读(nonrepeatable read): 由于 其中一个事务 提交了 对数据进行的 修改或者删除 操作，而另一个事务 多次查询了该数据，返回了多次不一样的结果，这就为 不可重复读。</h5></li><li><h5 id="3-幻读-phantom-read-由于-其中一个事务-提交了-对数据进行的-增加-操作，而另一个事务-多次查询了该数据，返回了多次不一样的结果，这就为-幻读。"><a href="#3-幻读-phantom-read-由于-其中一个事务-提交了-对数据进行的-增加-操作，而另一个事务-多次查询了该数据，返回了多次不一样的结果，这就为-幻读。" class="headerlink" title="3. 幻读(phantom read): 由于 其中一个事务 提交了 对数据进行的 增加 操作，而另一个事务 多次查询了该数据，返回了多次不一样的结果，这就为 幻读。"></a>3. 幻读(phantom read): 由于 其中一个事务 提交了 对数据进行的 增加 操作，而另一个事务 多次查询了该数据，返回了多次不一样的结果，这就为 幻读。</h5></li></ul></li><li><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png"></p></li><li><h4 id="隔离级别操作"><a href="#隔离级别操作" class="headerlink" title="隔离级别操作"></a>隔离级别操作</h4><ul><li><h5 id="查看当前会话隔离级别：-select-tx-isolation"><a href="#查看当前会话隔离级别：-select-tx-isolation" class="headerlink" title="查看当前会话隔离级别： select @@tx_isolation"></a>查看当前会话隔离级别： select @@tx_isolation</h5></li><li><h5 id="查看系统当前隔离级别：select-global-tx-isolation"><a href="#查看系统当前隔离级别：select-global-tx-isolation" class="headerlink" title="查看系统当前隔离级别：select @@global.tx_isolation"></a>查看系统当前隔离级别：select @@global.tx_isolation</h5></li><li><h5 id="设置当前会话隔离级别：set-session-transation-isolation-level-xx-既需要设置的-隔离级别"><a href="#设置当前会话隔离级别：set-session-transation-isolation-level-xx-既需要设置的-隔离级别" class="headerlink" title="设置当前会话隔离级别：set session transation isolation level xx(既需要设置的 隔离级别)"></a>设置当前会话隔离级别：set session transation isolation level xx(既需要设置的 隔离级别)</h5></li><li><h5 id="设置系统当前隔离级别：-set-global-transation-isolation-level-xx-既需要设置的-隔离级别"><a href="#设置系统当前隔离级别：-set-global-transation-isolation-level-xx-既需要设置的-隔离级别" class="headerlink" title="设置系统当前隔离级别： set global transation isolation level xx(既需要设置的 隔离级别)"></a>设置系统当前隔离级别： set global transation isolation level xx(既需要设置的 隔离级别)</h5></li><li><h5 id="mysql-的-默认事务隔离级别-是-reoeatable-read-可重复读-。可在mysql的安装目录中-的-my-ini-文件-transaction-isolation-xx-修改默认的-隔离级别。"><a href="#mysql-的-默认事务隔离级别-是-reoeatable-read-可重复读-。可在mysql的安装目录中-的-my-ini-文件-transaction-isolation-xx-修改默认的-隔离级别。" class="headerlink" title="mysql 的 默认事务隔离级别 是 reoeatable read(可重复读) 。可在mysql的安装目录中 的 my.ini 文件 transaction-isolation &#x3D; xx 修改默认的 隔离级别。"></a>mysql 的 默认事务隔离级别 是 reoeatable read(可重复读) 。可在mysql的安装目录中 的 my.ini 文件 transaction-isolation &#x3D; xx 修改默认的 隔离级别。</h5></li></ul></li><li><h4 id="事务的-acid特性"><a href="#事务的-acid特性" class="headerlink" title="事务的 acid特性"></a>事务的 acid特性</h4><p><img src="/%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7.png"></p></li></ul></li></ul><h3 id="十五、存储引擎"><a href="#十五、存储引擎" class="headerlink" title="十五、存储引擎"></a>十五、存储引擎</h3><ul><li><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="(1) 基本介绍"></a>(1) 基本介绍</h4><ul><li><h4 id="mysql-表类型-由-存储引擎决定，主要包括有Myisam、innodb、memory等。"><a href="#mysql-表类型-由-存储引擎决定，主要包括有Myisam、innodb、memory等。" class="headerlink" title="mysql 表类型 由 存储引擎决定，主要包括有Myisam、innodb、memory等。"></a>mysql 表类型 由 存储引擎决定，主要包括有Myisam、innodb、memory等。</h4></li><li><h4 id="mysql数据库表-支持六种类型，分别为CSV、Memory、ARCHIVE、MRG、MYISAM、innoDB。"><a href="#mysql数据库表-支持六种类型，分别为CSV、Memory、ARCHIVE、MRG、MYISAM、innoDB。" class="headerlink" title="mysql数据库表 支持六种类型，分别为CSV、Memory、ARCHIVE、MRG、MYISAM、innoDB。"></a>mysql数据库表 支持六种类型，分别为CSV、Memory、ARCHIVE、MRG、MYISAM、innoDB。</h4></li><li><h4 id="这六种类型又区分为两类，一类是-“事务安全型”-如-innoDB-另一类则是为-“非事务安全型”-其余的表类型-都是该类型"><a href="#这六种类型又区分为两类，一类是-“事务安全型”-如-innoDB-另一类则是为-“非事务安全型”-其余的表类型-都是该类型" class="headerlink" title="这六种类型又区分为两类，一类是 “事务安全型” 如 innoDB 另一类则是为 “非事务安全型” 其余的表类型 都是该类型"></a>这六种类型又区分为两类，一类是 “事务安全型” 如 innoDB 另一类则是为 “非事务安全型” 其余的表类型 都是该类型</h4></li></ul></li><li><h4 id="2-存储引擎的特点"><a href="#2-存储引擎的特点" class="headerlink" title="(2) 存储引擎的特点"></a>(2) 存储引擎的特点</h4><p><img src="/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E7%89%B9%E7%82%B9.png"></p></li><li><h4 id="3-三种主要的存储引擎介绍"><a href="#3-三种主要的存储引擎介绍" class="headerlink" title="(3) 三种主要的存储引擎介绍"></a>(3) 三种主要的存储引擎介绍</h4><ul><li><h4 id="MyISAM-不支持事务、外键，但访问速度快，对事务完整性没有要求。"><a href="#MyISAM-不支持事务、外键，但访问速度快，对事务完整性没有要求。" class="headerlink" title="MyISAM: 不支持事务、外键，但访问速度快，对事务完整性没有要求。"></a>MyISAM: 不支持事务、外键，但访问速度快，对事务完整性没有要求。</h4></li><li><h4 id="InnoDB：提供了具有提交、回滚、崩溃恢复能力的事务安全功能，但是对比-MyISAM-的处理效率差，并且会占用更多的磁盘空间-用来保存-数据-和-索引。"><a href="#InnoDB：提供了具有提交、回滚、崩溃恢复能力的事务安全功能，但是对比-MyISAM-的处理效率差，并且会占用更多的磁盘空间-用来保存-数据-和-索引。" class="headerlink" title="InnoDB：提供了具有提交、回滚、崩溃恢复能力的事务安全功能，但是对比 MyISAM 的处理效率差，并且会占用更多的磁盘空间 用来保存 数据 和 索引。"></a>InnoDB：提供了具有提交、回滚、崩溃恢复能力的事务安全功能，但是对比 MyISAM 的处理效率差，并且会占用更多的磁盘空间 用来保存 数据 和 索引。</h4></li><li><h4 id="MEMORY-使用-内存-来创建表，每个-memory表实际对应一个磁盘文件。-对于表的访问-非常得快，因为数据是放在-内存中的，默认使用-HASH索引。-一旦mysql服务关闭，那么表的数据就会全部丢失，但是表结构还在。"><a href="#MEMORY-使用-内存-来创建表，每个-memory表实际对应一个磁盘文件。-对于表的访问-非常得快，因为数据是放在-内存中的，默认使用-HASH索引。-一旦mysql服务关闭，那么表的数据就会全部丢失，但是表结构还在。" class="headerlink" title="MEMORY: 使用 内存 来创建表，每个 memory表实际对应一个磁盘文件。 对于表的访问 非常得快，因为数据是放在 内存中的，默认使用 HASH索引。 一旦mysql服务关闭，那么表的数据就会全部丢失，但是表结构还在。"></a>MEMORY: 使用 内存 来创建表，每个 memory表实际对应一个磁盘文件。 对于表的访问 非常得快，因为数据是放在 内存中的，默认使用 HASH索引。 一旦mysql服务关闭，那么表的数据就会全部丢失，但是表结构还在。</h4></li></ul></li><li><h4 id="4-如何选择存储引擎"><a href="#4-如何选择存储引擎" class="headerlink" title="(4) 如何选择存储引擎"></a>(4) 如何选择存储引擎</h4><ul><li><h4 id="如果应用不需要事务的功能-，就可以使用-MyISAM-。若需要-则用-innoDB"><a href="#如果应用不需要事务的功能-，就可以使用-MyISAM-。若需要-则用-innoDB" class="headerlink" title="如果应用不需要事务的功能 ，就可以使用 MyISAM 。若需要 则用 innoDB"></a>如果应用不需要事务的功能 ，就可以使用 MyISAM 。若需要 则用 innoDB</h4></li><li><h4 id="对于-数据经常产生变化，并且-该数据没有保存的意义时，就可以选择-MEMORY"><a href="#对于-数据经常产生变化，并且-该数据没有保存的意义时，就可以选择-MEMORY" class="headerlink" title="对于 数据经常产生变化，并且 该数据没有保存的意义时，就可以选择 MEMORY"></a>对于 数据经常产生变化，并且 该数据没有保存的意义时，就可以选择 MEMORY</h4></li></ul></li><li><h4 id="5-引擎基本操作"><a href="#5-引擎基本操作" class="headerlink" title="(5) 引擎基本操作"></a>(5) 引擎基本操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建引擎</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">)engine MyISAM;</span><br><span class="line"></span><br><span class="line">#修改引擎</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 engine <span class="operator">=</span> innoDB;</span><br></pre></td></tr></table></figure></li></ul><h3 id="十六、视图"><a href="#十六、视图" class="headerlink" title="十六、视图"></a>十六、视图</h3><ul><li><h4 id="1-含义：视图-是一个虚拟表，其内容是根据查询定义的。同真实的表一样，视图中的列-均来自于-对应的真实表（基表）的数据。"><a href="#1-含义：视图-是一个虚拟表，其内容是根据查询定义的。同真实的表一样，视图中的列-均来自于-对应的真实表（基表）的数据。" class="headerlink" title="(1) 含义：视图 是一个虚拟表，其内容是根据查询定义的。同真实的表一样，视图中的列 均来自于 对应的真实表（基表）的数据。"></a>(1) 含义：视图 是一个虚拟表，其内容是根据查询定义的。同真实的表一样，视图中的列 均来自于 对应的真实表（基表）的数据。</h4></li><li><h4 id="2-视图基本使用"><a href="#2-视图基本使用" class="headerlink" title="(2) 视图基本使用"></a>(2) 视图基本使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#视图的使用</span><br><span class="line">use exam_01;</span><br><span class="line">#<span class="number">1.</span> 创建一个视图emp_view01，只能查询emp表的(empno、ename, job 和 deptno ) 信息</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_view01 <span class="keyword">as</span> <span class="keyword">select</span> empno,ename,job,deptno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span> 查看视图</span><br><span class="line"><span class="keyword">desc</span> emp_view01;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span> 查看创建视图的指令</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> emp_view01;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span> 删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> emp_view01;</span><br></pre></td></tr></table></figure></li><li><h4 id="3-使用细节"><a href="#3-使用细节" class="headerlink" title="(3) 使用细节"></a>(3) 使用细节</h4><ul><li><h4 id="创建视图后，在mysql-存放数据库的文件中，可以看到视图只有-视图结构文件-视图名-frm"><a href="#创建视图后，在mysql-存放数据库的文件中，可以看到视图只有-视图结构文件-视图名-frm" class="headerlink" title="创建视图后，在mysql 存放数据库的文件中，可以看到视图只有 视图结构文件(视图名.frm)"></a>创建视图后，在mysql 存放数据库的文件中，可以看到视图只有 视图结构文件(视图名.frm)</h4></li><li><h4 id="改变视图的数据-就会改变基表的-数据。-基表的数据-自然会影响到-视图的数据"><a href="#改变视图的数据-就会改变基表的-数据。-基表的数据-自然会影响到-视图的数据" class="headerlink" title="改变视图的数据 就会改变基表的 数据。 基表的数据 自然会影响到 视图的数据"></a>改变视图的数据 就会改变基表的 数据。 基表的数据 自然会影响到 视图的数据</h4></li><li><h4 id="视图-也可以作为-基表，既-视图中-可以再使用-视图"><a href="#视图-也可以作为-基表，既-视图中-可以再使用-视图" class="headerlink" title="视图 也可以作为 基表，既 视图中 可以再使用 视图"></a>视图 也可以作为 基表，既 视图中 可以再使用 视图</h4></li></ul></li><li><h4 id="4-视图的最佳实践"><a href="#4-视图的最佳实践" class="headerlink" title="(4) 视图的最佳实践"></a>(4) 视图的最佳实践</h4><ul><li><h4 id="安全：视图可以有效帮助-基表保密某些字段，公开的字段-直接在视图显示即可，就不用查看到基表了。"><a href="#安全：视图可以有效帮助-基表保密某些字段，公开的字段-直接在视图显示即可，就不用查看到基表了。" class="headerlink" title="安全：视图可以有效帮助 基表保密某些字段，公开的字段 直接在视图显示即可，就不用查看到基表了。"></a>安全：视图可以有效帮助 基表保密某些字段，公开的字段 直接在视图显示即可，就不用查看到基表了。</h4></li><li><h4 id="性能：若需要-多表查询的时候，往往会进行分表查询，创建外键建立联系等操作，这样麻烦而且效率低。这时，就可以通过-视图-把需要的列组合在-一起就可以-通过一张视图就能查询想要的信息了。"><a href="#性能：若需要-多表查询的时候，往往会进行分表查询，创建外键建立联系等操作，这样麻烦而且效率低。这时，就可以通过-视图-把需要的列组合在-一起就可以-通过一张视图就能查询想要的信息了。" class="headerlink" title="性能：若需要 多表查询的时候，往往会进行分表查询，创建外键建立联系等操作，这样麻烦而且效率低。这时，就可以通过 视图 把需要的列组合在 一起就可以 通过一张视图就能查询想要的信息了。"></a>性能：若需要 多表查询的时候，往往会进行分表查询，创建外键建立联系等操作，这样麻烦而且效率低。这时，就可以通过 视图 把需要的列组合在 一起就可以 通过一张视图就能查询想要的信息了。</h4></li><li><h4 id="灵活：若有一张-旧表，即将废弃，但是该表-涉及到很多-其它表，不便于删除与修改。这时，就可以使用-视图来-映射到相关的-数据（既-旧表与其它表设计的列）。这样-就可以不需要改变旧表-也能实现-创建新表的效果。"><a href="#灵活：若有一张-旧表，即将废弃，但是该表-涉及到很多-其它表，不便于删除与修改。这时，就可以使用-视图来-映射到相关的-数据（既-旧表与其它表设计的列）。这样-就可以不需要改变旧表-也能实现-创建新表的效果。" class="headerlink" title="灵活：若有一张 旧表，即将废弃，但是该表 涉及到很多 其它表，不便于删除与修改。这时，就可以使用 视图来 映射到相关的 数据（既 旧表与其它表设计的列）。这样 就可以不需要改变旧表 也能实现 创建新表的效果。"></a>灵活：若有一张 旧表，即将废弃，但是该表 涉及到很多 其它表，不便于删除与修改。这时，就可以使用 视图来 映射到相关的 数据（既 旧表与其它表设计的列）。这样 就可以不需要改变旧表 也能实现 创建新表的效果。</h4></li></ul></li></ul><h3 id="十七、mysql用户管理"><a href="#十七、mysql用户管理" class="headerlink" title="十七、mysql用户管理"></a>十七、mysql用户管理</h3><ul><li><h4 id="1-基本介绍：mysql中的用户，都存储在-数据库mysql中的-user表中。-该表主要有三个字段-host-允许登录的位置，既ip号，user：用户名，authentication-string-：用password-函数加密过的-密码。"><a href="#1-基本介绍：mysql中的用户，都存储在-数据库mysql中的-user表中。-该表主要有三个字段-host-允许登录的位置，既ip号，user：用户名，authentication-string-：用password-函数加密过的-密码。" class="headerlink" title="(1) 基本介绍：mysql中的用户，都存储在 数据库mysql中的 user表中。 该表主要有三个字段, host: 允许登录的位置，既ip号，user：用户名，authentication_string ：用password()函数加密过的 密码。"></a>(1) 基本介绍：mysql中的用户，都存储在 数据库mysql中的 user表中。 该表主要有三个字段, host: 允许登录的位置，既ip号，user：用户名，authentication_string ：用password()函数加密过的 密码。</h4></li><li><h4 id="2-用户基本操作"><a href="#2-用户基本操作" class="headerlink" title="(2) 用户基本操作"></a>(2) 用户基本操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#演示用户相关操作</span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span> 创建用户</span><br><span class="line"># <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>: 用户名 与 登录位置(ip) </span><br><span class="line"># <span class="string">&#x27;123456&#x27;</span>： 密码</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>; </span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span> 查询用户</span><br><span class="line"><span class="keyword">select</span> `host`,`<span class="keyword">user</span>`,authentication_string <span class="keyword">from</span> mysql.user;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span>修改密码</span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> password(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line">#如果 登录用户就是 本身 则可以 简化修改密码语句</span><br><span class="line"><span class="keyword">set</span> password <span class="operator">=</span> password(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span> 删除用户</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><h4 id="3-用户权限设置"><a href="#3-用户权限设置" class="headerlink" title="(3) 用户权限设置"></a>(3) 用户权限设置</h4><ul><li><h5 id="语法设置"><a href="#语法设置" class="headerlink" title="语法设置"></a>语法设置</h5><p><img src="/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%AF%AD%E6%B3%95.png"></p></li><li><h5 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#演示 用户权限管理</span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span> 创建用户</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;jack&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span> 使用root 用户创建 testdb数据库  ,表 news 并添加测试数据</span><br><span class="line"><span class="keyword">create</span> database testdb;</span><br><span class="line">use testdb;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> news(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    content <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;广州新闻&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;肇庆新闻&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span> 给 jack 分配查看 news 表和 添加news的权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span> <span class="keyword">on</span> testdb.news <span class="keyword">to</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">4.</span> 可以增加<span class="keyword">update</span>权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span> <span class="keyword">on</span> testdb.news <span class="keyword">to</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">5.</span> 回收 jack 用户在 testdb.news 表的所有权限</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span>,<span class="keyword">update</span>,<span class="keyword">insert</span> <span class="keyword">on</span> testdb.news <span class="keyword">from</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">#如果想要省事 可以这样写</span><br><span class="line">#<span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> testdb.news <span class="keyword">from</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">6.</span> 删除Jack</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;jack&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="4-使用细节"><a href="#4-使用细节" class="headerlink" title="(4) 使用细节"></a>(4) 使用细节</h4><ul><li><h4 id="在创建用户的时候，如果不指定-host，则为-，-表示所有-ip都有连接的权限。"><a href="#在创建用户的时候，如果不指定-host，则为-，-表示所有-ip都有连接的权限。" class="headerlink" title="在创建用户的时候，如果不指定 host，则为% ，%表示所有 ip都有连接的权限。"></a>在创建用户的时候，如果不指定 host，则为% ，%表示所有 ip都有连接的权限。</h4></li><li><h4 id="创建用户的语句中-create-user-‘xxx‘-’192-168-1-’-表示该用户-可以在-192-168-1-的ip可以的登陆。"><a href="#创建用户的语句中-create-user-‘xxx‘-’192-168-1-’-表示该用户-可以在-192-168-1-的ip可以的登陆。" class="headerlink" title="创建用户的语句中 create user ‘xxx‘@’192.168.1.%’ 表示该用户 可以在 192.168.1.* 的ip可以的登陆。"></a>创建用户的语句中 create user ‘xxx‘@’192.168.1.%’ 表示该用户 可以在 192.168.1.* 的ip可以的登陆。</h4></li><li><h4 id="删除用户时，如果-host-不是-，则需要明确信息-‘用户‘-’host值’"><a href="#删除用户时，如果-host-不是-，则需要明确信息-‘用户‘-’host值’" class="headerlink" title="删除用户时，如果 host 不是 %，则需要明确信息 ‘用户‘@’host值’"></a>删除用户时，如果 host 不是 %，则需要明确信息 ‘用户‘@’host值’</h4></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、mysql-基本启动命令&quot;&gt;&lt;a href=&quot;#一、mysql-基本启动命令&quot; class=&quot;headerlink&quot; title=&quot;一、mysql 基本启动命令&quot;&gt;&lt;/a&gt;一、mysql 基本启动命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1-mysql-</summary>
      
    
    
    
    
    <category term="-Mysql -复习" scheme="http://example.com/tags/Mysql-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://example.com/2021/09/21/%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2021/09/21/%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.625Z</updated>
    
    
    
    
    
    <category term="-Java -复习" scheme="http://example.com/tags/Java-%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据库学习</title>
    <link href="http://example.com/2021/09/21/Redis%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/09/21/Redis%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-09-14T13:06:37.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、NoSQL介绍"><a href="#一、NoSQL介绍" class="headerlink" title="一、NoSQL介绍"></a>一、NoSQL介绍</h1><h3 id="1-为什么会出现nosql技术"><a href="#1-为什么会出现nosql技术" class="headerlink" title="1. 为什么会出现nosql技术"></a>1. 为什么会出现nosql技术</h3><p>在传统的网络时代中，用户的访问量 随着时代的发展 越来越大，对 <strong>CPU、内存、IO</strong> 的压力 越来越大。 这时，NOSQL技术就可以大大的缓解了这些压力。比如， <strong>可以把 存储用户信息的session，放到NoSQL中。 或是 把一些常用的 简单的数据查询 放到 NOSQL中，可以缓解IO压力 等等。</strong> </p><h3 id="2-NoSQL介绍"><a href="#2-NoSQL介绍" class="headerlink" title="2. NoSQL介绍"></a>2. NoSQL介绍</h3><ul><li><p>NoSQL 意为 Not Only SQL  不仅仅是 SQL。 指的是 <strong>非关系型数据库。</strong> NoSQL 是 <strong>不依赖义务逻辑存储的</strong>  而是以 <strong>key - value</strong> 的模式存储。</p></li><li><p><strong>特点：</strong></p><p>不遵循SQL标准、不支持ACID（原子性、一致性、永久性、隔离性）、远超SQL的性能。</p></li><li><p><strong>存储数据库类型：</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E8%A1%8C%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93.png"></p></li></ul><h1 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h1><h3 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a><strong>1. 前提</strong></h3><p>由于Redis 只支持Linux操作系统。 所以本次学习系统环境是：CentOS7 。</p><h3 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2. 安装步骤"></a>2. 安装步骤</h3><ul><li><p><strong>1) 安装C语言 编译环境（centos yml ， ubuntu apt-get）</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E5%AE%89%E8%A3%85C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure><p><strong>可通过 gcc –version 来检验是否完成安装。</strong> </p></li><li><p><strong>2）去官网下载Redis。并把下载好的压缩文件 放到 &#x2F;opt目录 。 然后解压</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E8%A7%A3%E5%8E%8Bredis%E5%8E%8B%E7%BC%A9%E5%8C%85.png"></p><p><code>tar -zxvf redis-6.2.1.tar.gz</code> </p></li><li><p><strong>3）在 redis-6.2.1 文件下 进行 编译并安装。安装目录：&#x2F;usr&#x2F;local&#x2F;bin</strong></p><p><strong>先使用 make命令 进行编译。 然后 使用 make install 命令进行 安装。</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/redis%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D.png"></p></li><li></li></ul><h3 id="3-配置后台启动"><a href="#3-配置后台启动" class="headerlink" title="3. 配置后台启动"></a>3. 配置后台启动</h3><ul><li><p><strong>1）复制一份 redis.conf 到 &#x2F;etc 目录下。</strong></p></li><li><p><strong>2）对&#x2F;etc&#x2F;redis.conf 文件 进行设置 。 把 daemonize no 改成 yes</strong></p></li><li><h3 id="3）启动："><a href="#3）启动：" class="headerlink" title="3）启动："></a><strong>3）启动：</strong></h3><p><strong>开启服务：redis-server &#x2F;etc&#x2F;redis.conf</strong></p><p><strong>查看是否开启服务：</strong> <strong>ps -ef | grep redis</strong></p><p><strong>进入 redis 客户端 使用 redis：</strong> <strong>redis-cli</strong> </p></li><li><h3 id="4）-关闭redis"><a href="#4）-关闭redis" class="headerlink" title="4） 关闭redis"></a>4） 关闭redis</h3><p><strong>可通过 exit、 ctrl+c 退出 redis客户端、使用 shutdown 退出服务。</strong></p></li></ul><h3 id="4-Redis相关知识介绍"><a href="#4-Redis相关知识介绍" class="headerlink" title="4. Redis相关知识介绍"></a>4. Redis相关知识介绍</h3><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.png"></p><ul><li><p>redis 是 <strong>单线程+多路复用 技术。</strong> </p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E5%8D%95%E7%BA%BF%E7%A8%8B+%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90.png"></p></li></ul><h1 id="三、常用五大数据类型"><a href="#三、常用五大数据类型" class="headerlink" title="三、常用五大数据类型"></a>三、常用五大数据类型</h1><h3 id="1-redis健（key）"><a href="#1-redis健（key）" class="headerlink" title="1. redis健（key）"></a>1. redis健（key）</h3><ul><li><p><strong>常用命令：</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/key%E5%91%BD%E4%BB%A401.png"></p></li><li><p>![</p></li></ul><h3 id="2-字符串类型（String）"><a href="#2-字符串类型（String）" class="headerlink" title="2. 字符串类型（String）"></a>2. 字符串类型（String）</h3><ul><li><p><strong>基本介绍：</strong></p><p>String 类型 是 <strong>二进制安全的 即Redis的String类型 可以包含任何数据。比如 jpg图片、序列化对象。</strong> </p><p>一个Redis中 字符串的 value <strong>最多可以是 512M.</strong></p></li><li><p><strong>常用命令：</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/string%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A401.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/string%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A401.png" alt="string类型命令01"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/string%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A402.png" alt="string类型命令02"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/string%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A403.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/String%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A404.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/string%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A405.png"></p></li><li><p><strong>数据结构：</strong></p><p><strong>String类型 持有 原子性 的数据结构：</strong> 即 <strong>这种操作 一旦执行 ，就不会被 其它线程打断。</strong></p><p>String类型的是 <strong>简单动态字符串</strong> 是可以修改的 字符串。内部结构 <strong>类似于Java的ArrayList。</strong> 采用 <strong>预分配冗余空间 减少内存的频繁分配（即 会在长度16中， 到了 13 就会扩容）。</strong> </p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/String%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p></li></ul><h3 id="3-Redis列表（List）"><a href="#3-Redis列表（List）" class="headerlink" title="3. Redis列表（List）"></a>3. Redis列表（List）</h3><ul><li><p><strong>1）基本了解：</strong> redis列表是简单的字符串列表。它的底层 实际上是一个 <strong>双向链表</strong> ，对两端的操作性能很高， 通过索引操作中间的节点性能会较差。</p></li><li><p><strong>2）常用命令：</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/list%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/list%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A402.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/list%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A403.png"></p></li><li><p><strong>3）数据结构：</strong></p><p>List的数据结构 是 <strong>快速链表quickList</strong> 。 在 <strong>列表元素较少时，会使用一块连续的内存存储 ziplist</strong> 。当 <strong>数据量变多时，就会将 各个的 ziplist 连接起来。组成 quicklist</strong> </p><p> <img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/list%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84quicklist.png"></p></li></ul><h3 id="4-Redis集合（Set）"><a href="#4-Redis集合（Set）" class="headerlink" title="4. Redis集合（Set）"></a>4. Redis集合（Set）</h3><ul><li><p><strong>1) 基本介绍：</strong> set集合 与 list列表 的功能是基本一致的。 主要的区别在于 <strong>set 可以 自动排重（即自动排除重复元素）。且 set集合 可以判断 某个 元素是否在set集合中 的 功能。</strong> set 是 <strong>string类型的  无序集合，底层是 value 为 null 的 hash表。</strong> 所以 添加、删除、查找 的 时间复杂度都为 O（1）。</p></li><li><p><strong>2) 常用命令：</strong></p></li></ul><p>  <img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/set%E9%9B%86%E5%90%88%E5%91%BD%E4%BB%A401.png"></p><p>  <img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/set%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A402.png"></p><ul><li><strong>3) 数据结构：</strong> <strong>Redis 的 set 结构 内部 使用了 hash结构，所有的value 指向 同一个内部值。</strong></li></ul><h3 id="5-哈希类型（Hash）"><a href="#5-哈希类型（Hash）" class="headerlink" title="5. 哈希类型（Hash）"></a>5. 哈希类型（Hash）</h3><ul><li><p><strong>1）基本介绍：</strong> hash 是一个 <strong>键值对集合</strong>, 是一个 <strong>string类型的 field value</strong> 的映射表，类似于Java的 map。 通常可以用来存储对象类型的数据。</p></li><li><p><strong>2) 常用命令：</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/hash%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png"></p></li><li><p><strong>3) 数据结构：</strong> 当数据量少的时候用 ziplist， 当数据量多的时候 则会把 每一个 zipList 合成一个 hashTable。</p></li></ul><h3 id="6-有序集合Zset"><a href="#6-有序集合Zset" class="headerlink" title="6.  有序集合Zset"></a>6.  有序集合Zset</h3><ul><li><p><strong>1）基本介绍：</strong> zset 和 set 集合是十分类似的，是一个 <strong>没有重复元素</strong> 的 字符串集合。 不同之处在于 zset <strong>会给每一个成员关联一个评分。这个评分用来作为排序的顺序。</strong> 其中 <strong>集合中 元素是唯一的，而 评分是可以重复的。</strong> </p></li><li><p><strong>2）常用命令：</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/zset%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A401.png"></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/zset%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A402.png"></p></li><li><p><strong>3）数据结构：</strong> zset 的数据结构 等价于 Java的 Map&lt;String, Double&gt; 类型，可以给 每一个元素 赋值权重。 <strong>另一方面，</strong> 它 <strong>又类似于 TreeSet</strong> 内部的元素 会根据权重来进行排序。 <strong>zset 有两种数据结构，分别是 hash 与 跳跃表。</strong> <strong>hash 的作用是 关联元素的 value 与 权重score</strong> 。 <strong>而 跳跃表 则是更快速高效的 根据权重进行排序。</strong> </p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E8%B7%B3%E8%B7%83%E8%A1%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p></li></ul><h1 id="四、redis配置文件详解"><a href="#四、redis配置文件详解" class="headerlink" title="四、redis配置文件详解"></a>四、redis配置文件详解</h1><h3 id="1-Units单位"><a href="#1-Units单位" class="headerlink" title="1. Units单位"></a>1. Units单位</h3><p>配置大小的单位，开头定义了基本的度量单位，<strong>只支持bytes, 不支持bit。 大小写不敏感</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/units%E5%8D%95%E4%BD%8D.png"></p><h3 id="2-includes配置"><a href="#2-includes配置" class="headerlink" title="2. includes配置"></a>2. includes配置</h3><p>主要进行对 <strong>其它配置文件的包含作用</strong> </p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/includes%E9%85%8D%E7%BD%AE.png"></p><h3 id="3-网络配置"><a href="#3-网络配置" class="headerlink" title="3. 网络配置"></a>3. 网络配置</h3><ul><li><p><strong>可以调整redis可以接受远程访问</strong></p><ul><li><p>第一步： 把bind注释掉，不然默认只接受本地访问</p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/bind%E6%B3%A8%E9%87%8A.png"></p></li><li><p>第二步：把 protected-mode 设置为 no</p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/protected-mode%E8%AE%BE%E7%BD%AE.png"></p></li></ul></li><li><p><strong>可以设置端口号</strong></p><p><img src="/../../blog/images/Redis%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7.png"></p></li><li><p><strong>设置tcp-blocklog</strong></p><p>tcp-blocklog 是指 <strong>tcp的连接队列。即 &#x3D;&#x3D; 未完成三次握手+已经完成三次握手队列。</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/tcpblacklog%E6%B3%A8%E6%84%8F.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/tcpbloack.png"></p></li><li><p><strong>timeout设置</strong></p><p>timeout的作用： 当连接redis后，一定时间没有操作，则断开连接。默认为0，即永不超时。（以秒为单位）</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/timeout.png"></p></li><li><p><strong>tcp-keepalive设置</strong></p><p>作用：当通过tcp连接redis后，一定时间没有操作，则断开连接。（以秒为单位）</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/tcp-keepalive.png"></p></li></ul><h3 id="4-通用配置"><a href="#4-通用配置" class="headerlink" title="4.通用配置"></a>4.通用配置</h3><ul><li><p><strong>pidfile设置</strong></p><p>作用：存放pid的位置（即进程号），每一个实例，就有一个pid文件</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/pidfile.png"></p></li><li><p><strong>loglevel设置</strong></p><p>作用：设置日志的级别</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/loglevel.png"></p></li><li><p><strong>logfile设置</strong></p><p>作用：设置日志文件存放的位置</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/logfile.png"></p></li><li><p><strong>database 设置</strong></p><p>作用：设置库的默认数量 默认是16</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/database.png"></p></li></ul><h3 id="5-security安全配置"><a href="#5-security安全配置" class="headerlink" title="5. security安全配置"></a>5. security安全配置</h3><ul><li><p><strong>设置密码登录，有两种模式，第一种是配置文件设置，第二种是命令行设置。</strong></p><ul><li><p>配置文件设置：</p><ul><li><p>打开requirepass foobared（密码）注释 </p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%8101.png"></p></li></ul></li><li><p>命令行设置</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81.png"></p></li></ul></li></ul><h3 id="6-Limit配置"><a href="#6-Limit配置" class="headerlink" title="6. Limit配置"></a>6. Limit配置</h3><ul><li><p><strong>maxclients设置</strong></p><p>作用：设置redis 最多可以被多少个客户端进行连接，默认是10000个客户端。如果超过设置数量，则会发出 “max number of clients reached”的回应，拒绝连接。</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/maxclients%E8%AE%BE%E7%BD%AE.png"></p></li><li><p><strong>maxmemory设置</strong></p><p>作用：<strong>建议必须设置的配置，否则，会将内存占满，造成服务器宕机。</strong></p><p>设置redis可以使用的内存量，如果超出上限，redis会试图移除内部数据，移除规则由 <strong>maxmemory-policy</strong> 设置。</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/maxmemory.png"></p></li><li><p><strong>maxmemory-policy设置</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/maxmemory-policy%E8%A7%84%E5%88%99.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/maxmemory-policy.png"></p></li><li><p><strong>maxmemory-samples设置</strong></p><p>作用：设置样本数量，LRU算法 和 TTL算法 并非准确的算法，而是估算值，所以可以设置一个样本的大小，redis会默认检查 这么多个 key并选择其中LRU的那个。 一般设置 3-7个，数值越小也不准确，当然性能消耗就越小。</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/maxmemroy-simple.png"></p></li></ul><h1 id="五、redis的发布与订阅"><a href="#五、redis的发布与订阅" class="headerlink" title="五、redis的发布与订阅"></a>五、redis的发布与订阅</h1><h3 id="1-什么是发布和订阅"><a href="#1-什么是发布和订阅" class="headerlink" title="1. 什么是发布和订阅"></a>1. 什么是发布和订阅</h3><p>Redis中的 发布与订阅 是 一种消息通信模式。发布即发送信息，订阅则是接收信息。 其中，redis客户端可以订阅 <strong>任意数量的频道。</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><h3 id="2-如何实现发布与订阅"><a href="#2-如何实现发布与订阅" class="headerlink" title="2. 如何实现发布与订阅"></a>2. 如何实现发布与订阅</h3><ul><li><p>打开一个客户端去订阅频道</p><p><code>subscrbe channel01</code></p></li><li><p>打开另一个客户端去发布信息</p><p><code>publish channel01 hello</code></p></li></ul><h1 id="六、Redis新数据类型"><a href="#六、Redis新数据类型" class="headerlink" title="六、Redis新数据类型"></a>六、Redis新数据类型</h1><h3 id="1-Bitmaps类型"><a href="#1-Bitmaps类型" class="headerlink" title="1. Bitmaps类型"></a>1. Bitmaps类型</h3><ul><li><p><strong>含义：</strong> bitmaps类型 可以合理的操作 二进制的位，通过操作位来有效地提高内存使用率和开发效率。在redis中，可以把bitmaps想象成，以位为单位的数组，数组的每一个单元都只能存储0或1，而数组的下标就叫做偏移量。</p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/bitmaps%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p><strong>使用命令：</strong></p><ul><li><p><strong>setbit命令：</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/setbit.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/setbit%E4%BD%BF%E7%94%A8.png"></p><p><strong>在第一次初始化bitmaps时，加入偏移量非常大，那么整个初始化过程就会比较慢，可能会造成redis阻塞。</strong></p></li><li><p><strong>getbit命令：</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/getbit.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/getbit%E4%BD%BF%E7%94%A8.png"></p></li><li><p><strong>bitcount命令：</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/bitcount.png"></p><p><strong>注意：bitcount统计1的数量 是以字节为单位的。</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/bitcount%E6%B3%A8%E6%84%8F.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/bitcount%E4%BD%BF%E7%94%A8.png"></p></li><li><p><strong>bitop and (or&#x2F;not&#x2F;xor)命令：</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/bitop%E5%91%BD%E4%BB%A4.png"></p></li><li><p><img src="/Redis%E5%AD%A6%E4%B9%A0/bitop%E4%BD%BF%E7%94%A8.png"></p><p><strong>注意：这个user091114是自定义创建的key</strong></p></li></ul></li><li><p><strong>适用范围：</strong> bitmaps适用于 类似 活跃用户这种类型的，适合频繁活动的数据，如存储一天的活跃用户。</p></li></ul><h3 id="2-HyperLogLog类型"><a href="#2-HyperLogLog类型" class="headerlink" title="2. HyperLogLog类型"></a>2. HyperLogLog类型</h3><ul><li><p><strong>简介：</strong> 主要用于解决 <strong>基数问题</strong> 。 基数问题 即 获取集合中 不重复个数的问题。 </p></li><li><p><strong>使用命令：</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/hyperloglog%E5%91%BD%E4%BB%A401.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/hyperloglog%E5%91%BD%E4%BB%A402.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/hyperloglog%E5%91%BD%E4%BB%A403.png"></p></li></ul><h3 id="3-Geospatial类型"><a href="#3-Geospatial类型" class="headerlink" title="3. Geospatial类型"></a>3. Geospatial类型</h3><ul><li><p><strong>简介：</strong> geospatial类型主要对GEO（地理信息）数据的支持。该元素主要是存储 经纬度的值。</p></li><li><p><strong>常用命令：</strong></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/geospatial%E5%91%BD%E4%BB%A401.png"></p><p><strong>注意： 两极的经纬度不能添加。有效经度为180°到-180°，有效的纬度为85.05112878°到 -85.06112878°</strong> </p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/geospatial%E5%91%BD%E4%BB%A402.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/geospatial%E5%91%BD%E4%BB%A403.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/geospatial%E5%8D%95%E4%BD%8D.png"></p><p><img src="/Redis%E5%AD%A6%E4%B9%A0/geospatial%E5%91%BD%E4%BB%A404.png"></p></li></ul><h1 id="七、Jedis工具"><a href="#七、Jedis工具" class="headerlink" title="七、Jedis工具"></a>七、Jedis工具</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Jedis工具 主要是用于 使用Java来操作Reids的一种工具。里面提供了许多redis的操作api。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ul><li><p><strong>maven引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对redis的conf文件配置</strong></p><ul><li>注释掉 bind 127.0.0.1</li><li>把protected-mode 设置为 no</li></ul></li><li><p><strong>关闭防火墙</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(centos版本)</span><br><span class="line">//查看防火墙</span><br><span class="line">systemctl status firewall</span><br><span class="line"></span><br><span class="line">//删除防火墙</span><br><span class="line">systemctl stop firewall</span><br><span class="line"></span><br><span class="line">（ubuntu版本）</span><br><span class="line">//查看防火墙</span><br><span class="line">service iptables status</span><br><span class="line">//关闭</span><br><span class="line">service iptables stop</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>最后，重启一下redis服务</strong></p></li></ul><h3 id="3-案例（手机验证码）"><a href="#3-案例（手机验证码）" class="headerlink" title="3. 案例（手机验证码）"></a>3. 案例（手机验证码）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规则 每个手机号每天只能获取三次验证码 每次验证码的有效期为2分钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机的验证码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>);</span><br><span class="line">            code+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//保存验证码到redis</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveCodeRedis</span><span class="params">(String telephone,String code)</span>&#123;</span><br><span class="line">        <span class="comment">//每天该手机号生成次数前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">codeCount</span> <span class="operator">=</span> telephone+<span class="string">&quot;count:&quot;</span>;</span><br><span class="line">        <span class="comment">//该手机号的验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">telephoneCode</span> <span class="operator">=</span> telephone+<span class="string">&quot;code:&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先获取该手机号今天已经获取的验证码次数</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.232.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">codeCount1</span> <span class="operator">=</span> jedis.get(codeCount);</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentCount</span> <span class="operator">=</span> codeCount1==<span class="literal">null</span>?<span class="number">0</span>:Integer.parseInt(codeCount1);</span><br><span class="line">        System.out.println(currentCount);</span><br><span class="line">        <span class="keyword">if</span>(currentCount==<span class="number">0</span>)&#123;</span><br><span class="line">            jedis.set(codeCount,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="comment">// 该号码是今天第一次获取验证码 则给redis添加key</span></span><br><span class="line">            jedis.expire(codeCount,<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currentCount&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">// 不是第一次获取 则给该key+1</span></span><br><span class="line">            jedis.incr(codeCount);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//今天已经获取了三次了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;今天已经获取了3次验证码，请明天再来！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储验证码</span></span><br><span class="line">        jedis.set(telephoneCode,code);</span><br><span class="line">        jedis.expire(telephoneCode,<span class="number">2</span>*<span class="number">60</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//验证验证码是否正确</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">verifyCode</span><span class="params">(String telephone,String code)</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.232.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">telephoneCode</span> <span class="operator">=</span> telephone+<span class="string">&quot;code:&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisCode</span> <span class="operator">=</span> jedis.get(telephoneCode);</span><br><span class="line">        <span class="keyword">if</span>(code.equals(redisCode))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;验证正确&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;验证失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       saveCodeRedis(<span class="string">&quot;15218423290&quot;</span>,getCode());</span><br><span class="line"><span class="comment">//        verifyCode(&quot;15218423290&quot;,&quot;86426&quot;);</span></span><br><span class="line">  </span><br><span class="line">     </span><br></pre></td></tr></table></figure><h1 id="八、SpringBoot整合Redis"><a href="#八、SpringBoot整合Redis" class="headerlink" title="八、SpringBoot整合Redis"></a>八、SpringBoot整合Redis</h1><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-在application-properties编写配置"><a href="#2-在application-properties编写配置" class="headerlink" title="2. 在application.properties编写配置"></a>2. 在application.properties编写配置</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、NoSQL介绍&quot;&gt;&lt;a href=&quot;#一、NoSQL介绍&quot; class=&quot;headerlink&quot; title=&quot;一、NoSQL介绍&quot;&gt;&lt;/a&gt;一、NoSQL介绍&lt;/h1&gt;&lt;h3 id=&quot;1-为什么会出现nosql技术&quot;&gt;&lt;a href=&quot;#1-为什么会出现no</summary>
      
    
    
    
    
    <category term="-redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>AntDesignProVue的使用</title>
    <link href="http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/AntDesignOfVue%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/AntDesignOfVue%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、脚手架安装与介绍"><a href="#一、脚手架安装与介绍" class="headerlink" title="一、脚手架安装与介绍"></a>一、脚手架安装与介绍</h1><h3 id="1-安装脚手架"><a href="#1-安装脚手架" class="headerlink" title="1. 安装脚手架"></a>1. 安装脚手架</h3><ul><li><p><strong>1) 可在vscode中 打开 文件夹的cmd命令窗口中运行</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/vueComponent/ant-design-vue-pro.git</span><br></pre></td></tr></table></figure></li><li><p><strong>2) 下载依赖</strong></p><p><strong>注意：这里记得 先打开 clone下来的 antDesignProVue 的文件夹的终端窗口 再下载依赖</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p><strong>3) 启动项目</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>![](&#x2F;Ant Design Pro Of Vue的使用&#x2F;项目成功启动.png)</p></li></ul><h3 id="2-目录介绍"><a href="#2-目录介绍" class="headerlink" title="2. 目录介绍"></a>2. 目录介绍</h3><ul><li><p><strong>整体目录了解：</strong></p><p>![](&#x2F;Ant Design Pro Of Vue的使用&#x2F;整体目录了解.png)</p></li><li><p><strong>主要目录分析：</strong></p><p>![](&#x2F;Ant Design Pro Of Vue的使用&#x2F;主要文件目录了解.png)</p></li></ul><h1 id="二、对脚手架进行个性化修改"><a href="#二、对脚手架进行个性化修改" class="headerlink" title="二、对脚手架进行个性化修改"></a>二、对脚手架进行个性化修改</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、脚手架安装与介绍&quot;&gt;&lt;a href=&quot;#一、脚手架安装与介绍&quot; class=&quot;headerlink&quot; title=&quot;一、脚手架安装与介绍&quot;&gt;&lt;/a&gt;一、脚手架安装与介绍&lt;/h1&gt;&lt;h3 id=&quot;1-安装脚手架&quot;&gt;&lt;a href=&quot;#1-安装脚手架&quot; class</summary>
      
    
    
    
    
    <category term="-Vue -前端组件使用" scheme="http://example.com/tags/Vue-%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/springBoot+swaggerUI%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/springBoot+swaggerUI%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、引入依赖"><a href="#一、引入依赖" class="headerlink" title="一、引入依赖"></a>一、引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger 用来测试方法是否有效 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、在application-properties中-配置属性"><a href="#二、在application-properties中-配置属性" class="headerlink" title="二、在application.properties中 配置属性"></a>二、在application.properties中 配置属性</h3><p><img src="/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/swaggerUI+springBoot/%E9%85%8D%E7%BD%AE.png"></p><p>​如果不配置该属性，则会在进行swaggerUI测试时，直接报错。</p><h3 id="三、编写-swaggerUI-配置类-固定"><a href="#三、编写-swaggerUI-配置类-固定" class="headerlink" title="三、编写 swaggerUI 配置类(固定)"></a>三、编写 swaggerUI 配置类(固定)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启swaggerUI</span></span><br><span class="line"><span class="comment">// swaggerUi 网页地址：localhost:8080/swagger-ui.html</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/admin/.*&quot;</span>)))</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信息的描述</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;学生管理系统API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了学生管理系统定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;http://jack.com&quot;</span>, <span class="string">&quot;1654074213@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、主要注解使用"><a href="#四、主要注解使用" class="headerlink" title="四、主要注解使用"></a>四、主要注解使用</h3><ul><li><h4 id="1-ApiModel（Value-description-””）-注解-主要用于标注-实体类。便于使用"><a href="#1-ApiModel（Value-description-””）-注解-主要用于标注-实体类。便于使用" class="headerlink" title="1. @ApiModel（Value&#x3D; , description&#x3D;””） 注解 : 主要用于标注 实体类。便于使用"></a>1. @ApiModel（Value&#x3D; , description&#x3D;””） 注解 : 主要用于标注 实体类。便于使用</h4><ul><li><h4 id="value-填写该类的名字"><a href="#value-填写该类的名字" class="headerlink" title="value: 填写该类的名字"></a>value: 填写该类的名字</h4></li><li><h4 id="description-填写该类的描述"><a href="#description-填写该类的描述" class="headerlink" title="description: 填写该类的描述"></a>description: 填写该类的描述</h4></li><li><h5 id="ApiModel-value-Student对象-description-学生"><a href="#ApiModel-value-Student对象-description-学生" class="headerlink" title="@ApiModel(value = &quot;Student对象&quot;,description = &quot;学生&quot;)"></a><code>@ApiModel(value = &quot;Student对象&quot;,description = &quot;学生&quot;)</code></h5></li></ul></li><li><h4 id="2-ApiModelProperty-value-“”-用于-使用了-ApiModel中的实体类，标注实体类的属性"><a href="#2-ApiModelProperty-value-“”-用于-使用了-ApiModel中的实体类，标注实体类的属性" class="headerlink" title="2. @ApiModelProperty(value &#x3D; “”) : 用于 使用了@ApiModel中的实体类，标注实体类的属性"></a>2. @ApiModelProperty(value &#x3D; “”) : 用于 使用了@ApiModel中的实体类，标注实体类的属性</h4><ul><li><h4 id="value-填写该属性的说明"><a href="#value-填写该属性的说明" class="headerlink" title="value: 填写该属性的说明"></a>value: 填写该属性的说明</h4></li><li><h5 id="ApiModelProperty-value-学生ID"><a href="#ApiModelProperty-value-学生ID" class="headerlink" title="@ApiModelProperty(value = &quot;学生ID&quot;)"></a><code>@ApiModelProperty(value = &quot;学生ID&quot;)</code></h5></li></ul></li><li><h4 id="3-ApiOperation-value-“”-用于标注在Controller类中的-各种方法"><a href="#3-ApiOperation-value-“”-用于标注在Controller类中的-各种方法" class="headerlink" title="3. @ApiOperation(value &#x3D; “”): 用于标注在Controller类中的 各种方法"></a>3. @ApiOperation(value &#x3D; “”): 用于标注在Controller类中的 各种方法</h4><ul><li><h4 id="value：该方法的-用途说明"><a href="#value：该方法的-用途说明" class="headerlink" title="value：该方法的 用途说明"></a>value：该方法的 用途说明</h4></li><li><h4 id="ApiOperation-value-添加学生"><a href="#ApiOperation-value-添加学生" class="headerlink" title="@ApiOperation(value = &quot;添加学生&quot;)"></a><code>@ApiOperation(value = &quot;添加学生&quot;)</code></h4></li></ul></li><li><h4 id="4-ApiParam-name-“”-value-“”-required-用于-标注方法中需要传入的参数说明"><a href="#4-ApiParam-name-“”-value-“”-required-用于-标注方法中需要传入的参数说明" class="headerlink" title="4. @ApiParam(name &#x3D; “”,value &#x3D; “”,required &#x3D; ):  用于 标注方法中需要传入的参数说明"></a>4. @ApiParam(name &#x3D; “”,value &#x3D; “”,required &#x3D; ):  用于 标注方法中需要传入的参数说明</h4><ul><li><h4 id="name-需要传参的-属性名"><a href="#name-需要传参的-属性名" class="headerlink" title="name:  需要传参的 属性名"></a>name:  需要传参的 属性名</h4></li><li><h4 id="value-对输入参数的具体描述"><a href="#value-对输入参数的具体描述" class="headerlink" title="value:  对输入参数的具体描述"></a>value:  对输入参数的具体描述</h4></li><li><h4 id="Required-该参数是否-必须传入"><a href="#Required-该参数是否-必须传入" class="headerlink" title="Required: 该参数是否 必须传入"></a>Required: 该参数是否 必须传入</h4></li><li><h4 id="ApiParam-name-Student-value-学生信息-required-true"><a href="#ApiParam-name-Student-value-学生信息-required-true" class="headerlink" title="@ApiParam(name = &quot;Student&quot;,value = &quot;学生信息&quot;,required = true)"></a><code>@ApiParam(name = &quot;Student&quot;,value = &quot;学生信息&quot;,required = true)</code></h4></li></ul></li><li><h4 id="5-Api-description-“”-：用于标注-Controller类，识别Controller"><a href="#5-Api-description-“”-：用于标注-Controller类，识别Controller" class="headerlink" title="5. @Api(description &#x3D; “”)：用于标注 Controller类，识别Controller"></a>5. @Api(description &#x3D; “”)：用于标注 Controller类，识别Controller</h4><ul><li><h4 id="description-填写Controller-的描述"><a href="#description-填写Controller-的描述" class="headerlink" title="description:  填写Controller 的描述"></a>description:  填写Controller 的描述</h4></li><li><h4 id="Api-description-学生管理"><a href="#Api-description-学生管理" class="headerlink" title="@Api(description = &quot;学生管理&quot;)"></a><code>@Api(description = &quot;学生管理&quot;)</code></h4></li></ul></li></ul><h3 id="五、在启动类上加上注解-EnableSwagger2"><a href="#五、在启动类上加上注解-EnableSwagger2" class="headerlink" title="五、在启动类上加上注解 @EnableSwagger2"></a>五、在启动类上加上注解 @EnableSwagger2</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、引入依赖&quot;&gt;&lt;a href=&quot;#一、引入依赖&quot; class=&quot;headerlink&quot; title=&quot;一、引入依赖&quot;&gt;&lt;/a&gt;一、引入依赖&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;</summary>
      
    
    
    
    
    <category term="-Java -框架" scheme="http://example.com/tags/Java-%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>springBoot+Vue+Nginx 前后端分离</title>
    <link href="http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/springboor+vue+nginx%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/springboor+vue+nginx%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本篇文章-仅作于如何搭建-前后端分离步骤"><a href="#本篇文章-仅作于如何搭建-前后端分离步骤" class="headerlink" title="本篇文章 仅作于如何搭建 前后端分离步骤"></a>本篇文章 仅作于如何搭建 前后端分离步骤</h1><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><ul><li><h4 id="搭建好基本的springBoot项目、Vue项目（具体看-另两篇文章-：SpringBoot-整合-Mybatis-plus-新建Vue项目）"><a href="#搭建好基本的springBoot项目、Vue项目（具体看-另两篇文章-：SpringBoot-整合-Mybatis-plus-新建Vue项目）" class="headerlink" title="搭建好基本的springBoot项目、Vue项目（具体看 另两篇文章 ：SpringBoot 整合 Mybatis-plus &amp;&amp; 新建Vue项目）"></a>搭建好基本的springBoot项目、Vue项目（具体看 另两篇文章 ：<em>SpringBoot 整合 Mybatis-plus</em> &amp;&amp; <em>新建Vue项目</em>）</h4></li><li><h4 id="下载-nginx。"><a href="#下载-nginx。" class="headerlink" title="下载 nginx。"></a>下载 nginx。</h4></li></ul><h4 id="二、编写后端"><a href="#二、编写后端" class="headerlink" title="二、编写后端"></a>二、编写后端</h4><ul><li><h4 id="1-在appcation-properties-配置端口号"><a href="#1-在appcation-properties-配置端口号" class="headerlink" title="1. 在appcation.properties  配置端口号"></a>1. 在appcation.properties  配置端口号</h4><p><img src="/%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7.png"></p></li><li><h4 id="2-编写简单的-Controller"><a href="#2-编写简单的-Controller" class="headerlink" title="2. 编写简单的 Controller"></a>2. 编写简单的 Controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/20 8:40</span></span><br><span class="line"><span class="comment"> * 编写简单的 controller 测试后端返回数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/exam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,this is springBoot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="3-在-swagger-ui进行功能测试"><a href="#3-在-swagger-ui进行功能测试" class="headerlink" title="3. 在 swagger-ui进行功能测试"></a>3. 在 swagger-ui进行功能测试</h4><p><img src="/%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F.png"></p></li></ul><h3 id="三、配置-nginx"><a href="#三、配置-nginx" class="headerlink" title="三、配置 nginx"></a>三、配置 nginx</h3><ul><li><h4 id="1-在nginx的目录下，conf-nginx-conf-中配置"><a href="#1-在nginx的目录下，conf-nginx-conf-中配置" class="headerlink" title="1. 在nginx的目录下，conf&#x2F;nginx.conf 中配置"></a>1. 在nginx的目录下，conf&#x2F;nginx.conf 中配置</h4><p>在 http中 新建server字段 具体如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">#试验前后端分离</span><br><span class="line">server&#123;  #一个server 代表一个项目管理的 nginx</span><br><span class="line">listen 9003; #nginx 端口号</span><br><span class="line">server_name localhost; #本地</span><br><span class="line"></span><br><span class="line">#配置代理 管理 前端 </span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://localhost:8080; #前端接口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#配置代理 管理 后端</span><br><span class="line">location ~ /exam/ &#123;</span><br><span class="line">proxy_pass http://localhost:8081; #8081 是后端的端口号</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="2-开启-nginx"><a href="#2-开启-nginx" class="headerlink" title="2. 开启 nginx"></a>2. 开启 nginx</h4><ul><li><p>nginx 常用命令</p><p><img src="/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png"></p></li><li><h5 id="开启nginx：在nginx的-目录中，上方的路径中输入cmd-打开shell。-输入命令即可"><a href="#开启nginx：在nginx的-目录中，上方的路径中输入cmd-打开shell。-输入命令即可" class="headerlink" title="开启nginx：在nginx的  目录中，上方的路径中输入cmd 打开shell。 输入命令即可"></a>开启nginx：在nginx的  目录中，上方的路径中输入cmd 打开shell。 输入命令即可</h5></li></ul></li></ul><h3 id="四、编写前端"><a href="#四、编写前端" class="headerlink" title="四、编写前端"></a>四、编写前端</h3><ul><li><h4 id="1-下载-axios-依赖"><a href="#1-下载-axios-依赖" class="headerlink" title="1.  下载 axios 依赖"></a>1.  下载 axios 依赖</h4><h5 id="通过命令-cnpm-install-axios-s-下载依赖"><a href="#通过命令-cnpm-install-axios-s-下载依赖" class="headerlink" title="通过命令 cnpm install axios -s 下载依赖"></a>通过命令 cnpm install axios -s 下载依赖</h5><p>下载完成后，可在 package.json 中的 dependencies 中查看是否下载成功</p><p><img src="/axios%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p></li><li><h4 id="2-编辑-dev-env-js-文件"><a href="#2-编辑-dev-env-js-文件" class="headerlink" title="2. 编辑 dev.env.js 文件"></a>2. 编辑 dev.env.js 文件</h4><p>在 config 文件夹中 编辑dev.env.js文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Descripttion: </span></span><br><span class="line"><span class="comment"> * @Author: jack</span></span><br><span class="line"><span class="comment"> * @Date: 2022-03-05 11:12:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> prodEnv = <span class="built_in">require</span>(<span class="string">&#x27;./prod.env&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(prodEnv, &#123;</span><br><span class="line">  <span class="attr">NODE_ENV</span>: <span class="string">&#x27;&quot;development&quot;&#x27;</span>,</span><br><span class="line">    <span class="comment">//主要配置端口号 改端口 就是 nginx 的的端口号</span></span><br><span class="line">  <span class="attr">BASE_API</span>: <span class="string">&#x27;&quot;http://localhost:9003&quot;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="3-新建-request-js-文件-用于创建-axios实例-以及-方便后续配置-request、response的设置"><a href="#3-新建-request-js-文件-用于创建-axios实例-以及-方便后续配置-request、response的设置" class="headerlink" title="3. 新建 request.js 文件 用于创建 axios实例 以及 方便后续配置 request、response的设置"></a>3. 新建 request.js 文件 用于创建 axios实例 以及 方便后续配置 request、response的设置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Descripttion: </span></span><br><span class="line"><span class="comment"> * @Author: jack</span></span><br><span class="line"><span class="comment"> * @Date: 2022-03-19 14:23:29</span></span><br><span class="line"><span class="comment"> * 创建 axios 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: process.<span class="property">env</span>.<span class="property">BASEURL</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response 拦截器  设置response</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//让返回的response 是直接返回response.data 这样就不需要再vue界面接受 数据时 还要 response.data.data</span></span><br><span class="line">      <span class="keyword">const</span> res = response.<span class="property">data</span> </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 这里是结合 后端返回的 R，进行显示</span></span><br><span class="line">      <span class="comment">// 20000:成功 200001：不成功</span></span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">code</span> == <span class="number">20001</span>) &#123;   <span class="comment">// 后端返回访问 不成功的 处理  既相当于 后端出现了错误 让前端无法正确的R值</span></span><br><span class="line">        <span class="title class_">Message</span>(&#123;</span><br><span class="line">          <span class="attr">message</span>: res.<span class="property">message</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">          <span class="attr">duration</span>: <span class="number">5</span> * <span class="number">1000</span> </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> response.<span class="property">data</span>  <span class="comment">//访问正确 response.data 其实就是R </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span> + error) <span class="comment">// for debug</span></span><br><span class="line">      <span class="title class_">Message</span>(&#123;</span><br><span class="line">        <span class="attr">message</span>: error.<span class="property">message</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        <span class="attr">duration</span>: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure></li><li><h4 id="4-新建-student-js-文件，-用于连接-与后端对应的-controller层的-方法。"><a href="#4-新建-student-js-文件，-用于连接-与后端对应的-controller层的-方法。" class="headerlink" title="4. 新建 student.js 文件， 用于连接 与后端对应的 controller层的 方法。"></a>4. 新建 student.js 文件， 用于连接 与后端对应的 controller层的 方法。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="title function_">exam</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">`/exam/hello`</span>,  <span class="comment">//后端方法地址</span></span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,  <span class="comment">// 请求方式</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="5-新建-exam-vue-界面"><a href="#5-新建-exam-vue-界面" class="headerlink" title="5. 新建 exam.vue 界面"></a>5. 新建 exam.vue 界面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> * @Descripttion: </span><br><span class="line"> * @Author: jack</span><br><span class="line"> * @Date: 2022-03-20 14:45:35</span><br><span class="line">--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;hello&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import student from &#x27;@/api/student&#x27;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        hello()&#123;</span><br><span class="line">            student.exam()</span><br><span class="line">            .then(response=&gt;&#123;</span><br><span class="line">                alert(response.data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;   </span><br></pre></td></tr></table></figure></li><li><h4 id="6-添加路由"><a href="#6-添加路由" class="headerlink" title="6.  添加路由"></a>6.  添加路由</h4><p><img src="/%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1.png"></p></li></ul><h3 id="五、-测试结果"><a href="#五、-测试结果" class="headerlink" title="五、 测试结果"></a>五、 测试结果</h3><p>启动vue项目,点击按钮 弹出 hello,this is springBoot 则成功实现 前后端分离</p><p><img src="/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%8C%E6%88%90.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本篇文章-仅作于如何搭建-前后端分离步骤&quot;&gt;&lt;a href=&quot;#本篇文章-仅作于如何搭建-前后端分离步骤&quot; class=&quot;headerlink&quot; title=&quot;本篇文章 仅作于如何搭建 前后端分离步骤&quot;&gt;&lt;/a&gt;本篇文章 仅作于如何搭建 前后端分离步骤&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="-框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>vue各种插件使用</title>
    <link href="http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/vue%E5%90%84%E7%A7%8D%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/vue%E5%90%84%E7%A7%8D%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-04-07T03:03:55.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="演示Vue各种插件的使用"><a href="#演示Vue各种插件的使用" class="headerlink" title="演示Vue各种插件的使用"></a>演示Vue各种插件的使用</h2><h3 id="1-Apache-ECharts"><a href="#1-Apache-ECharts" class="headerlink" title="1. Apache ECharts"></a>1. Apache ECharts</h3><ul><li><h4 id="1-用处：主要用于制作-各种数据图表-如-折线图、柱状图、饼装图等"><a href="#1-用处：主要用于制作-各种数据图表-如-折线图、柱状图、饼装图等" class="headerlink" title="(1) 用处：主要用于制作 各种数据图表 如 折线图、柱状图、饼装图等"></a>(1) 用处：主要用于制作 各种数据图表 如 折线图、柱状图、饼装图等</h4></li><li><h4 id="2-安装与配置"><a href="#2-安装与配置" class="headerlink" title="(2) 安装与配置"></a>(2) 安装与配置</h4><ul><li><p>1.npm安装 cnpm install echarts –save</p></li><li><p>2.在src&#x2F;main.js 中配置使用 echarts</p><p><img src="/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/%E5%90%84%E7%A7%8Dvue%E6%8F%92%E4%BB%B6/%E5%BC%95%E5%85%A5echarts.png"></p></li></ul></li><li><h4 id="3-使用（以-折线图为例）"><a href="#3-使用（以-折线图为例）" class="headerlink" title="(3) 使用（以 折线图为例）"></a>(3) 使用（以 折线图为例）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 创立一个dom 用于显示图表 --&gt;</span><br><span class="line">    &lt;div class=&quot;Echarts&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;main&quot; style=&quot;height: 400px; width: 500px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    name: &#x27;Echarts&#x27;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        myEcharts()&#123;</span><br><span class="line">            var myChart = this.$echarts.init(document.getElementById(&#x27;main&#x27;)); //获取dom</span><br><span class="line">            //绘制图表</span><br><span class="line">           var option=&#123;</span><br><span class="line">            tooltip : &#123;  //用于选择图形是哪一类</span><br><span class="line">                trigger: &#x27;axis&#x27;  </span><br><span class="line">            &#125;, </span><br><span class="line">            legend: &#123;  //有几条线 分别是什么</span><br><span class="line">                data:[&#x27;邮件营销&#x27;,&#x27;联盟广告&#x27;,&#x27;视频广告&#x27;,&#x27;直接访问&#x27;,&#x27;搜索引擎&#x27;]</span><br><span class="line">            &#125;,</span><br><span class="line">            toolbox: &#123;  //右上角的各种工具 如转换图等功能</span><br><span class="line">                show : true,</span><br><span class="line">                feature : &#123;</span><br><span class="line">                    // mark : &#123;show:true&#125;,</span><br><span class="line">                    // dataView : &#123;show:true, readOnly: false&#125;,</span><br><span class="line">                    // magicType : &#123;show:true, type: [&#x27;line&#x27;, &#x27;bar&#x27;, &#x27;stack&#x27;, &#x27;tiled&#x27;]&#125;,</span><br><span class="line">                    // restore : &#123;show:true&#125;,</span><br><span class="line">                    saveAsImage :&#123;show: true&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            calculable:true,  //固定配置</span><br><span class="line">            xAxis : [  //配置横轴(x轴)有哪些</span><br><span class="line">                        &#123;</span><br><span class="line">                            type : &#x27;category&#x27;,</span><br><span class="line">                            boundaryGap :false,</span><br><span class="line">                            data : [&#x27;周一&#x27;,&#x27;周二&#x27;,&#x27;周三&#x27;,&#x27;周四&#x27;,&#x27;周五&#x27;,&#x27;周六&#x27;,&#x27;周日&#x27;]</span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">            yAxis : [ //配置竖轴(y轴)有哪些</span><br><span class="line">                        &#123;</span><br><span class="line">                            type : &#x27;value&#x27;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    ],  </span><br><span class="line">            series : [  //配置各类型 的 结点数据</span><br><span class="line">                        &#123;</span><br><span class="line">                            name:&#x27;邮件营销&#x27;,</span><br><span class="line">                            type:&#x27;line&#x27;,</span><br><span class="line">                            stack: &#x27;总量&#x27;,</span><br><span class="line">                            data:[120, 132,101, 134, 90, 230, 210]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            name:&#x27;联盟广告&#x27;,</span><br><span class="line">                            type:&#x27;line&#x27;,</span><br><span class="line">                            stack: &#x27;总量&#x27;,</span><br><span class="line">                            data:[220, 182,191, 234, 290, 330, 310]</span><br><span class="line">                        &#125;, </span><br><span class="line">                        &#123;</span><br><span class="line">                            name:&#x27;视频广告&#x27;,</span><br><span class="line">                            type:&#x27;line&#x27;,</span><br><span class="line">                            stack: &#x27;总量&#x27;,</span><br><span class="line">                            data:[150, 232,201, 154, 190, 330, 410]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            name:&#x27;直接访问&#x27;,</span><br><span class="line">                            type:&#x27;line&#x27;,</span><br><span class="line">                            stack: &#x27;总量&#x27;,</span><br><span class="line">                            data:[320, 332,301, 334, 390, 330, 320]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            name:&#x27;搜索引擎&#x27;,</span><br><span class="line">                            type:&#x27;line&#x27;,</span><br><span class="line">                            stack: &#x27;总量&#x27;,</span><br><span class="line">                            data:[820, 932,901, 934, 1290, 1330, 1320]</span><br><span class="line">                        &#125;</span><br><span class="line">            ],        </span><br><span class="line">           &#125;;</span><br><span class="line">            myChart.setOption(option);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        this.myEcharts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;演示Vue各种插件的使用&quot;&gt;&lt;a href=&quot;#演示Vue各种插件的使用&quot; class=&quot;headerlink&quot; title=&quot;演示Vue各种插件的使用&quot;&gt;&lt;/a&gt;演示Vue各种插件的使用&lt;/h2&gt;&lt;h3 id=&quot;1-Apache-ECharts&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="-Vue -插件" scheme="http://example.com/tags/Vue-%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/%E6%96%B0%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2021/09/21/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/%E6%96%B0%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-09-21T03:57:36.000Z</published>
    <updated>2023-07-24T06:32:00.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-准备工具"><a href="#一、-准备工具" class="headerlink" title="一、 准备工具"></a>一、 准备工具</h3><ul><li><h4 id="1-node-js：用于Vue项目的依赖安装、构建等-运行的命令（npm）。"><a href="#1-node-js：用于Vue项目的依赖安装、构建等-运行的命令（npm）。" class="headerlink" title="1. node.js：用于Vue项目的依赖安装、构建等 运行的命令（npm）。"></a>1. node.js：用于Vue项目的依赖安装、构建等 运行的命令（npm）。</h4><h5 id="可通过-npm-v-与-node-v-来查看-是否安装成功"><a href="#可通过-npm-v-与-node-v-来查看-是否安装成功" class="headerlink" title="可通过 npm -v 与 node -v 来查看 是否安装成功"></a>可通过 npm -v 与 node -v 来查看 是否安装成功</h5></li><li><h4 id="2-对npm进行-国内镜像设置，加快依赖的下载"><a href="#2-对npm进行-国内镜像设置，加快依赖的下载" class="headerlink" title="2. 对npm进行 国内镜像设置，加快依赖的下载"></a>2. 对npm进行 国内镜像设置，加快依赖的下载</h4><h5 id="npm-install-g-cnpm-–registry-https-registry-npm-taobao-org"><a href="#npm-install-g-cnpm-–registry-https-registry-npm-taobao-org" class="headerlink" title="$ npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org"></a>$ npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></h5></li></ul><h3 id="二、项目初始化"><a href="#二、项目初始化" class="headerlink" title="二、项目初始化"></a>二、项目初始化</h3><ul><li><h4 id="1-安装-vue-cli"><a href="#1-安装-vue-cli" class="headerlink" title="1. 安装 vue-cli"></a>1. 安装 vue-cli</h4><h5 id="通过命令-cnpm-install-vue-cli-g-来全局安装"><a href="#通过命令-cnpm-install-vue-cli-g-来全局安装" class="headerlink" title="通过命令 cnpm install vue-cli -g  来全局安装"></a>通过命令 cnpm install vue-cli -g  来全局安装</h5><h5 id="安装完毕后，可使用-vue-list-来核实是否安装成功"><a href="#安装完毕后，可使用-vue-list-来核实是否安装成功" class="headerlink" title="安装完毕后，可使用 vue list 来核实是否安装成功"></a>安装完毕后，可使用 vue list 来核实是否安装成功</h5><p>![](&#x2F;Vue-cli 是否安装成功.png)</p></li><li><h4 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h4><h5 id="通过命令-vue-init-webpack-“项目名称”"><a href="#通过命令-vue-init-webpack-“项目名称”" class="headerlink" title="通过命令 vue init webpack “项目名称”"></a>通过命令 vue init webpack “项目名称”</h5><p><img src="/%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA.png"></p><h5 id="项目创建成功后目录"><a href="#项目创建成功后目录" class="headerlink" title="项目创建成功后目录"></a>项目创建成功后目录</h5><p><img src="/%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F%E7%9B%AE%E5%BD%95.png"></p></li><li><h4 id="3-下载项目必须依赖"><a href="#3-下载项目必须依赖" class="headerlink" title="3. 下载项目必须依赖"></a>3. 下载项目必须依赖</h4><h5 id="通过-npm-install-命令-下载依赖"><a href="#通过-npm-install-命令-下载依赖" class="headerlink" title="通过 npm install 命令 下载依赖"></a>通过 npm install 命令 下载依赖</h5><p>![](&#x2F;依赖下载完成 目录图.png)</p></li></ul><h3 id="三、项目启动"><a href="#三、项目启动" class="headerlink" title="三、项目启动"></a>三、项目启动</h3><h5 id="使用-npm-run-dev启动-项目"><a href="#使用-npm-run-dev启动-项目" class="headerlink" title="使用 npm run dev启动 项目"></a>使用 npm run dev启动 项目</h5><p><img src="/%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E5%9B%BE.png"></p><h3 id="四、整合VUE框架-element-UI"><a href="#四、整合VUE框架-element-UI" class="headerlink" title="四、整合VUE框架 element-UI"></a>四、整合VUE框架 element-UI</h3><ul><li><h4 id="1-引入-element-ui-的依赖"><a href="#1-引入-element-ui-的依赖" class="headerlink" title="1. 引入 element-ui 的依赖"></a>1. 引入 element-ui 的依赖</h4><h5 id="使用命令-cnpm-install-element-ui-–save-加入依赖"><a href="#使用命令-cnpm-install-element-ui-–save-加入依赖" class="headerlink" title="使用命令 cnpm install element-ui –save 加入依赖"></a>使用命令 cnpm install element-ui –save 加入依赖</h5><p>可在package.json 文件 查看element-ui 版本 得知是否安装成功</p><p><img src="/%E6%9F%A5%E7%9C%8Belement-ui%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"></p></li><li><h4 id="2-在-src-main-js-中，配置element-ui"><a href="#2-在-src-main-js-中，配置element-ui" class="headerlink" title="2. 在 src&#x2F;main.js 中，配置element-ui"></a>2. 在 src&#x2F;main.js 中，配置element-ui</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 element-ui</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"><span class="comment">//使用element-ui</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br><span class="line"><span class="comment">// 设置 elementUI 组件的默认大小</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>,&#123;<span class="attr">size</span>: <span class="string">&#x27;small&#x27;</span>,<span class="attr">zIndex</span>: <span class="number">3000</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/%E5%88%9B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/element-ui%E9%85%8D%E7%BD%AE.png"></p></li></ul><h3 id="五、-去除地址栏的-号"><a href="#五、-去除地址栏的-号" class="headerlink" title="五、 去除地址栏的#号"></a>五、 去除地址栏的#号</h3><ul><li><h5 id="在src-router-index-js-中设置-mode属性"><a href="#在src-router-index-js-中设置-mode属性" class="headerlink" title="在src&#x2F;router&#x2F;index.js 中设置 mode属性"></a>在src&#x2F;router&#x2F;index.js 中设置 mode属性</h5><img src="/%E5%8E%BB%E9%99%A4%E5%9C%B0%E5%9D%80%E6%A0%8F%E7%9A%84#%E5%8F%B7.png"></li></ul><h3 id="六、修改标题icon图标"><a href="#六、修改标题icon图标" class="headerlink" title="六、修改标题icon图标"></a>六、修改标题icon图标</h3><ul><li><h4 id="在-index-html中-通过link标签引入icon图标"><a href="#在-index-html中-通过link标签引入icon图标" class="headerlink" title="在 index.html中 通过link标签引入icon图标"></a>在 index.html中 通过link标签引入icon图标</h4><p><img src="/%E8%AE%BE%E7%BD%AEicon%E6%A0%87%E9%A2%98%E5%9B%BE%E6%A0%871.png"></p></li><li><h4 id="在-build-webpack-dev-conf-js-中设置属性"><a href="#在-build-webpack-dev-conf-js-中设置属性" class="headerlink" title="在 build&#x2F;webpack.dev.conf.js 中设置属性"></a>在 build&#x2F;webpack.dev.conf.js 中设置属性</h4><p><img src="/%E8%AE%BE%E7%BD%AEicon%E5%9B%BE%E6%A0%872.png"></p></li><li><h4 id="在build-webpack-prod-conf-js中-设置属性"><a href="#在build-webpack-prod-conf-js中-设置属性" class="headerlink" title="在build&#x2F;webpack.prod.conf.js中 设置属性"></a>在build&#x2F;webpack.prod.conf.js中 设置属性</h4><p><img src="/%E8%AE%BE%E7%BD%AEicon%E5%9B%BE%E6%A0%873.png"></p></li><li><h4 id="功能需要重启项目后才能生效"><a href="#功能需要重启项目后才能生效" class="headerlink" title="功能需要重启项目后才能生效"></a>功能需要重启项目后才能生效</h4></li></ul><h3 id="七、加入vuex插件"><a href="#七、加入vuex插件" class="headerlink" title="七、加入vuex插件"></a>七、加入vuex插件</h3><ul><li><h4 id="1-用处：在vue项目模块化的设计当中，一个vue页面，需要引入-多个vue页面模块-如-固定的导航栏模块等。各自的模块中，都有自身的-data-数据和方法，正常来说-各自模块中的data数据与方法-是-互不相干的，虽然引入了-该模块，但是却不能-操作该模块中-data数据-以及-调用方法。-这时，就可以使用-vuex-来统一管理这些个-需要跨越模块限制，共同使用-模块的数据与方法。-（注意：vuex-的作用域-是在同一个页面-既-同一个vue，并不是跨页面-管理）"><a href="#1-用处：在vue项目模块化的设计当中，一个vue页面，需要引入-多个vue页面模块-如-固定的导航栏模块等。各自的模块中，都有自身的-data-数据和方法，正常来说-各自模块中的data数据与方法-是-互不相干的，虽然引入了-该模块，但是却不能-操作该模块中-data数据-以及-调用方法。-这时，就可以使用-vuex-来统一管理这些个-需要跨越模块限制，共同使用-模块的数据与方法。-（注意：vuex-的作用域-是在同一个页面-既-同一个vue，并不是跨页面-管理）" class="headerlink" title="(1) 用处：在vue项目模块化的设计当中，一个vue页面，需要引入 多个vue页面模块 如 固定的导航栏模块等。各自的模块中，都有自身的 data() 数据和方法，正常来说 各自模块中的data数据与方法 是 互不相干的，虽然引入了 该模块，但是却不能 操作该模块中 data数据 以及 调用方法。 这时，就可以使用 vuex 来统一管理这些个 需要跨越模块限制，共同使用 模块的数据与方法。 （注意：vuex 的作用域 是在同一个页面 既 同一个vue，并不是跨页面 管理）"></a>(1) 用处：在vue项目模块化的设计当中，一个vue页面，需要引入 多个vue页面模块 如 固定的导航栏模块等。各自的模块中，都有自身的 data() 数据和方法，正常来说 各自模块中的data数据与方法 是 互不相干的，虽然引入了 该模块，但是却不能 操作该模块中 data数据 以及 调用方法。 这时，就可以使用 vuex 来统一管理这些个 需要跨越模块限制，共同使用 模块的数据与方法。 （注意：vuex 的作用域 是在同一个页面 既 同一个vue，并不是跨页面 管理）</h4></li><li><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="(2) 安装"></a>(2) 安装</h4><ul><li><h4 id="安装命令：-cnpm-install-vuex-–save"><a href="#安装命令：-cnpm-install-vuex-–save" class="headerlink" title="安装命令： cnpm install vuex –save"></a>安装命令： cnpm install vuex –save</h4></li><li><h4 id="注意事项：-vuex-会与-vue-版本进行挂钩，如果-vue版本在2-x-x-则-vuex的版本-需要是3-x-x-以此类推"><a href="#注意事项：-vuex-会与-vue-版本进行挂钩，如果-vue版本在2-x-x-则-vuex的版本-需要是3-x-x-以此类推" class="headerlink" title="注意事项： vuex 会与 vue 版本进行挂钩，如果 vue版本在2.x.x 则 vuex的版本 需要是3.x.x 以此类推"></a>注意事项： vuex 会与 vue 版本进行挂钩，如果 vue版本在2.x.x 则 vuex的版本 需要是3.x.x 以此类推</h4></li><li><h4 id="安装指定版本命令：-cnpm-install-–save-x76-x75-x65-x78-64-51-x2e-54-x2e-x32"><a href="#安装指定版本命令：-cnpm-install-–save-x76-x75-x65-x78-64-51-x2e-54-x2e-x32" class="headerlink" title="安装指定版本命令： cnpm install –save &#x76;&#x75;&#x65;&#x78;&#64;&#51;&#x2e;&#54;&#x2e;&#x32;"></a>安装指定版本命令： cnpm install –save <a href="mailto:&#x76;&#x75;&#x65;&#x78;&#64;&#51;&#x2e;&#54;&#x2e;&#x32;">&#x76;&#x75;&#x65;&#x78;&#64;&#51;&#x2e;&#54;&#x2e;&#x32;</a></h4></li></ul></li><li><h4 id="3-整体布局vuex"><a href="#3-整体布局vuex" class="headerlink" title="(3) 整体布局vuex"></a>(3) 整体布局vuex</h4><p>![](&#x2F;Vuex store目录.png)</p><ul><li><h5 id="1-创建-store目录-用于管理编写-vuex中的-各种文件"><a href="#1-创建-store目录-用于管理编写-vuex中的-各种文件" class="headerlink" title="1. 创建 store目录 用于管理编写 vuex中的 各种文件"></a>1. 创建 store目录 用于管理编写 vuex中的 各种文件</h5></li><li><h5 id="2-编写-index-js"><a href="#2-编写-index-js" class="headerlink" title="2. 编写 index.js"></a>2. 编写 index.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于 管理store的整体模块 可在main.js 引用该文件 </span></span><br><span class="line"><span class="comment">//以此运用在整体vue项目</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; systemData &#125; <span class="keyword">from</span> <span class="string">&#x27;./system.js&#x27;</span>  <span class="comment">//引入 state布局</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters.js&#x27;</span>  <span class="comment">//引入数据获取文件</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">modules</span>: &#123;</span><br><span class="line">        systemData  <span class="comment">//引入模块</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><h5 id="3-编写-system-js"><a href="#3-编写-system-js" class="headerlink" title="3. 编写 system.js"></a>3. 编写 system.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来初始化 vuex的基本架构（相当于一个 vuex模块）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> systemData=&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;  <span class="comment">//定义vuex交互的数据</span></span><br><span class="line">        <span class="attr">temp</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;  <span class="comment">//用改改变state数据的方法</span></span><br><span class="line">        <span class="comment">//修改temp的值 </span></span><br><span class="line">        <span class="comment">//state：指上面的state列表</span></span><br><span class="line">        <span class="comment">//data: 修改temp的值</span></span><br><span class="line">        <span class="title function_">changeTemp</span>(<span class="params">state,data</span>)&#123;</span><br><span class="line">            state.<span class="property">temp</span>=data;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123;  <span class="comment">//代替执行 mutations中的方法，暴露给使用者 可以实现异步操作</span></span><br><span class="line">        <span class="comment">//该方法用于修改 temp的值，调用 mutations 的 changeTemp方法</span></span><br><span class="line">        <span class="comment">//commit: vuex中的 专门用于 提交方法的对象</span></span><br><span class="line">        <span class="comment">//data: 修改temp值的参数</span></span><br><span class="line">        <span class="title function_">setTemp</span>(<span class="params">&#123;commit&#125;,data</span>)&#123;</span><br><span class="line">            <span class="comment">//调用 changeTemp方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">commit</span>(<span class="string">&#x27;changeTemp&#x27;</span>,data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="4-编写getters-js"><a href="#4-编写getters-js" class="headerlink" title="4. 编写getters.js"></a>4. 编写getters.js</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本文件 主要用于 封装state中 的数据</span></span><br><span class="line"><span class="comment">// 这样就不用 每次使用数据 都要写很长的一段state.systemData.xxx</span></span><br><span class="line"><span class="type">const</span> <span class="variable">systemData</span> <span class="operator">=</span> &#123;</span><br><span class="line">    temp: state =&gt; state.systemData.temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> systemData</span><br></pre></td></tr></table></figure></li><li><h5 id="5-编写src-utils-mixins-js"><a href="#5-编写src-utils-mixins-js" class="headerlink" title="5. 编写src&#x2F;utils&#x2F;mixins.js"></a>5. 编写src&#x2F;utils&#x2F;mixins.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本文件主要用于 具体调用vuex中的方法和数据</span></span><br><span class="line"><span class="comment">//用户需要使用state的话 可以直接 引用该类即可,就不需要引用那么多类对象了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入 vuex 特定的 类</span></span><br><span class="line"><span class="keyword">import</span> &#123;mapGetters,mapActions&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> systemMixins = &#123;</span><br><span class="line">    <span class="comment">//主要在computed 中 执行 获取 state的数据</span></span><br><span class="line">    <span class="attr">computed</span>: &#123;  </span><br><span class="line">        ...<span class="title function_">mapGetters</span>([  <span class="comment">//映射</span></span><br><span class="line">            <span class="string">&#x27;temp&#x27;</span>,  <span class="comment">//需要获取的数据</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;  </span><br><span class="line">        ...<span class="title function_">mapActions</span>([  <span class="comment">//映射</span></span><br><span class="line">            <span class="string">&#x27;setTemp&#x27;</span>, <span class="comment">//获取的方法</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="6-在src-main-js-中-引入-vuex-，使得全局生效"><a href="#6-在src-main-js-中-引入-vuex-，使得全局生效" class="headerlink" title="6. 在src&#x2F;main.js 中 引入 vuex ，使得全局生效"></a>6. 在src&#x2F;main.js 中 引入 vuex ，使得全局生效</h5><p><img src="/%E5%9C%A8main.js%E4%B8%AD%E9%85%8D%E7%BD%AEvuex.png"></p></li></ul></li><li><h4 id="4-如何使用："><a href="#4-如何使用：" class="headerlink" title="(4) 如何使用："></a>(4) 如何使用：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;tempData&#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;el-button @click=&quot;save&quot;&gt;存储数据&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button @click=&quot;get&quot;&gt;获取数据&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; systemMixins &#125; from &#x27;@/utils/mixins.js&#x27;  //引用已经封装好的state数据</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    mixins: [systemMixins],  //使用 vue自带的 mixins 引用 systemMixins</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            tempData: &#x27;&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        get()&#123;</span><br><span class="line">            this.tempData=this.temp //直接获取temp</span><br><span class="line">        &#125;,</span><br><span class="line">        save()&#123;</span><br><span class="line">            this.setTemp(&#x27;xxx&#x27;)  //直接使用vuex中的方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、-准备工具&quot;&gt;&lt;a href=&quot;#一、-准备工具&quot; class=&quot;headerlink&quot; title=&quot;一、 准备工具&quot;&gt;&lt;/a&gt;一、 准备工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1-node-js：用于Vue项目的依赖安装、构建等-运行的命令（npm</summary>
      
    
    
    
    
    <category term="-前端 -Vue" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF-Vue/"/>
    
  </entry>
  
</feed>
